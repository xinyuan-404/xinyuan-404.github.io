<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinyuan&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/cb5dd586f32c8841e8838c89301eb7fa</icon>
  <subtitle>鑫缘的blog</subtitle>
  <link href="http://websec.space/atom.xml" rel="self"/>
  
  <link href="http://websec.space/"/>
  <updated>2021-12-31T18:00:26.751Z</updated>
  <id>http://websec.space/</id>
  
  <author>
    <name>鑫缘</name>
    <email>xy_404@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新年快乐</title>
    <link href="http://websec.space/2022/01/01/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
    <id>http://websec.space/2022/01/01/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2021-12-31T18:00:26.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h1><p>新的一年，更加努力与坚持，更加灵活，不断向前，加油吧！</p><p>今年是我在安全领域的第一年，回想过去一年所经历的比赛，仿佛都历历在目，本想归纳记录一下，奈何太懒了，今天是2020.01.01，首先祝大家新年快乐吖！</p><p>现在来盘点记录一下今年在安全领域所经历的比较记忆犹新的事情，也感谢各位在这条路上一直帮助我的老师和同学，新的一年，大家继续努力。</p><h2 id="2021年寒假线上实训"><a href="#2021年寒假线上实训" class="headerlink" title="2021年寒假线上实训"></a>2021年寒假线上实训</h2><p>结识了杨老师，并且在老师的指导下，开始了在暗网方面的相关研究工作。</p><h2 id="ciscn作品赛"><a href="#ciscn作品赛" class="headerlink" title="ciscn作品赛"></a>ciscn作品赛</h2><p>第一次参加国赛，也是第一次做安全研发，大一上主要参加两个比赛，第一次参赛，也是误打误撞就进了决赛，继续准备调试，做了许多遍，在即将启程出发青岛参加决赛时，疫情反复，在出发的前一天比赛取消了，推迟（今年可能令许多安全参赛同学最无奈的就是疫情吧）。</p><p>在暑假过去一半的时候草草回家，等待比赛的时期</p><img src="https://img-blog.csdnimg.cn/4744627185fc453da9f64e94ac8ccce7.png" alt="img" style="zoom: 33%;" /><p>最后被分到总体做的还算比较满意，最后系统也实现了，答辩也回答了老师们的问题。</p><img src="https://img-blog.csdnimg.cn/2b9e6b0d1a784965aab91b002815c2f7.png" alt="img" style="zoom:50%;" /><h2 id="尖峰训练营"><a href="#尖峰训练营" class="headerlink" title="尖峰训练营"></a>尖峰训练营</h2><p>2021年开始立项的第一个项目，也是让我经历从一个小白到真正入门的第一个项目，见证了开发一个安全产品的全过程。</p><p>附一张决赛时的图片，也是第一次出去打比赛，武汉很爱。</p><img src="https://img-blog.csdnimg.cn/284eb45e8486456cb5eff823deeb022d.png" alt="img" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/7ad5ef24b98342d9b0bf88ca599c49e5.png" alt="img" style="zoom:50%;" /><p>待遇也很爱，宾馆很好，早餐也很爱。</p><img src="https://img-blog.csdnimg.cn/3f35b6b70af648208025f0d98b78c6d7.png" alt="img" style="zoom:50%;" /><img src="C:\Users\97085\AppData\Roaming\Typora\typora-user-images\image-20220101010208749.png" alt="image-20220101010208749" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/f4e424b644f647f78ca050074fe2137a.png" alt="img" style="zoom:50%;" /><p>最后拿到了团队赛二等奖，前四的成绩哈哈哈，也算让自己在安全领域慢慢建立起了信心。</p><img src="https://img-blog.csdnimg.cn/6af1f74ad56245fe8c46dbd092650bad.png" alt="img" style="zoom:50%;" /><p>感谢老师们的支持，也感谢洁哥此处@brey在关键时刻提供的支持，多少次感觉要放弃时，洁哥的关键建议总能成为不断推进的可行方案。</p><p>也第一次接触了龙芯，也做了一些比较创新的小操作，想想还是蛮有趣的。</p><h2 id="网络运维纳新"><a href="#网络运维纳新" class="headerlink" title="网络运维纳新"></a>网络运维纳新</h2><p>可能大学都有那么几个地方，有一帮志同道合的朋友，又到了一年的开学季，网络运维开始纳新，准备很多哈哈</p><p>看到了形形色色的新同学，有时候也感慨自己技术好菜，不及很多大一的同学，忙忙碌碌两个月网络运维也算完成新的一年的组建。</p><img src="https://img-blog.csdnimg.cn/a861529fd77c4571bd9fb5f601e7e8bd.png" alt="img" style="zoom:33%;" /><h2 id="穹镜SkyMirror成立"><a href="#穹镜SkyMirror成立" class="headerlink" title="穹镜SkyMirror成立"></a>穹镜SkyMirror成立</h2><p>马工的推荐下，正式以穹镜SkyMirror，穹镜的成立也形成工大又一个崭新的安全圈子，正如在组建的时候所说，穹镜安全所展开的面很广，按照大家兴趣去做自己的方向，新的一年穹镜加油。</p><p>（安全组:想在互联网上成为一名漏洞猎人吗,想为打击互联网黑产奉献一份力量吗,想成为一名帅气的 CTFer 吗?我们有奋斗于安全一线的 Hacker ,或痴迷用代码改变世界 Programmer ,亦不乏潜心钻研的 Geeker 。我们始终不安一偶,崇尚技术,不断在信息安全的传统界线上寻求挑战和突破。在这里有咱们运维部门的安全工程师,也有不断努力学习的学长,加入我们,共同努力,大家一起变得更强。）</p><h2 id="美亚杯”第七届中国电子数据取证大赛"><a href="#美亚杯”第七届中国电子数据取证大赛" class="headerlink" title="美亚杯”第七届中国电子数据取证大赛"></a>美亚杯”第七届中国电子数据取证大赛</h2><p>被百度云和硬盘搞心态的一个比赛，也算是穹镜在组建以后大家参加的第一个比赛。</p><p>有时候下载一个晚上第二天发现</p><img src="https://img-blog.csdnimg.cn/7a6e6031283a496989bc3580db9ce2ea.png" alt="img" style="zoom:33%;" /><p>网不行就上千兆网，盘不行就加盘</p><img src="https://img-blog.csdnimg.cn/52e23ef0990c46118d185edfa7f5235c.png" alt="img" style="zoom: 33%;" /><p>也非常感谢老师在这次比赛中给的帮助，咱急需硬盘的时候，老师直接给送来了笔记本，保证能人手一个比赛设备，虽然最后检材没预期那么大。</p><p>开赛当天真的是一头雾水，解压密码被&lt;&gt;给闭合了，前半个小时心态不太好，结果打完资格赛结果出乎意料的不错。</p><p>有了资格赛的信心，团队赛打的相对更加自信，也更有张力。</p><p>最后鑫缘竟然拿了资格赛一等奖（属实出乎意料，之前接触取证不多），穹镜参加的两支队都拿到了一等奖。</p><h2 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h2><p>继续坚持走自己的路，明年的元旦，可能已经要开始准备考研了，明年也要慢慢扩充穹在各个安全方向的人员，马工的回归肯定能让穹镜更加强大，也更希望能够想加入我们一起玩安全的好兄弟。</p><p>在做安全的这条路上，不玩虚的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;新年快乐&quot;&gt;&lt;a href=&quot;#新年快乐&quot; class=&quot;headerlink&quot; title=&quot;新年快乐&quot;&gt;&lt;/a&gt;新年快乐&lt;/h1&gt;&lt;p&gt;新的一年，更加努力与坚持，更加灵活，不断向前，加油吧！&lt;/p&gt;
&lt;p&gt;今年是我在安全领域的第一年，回想过去一年所经历的比赛，</summary>
      
    
    
    
    <category term="闲聊" scheme="http://websec.space/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="http://websec.space/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>python基础函数的基本使用</title>
    <link href="http://websec.space/2021/12/21/python%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://websec.space/2021/12/21/python%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-20T16:00:00.000Z</published>
    <updated>2021-12-20T06:51:27.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h1><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>函数是一段具有特定功能的、可重用的语句组，用函数名来表示并通过函数名进行完成功能调用。</p><p>函数也可以看作是一段具有名字的子程序，可以在需要的地方调用执行，不需要在每个执行地方重复编写这些语句。每次使用函数可以提供不同的参数作为输入，以实现对不同数据的处理；函数执行后，还可以反馈相应的处理结果。</p><p>Python定义一个函数使用def保留字，语法形式如下：</p><p>def &lt;函数名&gt;(&lt;参数列表&gt;):</p><p>​    &lt;函数体&gt;</p><p>​    return &lt;返回值列表&gt;</p><p>程序调用一个函数需要执行以下四个步骤：</p><p>（1）调用程序在调用处暂停执行；</p><p>（2）在调用时将实参复制给函数的形参；</p><p>（3）执行函数体语句；</p><p>（4）函数调用结束给出返回值，程序回到调用前的暂停处继续执行。</p><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>匿名函数，又称lambda函数。</p><p>匿名函数并非没有名字，而是将函数名作为函数结果返回</p><p>&lt;函数名&gt; = lambda &lt;参数列表&gt;: &lt;表达式&gt;</p><p>lambda函数与正常函数一样，等价于下面形式：</p><p>def &lt;函数名&gt;(&lt;参数列表&gt;):</p><p>​    return &lt;表达式&gt;</p><p>简单说，lambda函数用于定义简单的、能够在一行内表示的函数，返回一个函数类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">type</span>(f)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">f</span>(<span class="params"><span class="number">10</span>, <span class="number">12</span></span>)</span></span><br><span class="line"><span class="class">22</span></span><br></pre></td></tr></table></figure><h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><p>可选参数和可变数量参数</p><p>在定义函数时，有些参数可以存在默认值</p><p>由于函数调用时需要按顺序输入参数，可选参数必须定义在 非可选参数的后面。即dup函数中带默认值的可选参数times必须定义在str参数后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">dup</span>(<span class="params"><span class="built_in">str</span>, times = <span class="number">2</span></span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="built_in">str</span>*times)</span><br><span class="line">&gt;&gt;&gt;dup(<span class="string">&quot;knock~&quot;</span>)</span><br><span class="line">knock~knock~</span><br><span class="line">&gt;&gt;&gt;dup(<span class="string">&quot;knock~&quot;</span>,<span class="number">4</span>)</span><br><span class="line">knock~knock~knock~knock~</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在函数定义时，可以设计可变数量参数，通过参数前增加星号（*）实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">vfunc</span>(<span class="params">a, *b</span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line">       <span class="keyword">for</span> n <span class="keyword">in</span> b:</span><br><span class="line">           a += n</span><br><span class="line">       <span class="keyword">return</span> a</span><br><span class="line">&gt;&gt;&gt;vfunc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">15</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><h4 id="参数的位置和名称传递"><a href="#参数的位置和名称传递" class="headerlink" title="参数的位置和名称传递"></a>参数的位置和名称传递</h4><p>参数较多时，采用按照位置顺序的方式传递给参数，可读性较差</p><p>假设func()函数有6个参数，定义如下：</p><p>func(x1, y1, z1, x2, y2, z2)</p><p>​    return</p><p>调用  </p><p>Result = func(1, 2, 3, 4, 5, 6)</p><p>如果仅看实际调用而不看函数定义，很难理解这些输入参数的含义</p><p>Python提供了按照形参名称输入实参的方式，调用如下：</p><p>result = func(x2=4, y2=5, z2=6, x1=1, y1=2, z1=3)</p><p>由于调用函数时指定了参数名称，所以参数之间的顺序可以任意调整</p><h3 id="变量的返回值"><a href="#变量的返回值" class="headerlink" title="变量的返回值"></a>变量的返回值</h3><p>return语句用来退出函数并将程序返回到函数被调用的位置继续执行。</p><p>return语句同时可以将0个、1个或多个函数运算完的结果返回给函数被调用处的变量。</p><p>函数也可以用return返回多个值，多个值以元组类型保存</p><h4 id="函数对变量的作用"><a href="#函数对变量的作用" class="headerlink" title="函数对变量的作用"></a>函数对变量的作用</h4><p>一个程序中的变量包括两类：全局变量和局部变量。</p><p>全局变量指在函数之外定义的变量，一般没有缩进，在程序执行全过程有效。</p><p>局部变量指在函数内部使用的变量，仅在函数内部有效，当函数退出时变量将不存在。</p><p>变量的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;n = <span class="number">1</span>    <span class="comment">#n是全局变量</span></span><br><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line">       c = a * b     <span class="comment">#c是局部变量，a和b作为函数参数也是局部变量</span></span><br><span class="line">       <span class="keyword">return</span> c</span><br><span class="line">&gt;&gt;&gt;s = func(<span class="string">&quot;knock~&quot;</span>, <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(c)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#6&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">NameError: name <span class="string">&#x27;c&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当函数执行完退出后，其内部变量将被释放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;n = <span class="number">1</span>    <span class="comment">#n是全局变量</span></span><br><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line">       n = b     <span class="comment">#这个n是在函数内存中新生成的局部变量，不是全局变量 </span></span><br><span class="line">       <span class="keyword">return</span> a*b</span><br><span class="line">&gt;&gt;&gt;s = func(<span class="string">&quot;knock~&quot;</span>, <span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(s, n)  <span class="comment">#测试一下n值是否改变</span></span><br><span class="line">knock~knock~ <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数的基本使用&quot;&gt;&lt;a href=&quot;#函数的基本使用&quot; class=&quot;headerlink&quot; title=&quot;函数的基本使用&quot;&gt;&lt;/a&gt;函数的基本使用&lt;/h1&gt;&lt;h3 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="python" scheme="http://websec.space/categories/python/"/>
    
    
    <category term="python" scheme="http://websec.space/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python基础(二)</title>
    <link href="http://websec.space/2021/12/20/python%E5%9F%BA%E7%A1%80(%E4%BA%8C)/"/>
    <id>http://websec.space/2021/12/20/python%E5%9F%BA%E7%A1%80(%E4%BA%8C)/</id>
    <published>2021-12-19T16:00:00.000Z</published>
    <updated>2021-12-20T06:44:55.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python基础-二"><a href="#python基础-二" class="headerlink" title="python基础(二)"></a>python基础(二)</h1><h2 id="程序的基本结构"><a href="#程序的基本结构" class="headerlink" title="程序的基本结构"></a>程序的基本结构</h2><p>程序流程图用一系列图形、流程线和文字说明描述程序的基本操作和控制流程，它是程序分析和过程描述的最基本方式。</p><p><img src="https://img-blog.csdnimg.cn/2d0deb534583469d972936b39e4a3f4d.png" alt="img"></p><p>程序由三种基本结构组成：</p><p>顺序结构</p><p>分支结构</p><p>循环结构</p><p>这些基本结构都有一个入口和一个出口。任何程序都由这三种基本结构组合而成</p><blockquote><p>顺序结构是程序按照线性顺序依次执行的一种运行方式，其中语句块1和语句块2表示一个或一组顺序执行的语句 </p><p>分支结构是程序根据条件判断结果而选择不同向前执行路径的一种运行方式，包括单分支结构和二分支结构。由二分支结构会组合形成多分支结构</p><p>循环结构是程序根据条件判断结果向后反复执行的一种运行方式，根据循环体触发条件不同，包括条件循环和遍历循环结构</p></blockquote><h2 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h2><p>Python中if语句的语法格式如下：</p><p>if &lt;条件&gt;:</p><p>  语句块</p><p>语句块是if条件满足后执行的一个或多个语句序列</p><p>语句块中语句通过与if所在行形成缩进表达包含关系</p><p>if语句首先评估&lt;条件&gt;的结果值，如果结果为True，则执行语句块里的语句序列，然后控制转向程序的下一条语句。如果结果为False，语句块里的语句会被跳过。 </p><h3 id="单分支语句"><a href="#单分支语句" class="headerlink" title="单分支语句"></a>单分支语句</h3><p>if语句中语句块执行与否依赖于条件判断。但无论什么情况，控制都会转到if语句后与该语句同级别的下一条语句 </p><p>if语句中&lt;条件&gt;部分可以使用任何能够产生True或False的语句</p><p>形成判断条件最常见的方式是采用关系操作符</p><table><thead><tr><th>操作符</th><th>数学符号</th><th>操作符含义</th></tr></thead><tbody><tr><td><em>&lt;</em></td><td><em>&lt;</em></td><td>小于</td></tr><tr><td><em>&lt;=</em></td><td><em>≤</em></td><td>小于等于</td></tr><tr><td><em>&gt;=</em></td><td><em>≥</em></td><td>大于等于</td></tr><tr><td><em>&gt;</em></td><td><em>&gt;</em></td><td>大于</td></tr><tr><td><em>==</em></td><td><em>=</em></td><td>等于</td></tr><tr><td>!<em>=</em></td><td></td><td>不等于</td></tr></tbody></table><p>二分支结构: if-else语句</p><p>Python中if-else语句用来形成二分支结构，语法格式如下：</p><p>if &lt;条件&gt;:</p><p>  &lt;语句块1&gt;</p><p>else:</p><p>  &lt;语句块2&gt;</p><p>&lt;语句块1&gt;是在if条件满足后执行的一个或多个语句序列</p><p>&lt;语句块2&gt;是if条件不满足后执行的语句序列</p><p>二分支语句用于区分&lt;条件&gt;的两种可能True或者False，分别形成执行路径</p><blockquote><p>二分支结构还有一种更简洁的表达方式，适合通过判断返回特定值，语法格式如下：</p><p>&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;</p></blockquote><h3 id="多分支结构-if-elif-else语句"><a href="#多分支结构-if-elif-else语句" class="headerlink" title="多分支结构: if-elif-else语句"></a>多分支结构: if-elif-else语句</h3><p>Python的if-elif-else描述多分支结构，语句格式如下：</p><p>if &lt;条件1&gt;:</p><p>​    &lt;语句块1&gt;</p><p>elif &lt;条件2&gt;:</p><p>​    &lt;语句块2&gt;</p><p>… </p><p>else: </p><p>​    &lt;语句块N&gt;</p><p>多分支结构是二分支结构的扩展，这种形式通常用于设置同一个判断条件的多条执行路径。</p><p>Python依次评估寻找第一个结果为True的条件，执行该条件下的语句块，同时结束后跳过整个if-elif-else结构，执行后面的语句。如果没有任何条件成立，else下面的语句块被执行。else子句是可选的 </p><h2 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h2><h3 id="遍历循环"><a href="#遍历循环" class="headerlink" title="遍历循环"></a>遍历循环</h3><p>  根据循环执行次数的确定性，循环可以分为确定次数循环和非确定次数循环。确定次数循环指循环体对循环次数有明确的定义，循环次数采用遍历结构中元素个数来体现。</p><p>Python通过保留字for实现“遍历循环” ：</p><p>for &lt;循环变量&gt; in &lt;遍历结构&gt;:</p><p>  &lt;语句块&gt;</p><p>遍历结构可以是字符串、文件、组合数据类型或range()函数：</p><table><thead><tr><th>循环N次  for  i in  range(N):     &lt;语句块&gt;</th><th>遍历文件fi的每一行  for  line in fi:    &lt;语句块&gt;</th><th>遍历字符串s   for  c in s:    &lt;语句块&gt;</th><th>遍历列表ls   for  item in ls:    &lt;语句块&gt;</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>遍历循环还有一种扩展模式，使用方法如下：</p><p>for &lt;循环变量&gt; in &lt;遍历结构&gt;:</p><p>​    &lt;语句块1&gt;</p><p>else:</p><p>​    &lt;语句块2&gt;</p><p>当for循环正常执行之后，程序会继续执行else语句中内容。<strong>else语句只在循环正常执行之后才执行并结束，</strong>因此，可以在&lt;语句块2&gt;中放置判断循环执行情况的语句</p><h3 id="无限循环-while语句"><a href="#无限循环-while语句" class="headerlink" title="无限循环: while语句"></a>无限循环: while语句</h3><p>无限循环：</p><p>无限循环一直保持循环操作直到特定循环条件不被满足才结束，不需要提前知道确定循环次数。</p><p>Python通过保留字while实现无限循环，使用方法如下：</p><p>while &lt;条件&gt;:</p><p>​    &lt;语句块&gt;</p><p>无限循环也有一种使用保留字else的扩展模式，else语句只在循环正常执行之后才执行：</p><p>while &lt;条件&gt;:</p><p>​    &lt;语句块1&gt;</p><p>else:</p><p>​    &lt;语句块2&gt;</p><h3 id="循环保留字-break和continue"><a href="#循环保留字-break和continue" class="headerlink" title="循环保留字: break和continue"></a>循环保留字: break和continue</h3><p>循环结构有两个辅助保留字：break和continue，它们用来辅助控制循环执行</p><p>break用来跳出最内层for或while循环，脱离该循环后程序从循环后代码继续执行 </p><blockquote><p>其中，break语句跳出了最内层for循环，但仍然继续执行外层循环。每个break语句只有能力跳出当前层次循环 </p></blockquote><p>continue用来结束当前当次循环，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。</p><p>对于while循环，继续求解循环条件。而对于for循环，程序流程接着遍历循环列表</p><blockquote><p>continue语句和break语句的区别是：</p><p>continue语句只结束本次循环，而不终止整个循环的执行。</p><p>break语句则是结束整个循环过程，不再判断执行循环的条件是否成立</p></blockquote><p>for循环和while循环中都存在一个else扩展用法。</p><p>else中的语句块只在一种条件下执行，即循环正常遍历了所有内容没有因为break或return而退出。</p><p>continue保留字对else没有影响。</p><h2 id="random库概述"><a href="#random库概述" class="headerlink" title="random库概述"></a>random库概述</h2><p>随机数在计算机应用中十分常见，Python内置的random库主要用于产生各种分布的伪随机数序列。random库采用梅森旋转算法（Mersenne twister）生成伪随机数序列，可用于除随机性要求更高的加解密算法外的大多数工程应用。</p><p>使用random库主要目的是生成随机数，因此，读者只需要查阅该库的随机数生成函数，找到符合使用场景的函数使用即可。这个库提供了不同类型的随机数函数，所有函数都是基于最基本的random.random()函数扩展而来。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>seed(a=None)</td><td>初始化随机数种子，默认值为当前系统时间</td></tr><tr><td>random()</td><td>生成一个[0.0,  1.0)之间的随机小数</td></tr><tr><td>randint(a, b)</td><td>生成一个[a,b]之间的整数</td></tr><tr><td>getrandbits(k)</td><td>生成一个k比特长度的随机整数</td></tr><tr><td>randrange(start, stop[, step])</td><td>生成一个[start,  stop)之间以step为步数的随机整数</td></tr><tr><td>uniform(a, b)</td><td>生成一个[a,  b]之间的随机小数</td></tr><tr><td>choice(seq)</td><td>从序列类型(例如：列表)中随机返回一个元素</td></tr><tr><td>shuffle(seq)</td><td>将序列类型中元素随机排列，返回打乱后的序列</td></tr><tr><td>sample(pop, k)</td><td>从pop类型中随机选取k个元素，以列表类型返回</td></tr></tbody></table><p>生成随机数之前可以通过seed()函数指定随机数种子，随机种子一般是一个整数，只要种子相同，每次生成的随机数序列也相同。这种情况便于测试和同步数据</p><blockquote><p>好一个序列密码</p></blockquote><h2 id="程序的异常处理"><a href="#程序的异常处理" class="headerlink" title="程序的异常处理"></a>程序的异常处理</h2><p>初学不必太过于计较这个地方</p><blockquote><p>Python异常信息中最重要的部分是异常类型，它表明了发生异常的原因，也是程序处理异常的依据。</p><p>Python使用try-except语句实现异常处理，基本的语法格式如下：</p><p>try:</p><p> &lt;语句块1&gt;</p><p>except &lt;异常类型&gt;:</p><p> &lt;语句块2&gt;</p></blockquote><p>try 语句的工作原理如下：</p><p>首先，执行 try 子句的语句块。</p><p>如果没有异常发生，则跳过 except 子句。</p><p>如果发生了异常，则跳过 try 子句中剩余的语句部分。然后，如果异常类型和 except 关键字后面的异常类型匹配（同一个类或者是它的基类），则执行 except 子句的语句块。</p><p>如果发生的异常和 except 子句中的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个未处理异常，执行将停止并显示异常信息。</p><blockquote><p>NameError </p><p>ZeroDivisionError</p><p>TypeError</p><p>SyntaxError</p><p>IndexError  索引超出序列范围</p><p>KeyError  请求一个不存在的字典关键字</p><p>IOError    输入输出错误</p><p>AttributeError  尝试访问未知的对象属性</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python基础-二&quot;&gt;&lt;a href=&quot;#python基础-二&quot; class=&quot;headerlink&quot; title=&quot;python基础(二)&quot;&gt;&lt;/a&gt;python基础(二)&lt;/h1&gt;&lt;h2 id=&quot;程序的基本结构&quot;&gt;&lt;a href=&quot;#程序的基本结构&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="http://websec.space/categories/python/"/>
    
    
    <category term="python" scheme="http://websec.space/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python基础(一)</title>
    <link href="http://websec.space/2021/12/18/python%E5%9F%BA%E7%A1%80/"/>
    <id>http://websec.space/2021/12/18/python%E5%9F%BA%E7%A1%80/</id>
    <published>2021-12-17T16:00:00.000Z</published>
    <updated>2021-12-20T06:49:30.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python基础-一"><a href="#python基础-一" class="headerlink" title="python基础(一)"></a>python基础(一)</h1><h2 id="程序设计基本方法"><a href="#程序设计基本方法" class="headerlink" title="程序设计基本方法"></a>程序设计基本方法</h2><blockquote><p>程序设计语言分类</p><p>机器语言</p><p>汇编语言</p><p>高级语言</p><p>编译和解释</p><p>静态语言（ C/C++、Java ）、编译型语言</p><p>脚本语言（Python、JavaScript、PHP）、解释型语言</p></blockquote><h2 id="Python程序实例解析"><a href="#Python程序实例解析" class="headerlink" title="Python程序实例解析"></a>Python程序实例解析</h2><p><img src="https://img-blog.csdnimg.cn/2a70cad13fd04cc68db4ef8a62b5d13f.png" alt="img"></p><p>使用import引入函数库有两种方式，对函数的使用方式略有不同</p><p>第一种：import &lt;库名&gt;</p><p>  函数调用方式：&lt;库名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)</p><p>第二种：from &lt;库名&gt; import &lt;函数名&gt;</p><p>​        from &lt;库名&gt; import * (通配符)</p><p>  函数调用方式：&lt;函数名&gt;(&lt;函数参数&gt;)</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p><img src="https://img-blog.csdnimg.cn/bf5736d5285847cc82fbdb3f54bfc9fe.png" alt="img"></p><h4 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h4><p>十进制、二进制、八进制、十六进制</p><blockquote><p>示例</p><p> 1010, 99, -217 </p><p> 0x9a, -0X89  (0x, 0X开头表示16进制数) </p><p> 0b010, -0B101 (0b, 0B开头表示2进制数) </p><p> 0o123, -0O456 (0o, 0O开头表示8进制数)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进制转换(只演示十进制转二进制)</span></span><br><span class="line">a=<span class="number">1010</span></span><br><span class="line"><span class="comment">#转为二进制</span></span><br><span class="line"><span class="comment">#方法一</span></span><br><span class="line">b=<span class="built_in">format</span>(a,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#此时b为str类型</span></span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line">b=<span class="built_in">oct</span>(a)</span><br></pre></td></tr></table></figure><p> 进制转换</p><p>与数学中的整数概念一致，没有取值范围限制(python 2.2之后取消了普通整型和长整型，会自动转换为长整型)</p><p>pow(x, y)函数：计算x<sup>y</sup></p><p>pow(2,10)=1024</p><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><p>带有小数的数值</p><p>浮点数类型与整数类型由计算机的不同硬件单元执行，处理方法不同。故而浮点数0.0与整数0值相同，但是在计算机内部表示不同。</p><p>Python语言中浮点数的数值范围存在限制，小数精度也存在限制。受不同计算机系统的限制</p><p>n浮点数类型与整数类型由计算机的不同硬件单元执行，处理方法不同。故而浮点数0.0与整数0值相同，但是在计算机内部表示不同。</p><blockquote><p>n0.0, -77., -2.17 </p><p>n 96e4, 4.3e-3, 9.6E5 （科学计数法）</p><p>n 科学计数法使用字母“e”或者“E”作为幂的符号，以10为基数。科学计数法含义如下：</p><p>           <a>e<b> = a * 10<sup>b</sup></p></blockquote><p>浮点数类型直接表示或科学计数法表示中的系数最长可输出16个数字，浮点数运算结构中最长可输出17个数字，然而根据 sys.float_info结果，计算机只能提供15个数字的准确性，最后一位由计算机根据二进制计算结果确定，存在误差</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;1.2345678912345678</span><br><span class="line">1.234567891234568</span><br></pre></td></tr></table></figure><p>浮点数在超过15位数字计算中产生的误差与计算机内部采用二进制运算有关。(计算机组成原理)</p><p>由于python语言能够支持无限且准确的整数运算，因此，如果希望获得精度更高的计算结果，往往采用整数而不直接用浮点数。</p><p><img src="https://img-blog.csdnimg.cn/99b811ed8b7143e390026b990d80b80b.png" alt="img"></p><p>(使用标准库decimal进行高精度浮点数运算。)</p><h4 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h4><p>与数学中的复数概念一致, z = a + bj， a是实数部分，b是虚数部分，a和b都是浮点类型，虚数部分用j或者J标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12.3+4j,   -5.6+7j</span><br></pre></td></tr></table></figure><blockquote><p>z = 1.23e-4+5.6e+89j（实部和虚部是什么？）</p><p>对于复数z，可以用z.real获得实数部分，z.imag获得虚数部分</p><p>z.real = 0.000123  z.imag = 5.6e+89</p></blockquote><h4 id="python的操作"><a href="#python的操作" class="headerlink" title="python的操作"></a>python的操作</h4><p>Python解释器为数字类型提供数值运算操作符、数值运算函数、类型转换函数等操作方法。</p><p>Python提供了九个基本的数值运算操作符。</p><p>由Python解释器直接提供，不需要引用标准或第三方函数库，也叫作内置操作符。</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>x + y</td><td>x与y之和</td></tr><tr><td>x - y</td><td>x与y之差</td></tr><tr><td>x * y</td><td>x与y之积</td></tr><tr><td>x / y</td><td>x与y之商</td></tr><tr><td>x // y</td><td>x与y之整数商，即：不大于x与y之商的最大整数  (整除)</td></tr><tr><td>x % y</td><td>x与y之商的余数，也称为模运算</td></tr><tr><td>-x</td><td>x的负值，即：x*(-1)</td></tr><tr><td>+x</td><td>x本身</td></tr><tr><td>x**y</td><td>x的y次幂，即：x<sup>y</sup></td></tr></tbody></table><blockquote><p>操作符的运算结果可能改变数字类型。</p><p>三种数字类型存在一种逐渐“扩展”的关系：</p><p>​     整数 -&gt; 浮点数 -&gt; 复数 </p><p>​    （整数是浮点数特例，浮点数是复数特例）</p><p>不同数字类型之间可以进行混合运算，运算后生成结果为最宽类型</p><p>123 + 4.0 = 127.0 (整数 + 浮点数 = 浮点数)</p></blockquote><blockquote><p>数字类型之间相互运算所生成的结果是“更宽”的类型，基本规则是：</p><p>整数之间运算，如果数学意义上的结果是小数，结果是浮点数（Python 3 与Python 2的区别）；(注意整除//)</p><p>整数之间运算，如果数学意义上的结果是整数，结果是整数；</p><p>整数和浮点数混合运算，输出结果是浮点数；</p><p>整数或浮点数与复数运算，输出结果是复数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#在python2中:</span><br><span class="line"></span><br><span class="line">10/4=2</span><br><span class="line"></span><br><span class="line">#在python3中:</span><br><span class="line"></span><br><span class="line">10/4=2.5</span><br><span class="line"></span><br><span class="line">10//4=2</span><br></pre></td></tr></table></figure><h5 id="增强赋值运算符"><a href="#增强赋值运算符" class="headerlink" title="增强赋值运算符"></a>增强赋值运算符</h5><p>所有的二元数学操作符(+、-、<em>、/、//、%、</em><em>)都有与之对应的增强赋值操作符(+=、-=、</em>=、/=、//=、%=、**=)</p><blockquote><p>x+=3等价于x=x+3</p><p>x** =3等价于x=x**3</p></blockquote><h5 id="内置的数值运算函数"><a href="#内置的数值运算函数" class="headerlink" title="内置的数值运算函数"></a>内置的数值运算函数</h5><p>Python解释器提供了一些内置函数(不需要引用库，可以直接使用)，在这些内置函数之中，有6个函数与数值运算相关</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>abs(x)</td><td>x的绝对值</td></tr><tr><td>divmod(x, y)</td><td>(x//y, x%y)，输出为二元组形式（也称为元组类型）</td></tr><tr><td>pow(x, y[, z])</td><td>(x** y)%z，[..]表示该参数可以省略，即：pow(x,y)，它与x ** y相同</td></tr><tr><td>round(x[, ndigits])</td><td>对x四舍五入，保留ndigits位小数。round(x)返回四舍五入的整数值</td></tr><tr><td>max(x1, x2,  …, xn)</td><td>x1, x2,  …, xn的最大值，n没有限定</td></tr><tr><td>min(x1, x2,  …, xn)</td><td>x1, x2,  …, xn的最小值，n没有限定</td></tr></tbody></table><p>数值运算操作符可以隐式地转换输出结果的数字类型</p><p>例如，两个整数采用运算符“/”的除法将可能输出浮点数结果(Python 3)。</p><p>此外，通过内置的数字类型转换函数可以显式地在数字类型之间进行转换 </p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x)</td><td>将x转换为整数，x可以是浮点数或字符串</td></tr><tr><td>float(x)</td><td>将x转换为浮点数，x可以是整数或字符串</td></tr><tr><td>complex(re[, im])</td><td>生成一个复数，实部为re，虚部为im，re可以是整数、浮点数或字符串，im可以是整数或浮点数但不能为字符串(如果第一个参数为字符串，则不需要指定第二个参数)</td></tr></tbody></table><p>复数不能直接转换为其他数字类型，可以通过.real和.imag将复数的实部或虚部分别转换</p><p>函数：type(x)，返回x的类型，适用于所有类型的判断</p><p>（math库在此不介绍，平时用处也不大）</p><h3 id="字符串类型及其操作（重点）"><a href="#字符串类型及其操作（重点）" class="headerlink" title="字符串类型及其操作（重点）"></a>字符串类型及其操作（重点）</h3><p>字符串是字符的序列表示，可以由“单引号“、” 双引号”或”三引号”构成。</p><p>单引号和双引号可以表示单行字符串，两者作用相同</p><p>三引号可以表示单行或者多行字符串</p><p>字符串可以保存在变量中，也可以单独存在。</p><blockquote><p>使用单引号时，双引号可以作为字符串的一部分；</p><p>使用双引号时，单引号可以作为字符串的一部分。</p><p>三引号可以表示单行或者多行字符串。字符串可以保存在变量中，也可以单独存在。</p></blockquote><p>input()函数<strong>将用户输入的内容当作一个字符串类型</strong>，这是获得用户输入的常用方式</p><p>print()函数可以<strong>直接打印字符串</strong>，这是输出字符串的常用方式。</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>字符串是一个字符序列：字符串最左端位置标记为0，依次增加。字符串中的编号叫做“索引”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单个索引辅助访问字符串中的特定位置</span></span><br><span class="line"><span class="comment">#格式为&lt;string&gt;[&lt;索引&gt;]</span></span><br><span class="line">geet=<span class="string">&quot;Hello John&quot;</span></span><br><span class="line"><span class="built_in">print</span>(greet[<span class="number">2</span>]) <span class="comment">#打印第三个l</span></span><br><span class="line"><span class="built_in">print</span>(greet[-<span class="number">2</span>])<span class="comment">#打印倒数第二个h</span></span><br></pre></td></tr></table></figure><blockquote><p>Python中字符串索引从0开始，一个长度为L的字符串最后一个字符的位置是L-1</p><p>Python同时允许使用负数从字符串右边末尾向左边进行反向索引，最右侧索引值是-1</p></blockquote><p>Python字符串也提供区间访问方式，采用[N: M]格式，表示字符串中从N到M（不包含M）的子字符串，其中，N和M为字符串的索引序号。</p><p>可以混合使用正向递增序号和反向递减序号。</p><p>如果表示中M或者N索引缺失，则表示字符串把开始或结束索引值设为默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串以Unicode编码存储，因此，字符串的英文字符和中文字符都</span></span><br><span class="line"><span class="comment">#算作1个字符。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name=<span class="string">&quot;python 是最好的语言&quot;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;p&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(name[<span class="number">2</span>:-<span class="number">4</span>])</span><br><span class="line">thon 是最</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(name[:<span class="number">6</span>])</span><br><span class="line">python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(name[<span class="number">6</span>:])</span><br><span class="line"> 是最好的语言</span><br></pre></td></tr></table></figure><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>反斜杠字符（\）是一个特殊字符，在字符串中表示“转义”，即该字符与后面相邻的一个字符共同组成了新的含义。</p><p>例如：\n表示换行、\表示反斜杠、\’表示单引号、</p><p>\”表示双引号、\t表示制表符（TAB）等。</p><h4 id="基本的字符串操作符"><a href="#基本的字符串操作符" class="headerlink" title="基本的字符串操作符(*)"></a>基本的字符串操作符(*)</h4><table><thead><tr><th><strong>操作符</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>x + y</strong></td><td>连接两个字符串x与y</td></tr><tr><td><strong>x * n</strong> <strong>或</strong>  <strong>n * x</strong></td><td>复制n次字符串x</td></tr><tr><td><strong>x in s</strong></td><td>如果x是s的子串，返回True，否则返回False</td></tr><tr><td><strong>str[i]</strong></td><td><strong>索引，返回第i个字符</strong></td></tr><tr><td><strong>str[N: M]</strong></td><td><strong>切片，返回索引第N到M的子串，其中不包含M</strong></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;SkyMirror&quot;</span>+<span class="string">&quot; yyds&quot;</span></span><br><span class="line"><span class="string">&#x27;SkyMirror yyds&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;SkyMirror yyds\n&quot;</span>*<span class="number">4</span>)</span><br><span class="line">SkyMirror yyds</span><br><span class="line">SkyMirror yyds</span><br><span class="line">SkyMirror yyds</span><br><span class="line">SkyMirror yyds</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;yyds&quot;</span> <span class="keyword">in</span> <span class="string">&quot;SkyMirror yyds\n&quot;</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="内置的字符串处理函数"><a href="#内置的字符串处理函数" class="headerlink" title="内置的字符串处理函数(*)"></a>内置的字符串处理函数(*)</h4><table><thead><tr><th><strong>函数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>len(x)</strong></td><td><strong>返回字符串x的长度</strong></td></tr><tr><td><strong>str(x)</strong></td><td><strong>返回任意类型x所对应的字符串形式</strong></td></tr><tr><td><strong>chr(x)</strong></td><td><strong>返回Unicode编码x对应的单字符</strong></td></tr><tr><td><strong>ord(x)</strong></td><td><strong>返回单字符表示的Unicode编码</strong></td></tr><tr><td><strong>hex(x)</strong></td><td><strong>返回整数x对应十六进制数的小写形式字符串</strong></td></tr><tr><td><strong>oct(x)</strong></td><td><strong>返回整数x对应八进制数的小写形式字符串</strong></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chr(10004) </span><br><span class="line">&#x27;✔&#x27;</span><br><span class="line">&gt;&gt;&gt; ord(&#x27;✔&#x27;)   </span><br><span class="line">10004</span><br></pre></td></tr></table></figure><p>实例：</p><p>凯撒密码是古罗马凯撒大帝用来对军事情报进行加密的算法，它采用了替换方法对信息中的每一个英文字符循环替换为该字符后面3个字符，对应关系如下：</p><p>•原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p><p>•密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C</p><p>（看到这里的话，先自己盲打一段代码试试）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#凯撒密码加密器</span></span><br><span class="line">plaintext=<span class="built_in">input</span>(<span class="string">&quot;输入要加密的内容(英文）：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> plaintext:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span>&lt;=m&lt;=<span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(m)+<span class="number">3</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;A&#x27;</span>&lt;=m&lt;=<span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(m)+<span class="number">3</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;不听话拜拜&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>在Python解释器内部，所有数据类型都采用面向对象方式实现，封装为一个类。</p><p>字符串也是一个类，它具有类似<a>.b()形式的字符串处理函数。在面向对象字典里，这类函数被称为“方法”。</p><p>字符串类型共包含43个内置方法。鉴于部分内置方法并不常用，限于篇幅，这里仅介绍15个常用的内置方法，</p><table><thead><tr><th><strong>函数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>str.lower()</strong></td><td><strong>返回字符串str的副本，全部字符小写</strong></td></tr><tr><td><strong>str.upper()</strong></td><td><strong>返回字符串str的副本，全部字符大写</strong></td></tr><tr><td><strong>str.islower()</strong></td><td><strong>当str所有字符都是小写时，返回True，否则False</strong></td></tr><tr><td><strong>str.isprintable()</strong></td><td><strong>当str所有字符都是可打印的，返回True，否则False</strong></td></tr><tr><td><strong>str. isnumeric()</strong></td><td><strong>当str所有字符都是数字时，返回True，否则False</strong></td></tr><tr><td><strong>str.isspace()</strong></td><td><strong>当str所有字符都是空格，返回True，否则False</strong></td></tr><tr><td><strong>str.endswith(suffix[,start[,end]])</strong></td><td><strong>str[start: end]</strong> 以suffix结尾返回True，否则返回False</td></tr><tr><td><strong>str.startswith(prefix[,  start[, end]])</strong></td><td><strong>str[start: end]</strong> 以suffix开始返回True，否则返回False</td></tr><tr><td><strong>str.split(sep=None,  maxsplit=-1)</strong></td><td><strong>返回一个列表，由str根据sep被分割的部分构成</strong></td></tr><tr><td><strong>str.count(sub[,start[,end]])</strong></td><td><strong>返回str[start: end]中sub子串出现的次数</strong></td></tr></tbody></table><table><thead><tr><th><strong>str.replace(old,  new[, count])</strong></th><th><strong>返回字符串str的副本，所有old子串被替换为new，如果count给出，则前count次old出现被替换</strong></th></tr></thead><tbody><tr><td><strong>str.center(width[,  fillchar])</strong></td><td><strong>字符串居中函数，详见函数定义</strong></td></tr><tr><td><strong>str.strip([chars])</strong></td><td><strong>返回字符串str的副本，左侧和右侧去掉在chars中列出字符</strong></td></tr><tr><td><strong>str.zfill(width)</strong></td><td><strong>返回字符串str的副本，长度为width，不足部分在左侧添0</strong></td></tr><tr><td><strong>str.format()</strong></td><td><strong>返回字符串str的一种排版格式（重要）</strong></td></tr><tr><td><strong>str.join(iterable)</strong></td><td><strong>返回一个新字符串，由组合数据类型iterable变量的每个元素组成，元素间用str分割</strong></td></tr></tbody></table><h4 id="字符串类型的格式化"><a href="#字符串类型的格式化" class="headerlink" title="字符串类型的格式化"></a><strong>字符串类型的格式化</strong></h4><p>format()方法的基本使用，字符串格式化用于解决字符串和变量同时输出时的格式安排。</p><blockquote><p>字符串format()方法的基本使用格式是：</p><p>&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</p><p>&lt;模板字符串&gt;由一系列的槽组成，用来控制修改字符串中嵌入值出现的位置，其基本思想是将format()方法的&lt;逗号分隔的参数&gt;中的参数按照序号关系替换到&lt;模板字符串&gt;的槽中。</p></blockquote><p>槽用大括号({})表示，如果大括号中没有序号，则按照出现顺序替换</p><p>如果大括号中指定了使用参数的序号，按照序号对应参数替换调用format()方法后会返回一个新的字符串，参数从0开始编号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#123;1&#125;:计算机&#123;0&#125;的CPU占用率为&#123;2&#125;%。&quot;.format(&quot;2016-12-31&quot;,&quot;python&quot;,10)</span><br></pre></td></tr></table></figure><p>format()方法可以非常方便地连接不同类型的变量或内容，如果需要输出大括号</p><p>format()方法中&lt;模板字符串&gt;的槽除了包括参数序号，还可以包括格式控制信息。此时，槽的内部样式如下：{&lt;参数序号&gt;: &lt;格式控制标记&gt;} </p><p>其中，&lt;格式控制标记&gt;用来控制参数显示时的格式</p><p>&lt;格式控制标记&gt;包括：&lt;填充&gt;&lt;对齐&gt;&lt;宽度&gt;,&lt;.精度&gt;&lt;类型&gt;6个字段，这些字段都是可选的，可以组合使用，这里按照使用方式逐一介绍</p><p><img src="https://img-blog.csdnimg.cn/51fc9af2b3004245999747030d4a26a9.png" alt="img"></p><p>&lt;填充&gt;、&lt;对齐&gt;和&lt;宽度&gt;是3个相关字段。</p><p>&lt;宽度&gt;指当前槽的设定输出字符宽度，如果该槽对应的format()参数长度比&lt;宽度&gt;设定值大，则使用参数实际长度。如果该值的实际位数小于指定宽度，则位数将被默认以空格字符补充。</p><p>&lt;对齐&gt;指参数在&lt;宽度&gt;内输出时的对齐方式，分别使用&lt;、&gt;和^三个符号表示左对齐、右对齐和居中对齐。</p><p>&lt;填充&gt;指&lt;宽度&gt;内除了参数外的字符采用什么方式表示，默认采用空格，可以通过&lt;填充&gt;更换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:30&#125;&quot;</span>.<span class="built_in">format</span>(s)</span><br><span class="line"><span class="string">&#x27;python                        &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:*^10&#125;&quot;</span>.<span class="built_in">format</span>(s)  </span><br><span class="line"><span class="string">&#x27;**python**&#x27;</span></span><br></pre></td></tr></table></figure><p>&lt;.精度&gt;表示两个含义，由小数点（.）开头。</p><p>对于浮点数，精度表示小数部分输出的有效位数。</p><p>对于字符串，精度表示输出的最大长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1.2344423</span>)</span><br><span class="line"><span class="string">&#x27;1.23&#x27;</span></span><br></pre></td></tr></table></figure><p>&lt;类型&gt;表示输出整数和浮点数类型的格式规则。对于整数类型，输出格式包括：</p><p>–b: 输出整数的二进制方式；</p><p>–c: 输出整数对应的Unicode字符；</p><p>–d: 输出整数的十进制方式；</p><p>–o: 输出整数的八进制方式；</p><p>–x: 输出整数的小写十六进制方式；</p><p>–X: 输出整数的大写十六进制方式；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">16</span>)</span><br><span class="line"><span class="string">&#x27;10000,\x10,16&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python基础-一&quot;&gt;&lt;a href=&quot;#python基础-一&quot; class=&quot;headerlink&quot; title=&quot;python基础(一)&quot;&gt;&lt;/a&gt;python基础(一)&lt;/h1&gt;&lt;h2 id=&quot;程序设计基本方法&quot;&gt;&lt;a href=&quot;#程序设计基本方法&quot; c</summary>
      
    
    
    
    <category term="python" scheme="http://websec.space/categories/python/"/>
    
    
    <category term="python" scheme="http://websec.space/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>密码学之理论篇(密钥管理)</title>
    <link href="http://websec.space/2021/12/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87(%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86)/"/>
    <id>http://websec.space/2021/12/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87(%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86)/</id>
    <published>2021-12-12T16:00:00.000Z</published>
    <updated>2021-12-14T07:53:47.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇-密钥管理"><a href="#密码学之理论篇-密钥管理" class="headerlink" title="密码学之理论篇(密钥管理)"></a>密码学之理论篇(密钥管理)</h1><h2 id="秘密共享"><a href="#秘密共享" class="headerlink" title="秘密共享"></a>秘密共享</h2><blockquote><p>(1)一个绝密情报锁在保险柜里，为了确保安全，规定情报管理部门的8个人至少有4个人在场才能打开保险柜。</p><p>为了解决这样一些问题，人们引入了(t，n)门限方案(Threshold Scheme)，</p></blockquote><p>其基本思想:预先由需要保护的共享秘密产生n份秘密或称为秘密影子(Shadow)，并且这n份中的任意t个就可以重构共享秘密。</p><p>一个共享秘密M分位n份秘密m<del>1</del>，m<del>2</del>，m<del>3</del>,……，m<del>n</del> ，并将这n份秘密分别授予n个不同的持有人保管。</p><p>(1)由人体t个或多个t个已知的秘密份额m<del>i</del>，可以方便地计算出共享秘密M</p><p>(2)若仅知道t-1个或者少于t-1个秘密份额m<del>i</del>，则不可能确定共享秘密M</p><p>t称为门限值，这样的方案称为(t,n)门限方案，多人共同长官一个秘密信息。</p><h3 id="Shamir门限方案"><a href="#Shamir门限方案" class="headerlink" title="Shamir门限方案"></a>Shamir门限方案</h3><p>Shamir利用有限域上的多项式结合拉格朗日插值公式构造了一个(t,n)门限方案。设GF(p)是一有限域，共享密钥k∈GF(p)，可信中心给n(n&lt;p)个共享者U<del>i</del>(1≤i≤n)分配密钥的步骤如下</p><p>GF(p)={0,1,2,3,4,5…….,p-1}</p><blockquote><p>该方案基于拉格朗日插值法，所谓插值法就是利用k次多项式只需要有k个方程就可以将系数全部解出的特性。</p><p>先确立一个方程k-1次的方程，保证k个方程即k个人能打开箱子。密钥取值即为函数上的其他点。</p></blockquote><p>(1)可信中心T随机选择一个t-1次多项式：</p><p>​                            g(x)=a<del>t-2</del>x^t-1^ +a<del>t-2</del>^t-2^+…+a<del>2</del>x^2^+a<del>1</del>x+a<del>0</del></p><p>g(x)∈GF(p)[x];a<del>0</del>=k就是共享密钥</p><p>(2)可信中心T在GF(p)中选择n个非零的、互不相同的元素x<del>1</del>，x<del>2</del>,….,x<del>n</del>,分别计算：</p><p>​                            y<del>i</del>=g(x<del>i</del>),i=1,2,3…,n即找出曲线g(x)上的n个点</p><p>(3)把第i个点(x<del>i</del>,y<del>i</del>)作为秘密份额分配给第i个共享者U<del>i</del> ,其中x<del>i</del>是公开的，通常可以直接取共享者U<del>i</del>的身份ID<del>i</del>，y<del>i</del>是属于共享者U<del>i</del>的秘密份额，i=1,2,3,4，….,n</p><p>由于g(x)是t-1次多项式，因而t个或t个以上的坐标点可以唯一确定g(x)，从而共享密钥也可以确定下来，也即k=g(0);反过来，如果坐标点少于t个，则无法确定g(x),也就无法确定k</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇-密钥管理&quot;&gt;&lt;a href=&quot;#密码学之理论篇-密钥管理&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇(密钥管理)&quot;&gt;&lt;/a&gt;密码学之理论篇(密钥管理)&lt;/h1&gt;&lt;h2 id=&quot;秘密共享&quot;&gt;&lt;a href=&quot;#秘密共享&quot; c</summary>
      
    
    
    
    <category term="密码学" scheme="http://websec.space/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://websec.space/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学之理论篇(认证理论与技术)</title>
    <link href="http://websec.space/2021/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87(%E8%AE%A4%E8%AF%81%E7%90%86%E8%AE%BA%E4%B8%8E%E6%8A%80%E6%9C%AF)/"/>
    <id>http://websec.space/2021/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87(%E8%AE%A4%E8%AF%81%E7%90%86%E8%AE%BA%E4%B8%8E%E6%8A%80%E6%9C%AF)/</id>
    <published>2021-12-11T16:00:00.000Z</published>
    <updated>2021-12-13T13:34:59.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇-认证理论与技术"><a href="#密码学之理论篇-认证理论与技术" class="headerlink" title="密码学之理论篇(认证理论与技术)"></a>密码学之理论篇(<strong>认证理论与技术</strong>)</h1><h2 id="认证与认证系统"><a href="#认证与认证系统" class="headerlink" title="认证与认证系统"></a>认证与认证系统</h2><p>认证又称为鉴别，是许多应用系统中安全保护的第一道设防，在现代密码学中有着非常重要的作用，认证是个过程，通过这个过程，一个实体向另外一个实体证明某种声称的属性，前者是一个主体，声称拥有某种合法权利，可以进入后一个实体的系统或者使用后者的服务，通过认证，后者确定前者确实拥有的权利，认证参数一般有多种形式，如：口令、标识符、密钥、信物、智能卡、指纹、视网纹。</p><blockquote><p>“口令”相当于平时咱们登录系统时输入的密码（也是一种认证） 。</p><p>“密钥”相当于公钥密码体制中的私钥，可用于数字签名（也是一种认证）。</p><p>“智能卡”相当于校园一卡通之类（也是一种认证） 。</p><p>“指纹”比如指纹识别手机开机、指纹识别移动支付等（也是一种认证） 。</p></blockquote><p>随着Hash函数和数字签名的发现，人们认识到保密和认证是两个不同的属性的问题，认证不能自动提供保密性，而保密性也不能自然提供认证功能。认证主要用于确保消息发送者和接收者的真实性以及消息的完整性。</p><p><img src="https://img-blog.csdnimg.cn/45c78e46e5364498b8f7fc6cbc983113.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>注意：这个示意图并不绝对。Hash函数也能用于认证，但Hash函数里并没用到密钥。</p><h2 id="Hash函数概述"><a href="#Hash函数概述" class="headerlink" title="Hash函数概述"></a>Hash函数概述</h2><p>Hash 函数又称为哈希函数、杂凑函数和散列函数，在现代密码学中扮演着重要角色。Hash函数是一公开函数，通常记为H或h。Hash函数可以将任意长的消息 m映射为较短的、固定长度的一个值，记为H(m)，经常称函数值H(m)为散列值、哈希值、杂凑值、杂凑码或消息摘要、数组指纹。</p><p>Hash函数也可以看作是一种单向密码体制，即它从一个明文到密文是不可逆映射，只有加密过程，不能解密。哈希值是消息中所有比特的函数，因此提供了一种错误检测能力，即改变消息中任何一个比特或几个比特都会使哈希值发生改变。Hash 函数是实现有效、安全、可靠数字签名和认证的重要工具。</p><p>利用Hash函数可以对消息的完整性</p><blockquote><p>利用Hash函数可以对消息的完整性进行认证。比如A将(x,H(x))发送给B,其中x是消息，H()是公开的Hash函数。B利用Hash函数验证一下，通过了说明消息完整，不通过说明消息不完整。</p><p>注意：这只是简单说明Hash函数用于认证的原理，并不能防止伪造。如攻击者将A发送的东西截取了，反手将（y, H(y)）发送给接收者B，B也觉得消息挺完整的。有时候还要结合密钥使用。</p></blockquote><h3 id="Hash函数的概念及结构"><a href="#Hash函数的概念及结构" class="headerlink" title="Hash函数的概念及结构"></a>Hash函数的概念及结构</h3><p>1.Hash函数的概念及一般安全特性</p><p>Hash函数H是一个公开函数，不需要密钥，用于将任意长的消息m映射为较短的、固定长度一个值H(m)</p><p>对于H有下面六个要求：</p><p>(1)能够接受任意长度的消息作为输入</p><p>(2)能够生成较短的，固定长度的输出</p><p>(3)对任何消息输入都应该能够容易快速地计算出哈希值</p><p>(4)应该具有单向性，也就是说，给定H(m)，恢复消息m在计算上是不可行的</p><p>(5)应该能够抵抗弱碰撞，即给定消息m和H(m),找到另外一个消息m≠m‘，使H(m)=H(m’)是不可能的</p><p>(6)应该能够抵抗强冲击，即可以有两个有意义的消息m和m’，使得H(m)=H(m’)几乎是不可能的</p><blockquote><p>弱碰撞：对于给定的一个“人”，找到一个和他指纹相同的人。</p><p>强碰撞：在这个世界上找到两个指纹相同的人。</p></blockquote><p>Hash函数应该满足的一般安全特性如下：</p><p>(1)单向性，给定H(m),计算m在计算上不可行</p><p>(2)抗弱碰撞性，即给定消息m和H(m),找到另外一个消息m≠m‘，使H(m)=H(m’)是不可能的</p><p>(3)抗强碰撞性，即可以有两个有意义的消息m和m’，使得H(m)=H(m’)几乎是不可能的</p><p>2.MD迭代结构</p><p>1979年，Merkle建议了一个Hash函数的一般结构，这一种迭代结构的Hash函数，MD系列，SHA系列大多数Hash函数都使用该结构。</p><p><img src="https://img-blog.csdnimg.cn/5711b384a17449edae6bcf92c16d7f22.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>f函数：输入n+b比特，输出n比特</p><p>Hash函数输入消息m，并将其分为L个固定长度的分组，该Hash函数重复使用一个压缩函数f。压缩函数f有两个输入，一个是前一阶段的n比特输入，另外一个源于消息的b的bit分组，并产生一个n bit的输出</p><h3 id="Hash函数的发展现状"><a href="#Hash函数的发展现状" class="headerlink" title="Hash函数的发展现状"></a>Hash函数的发展现状</h3><p>最常用的Hash函数有两个系列：Message Digest(MD)系列和SHA(Security Hash Algorithm)系列</p><ol><li><p>Message Digest(MD)系列</p><p>MD5(1991年提出，是对MD4的改进版，其哈希值为128位)</p></li><li><p>SHA(Security Hash Algorithm)系列</p><p>1995年SHA-1被提出消息三列为160bit，2003年，NIST相继对SHA系列算法进行了扩展提出了SHA-256、SHA-384、SHA-512，并于2004年增加了一种变种算法：SHA-224，统称为SHA-2</p></li></ol><p>MD5曾经是应用最广泛的Hash算法，2004年，山东大学的王小云教授等人发表了对SHA-1的完整版攻击，能找到一组SHA-1的碰撞。（MD5散列算法已不安全，不在推荐使用）</p><p>2007年NIST发起了SHA-3竞赛以征集新的Hash算法，2012年，Keccak成为竞赛的胜利者，SHA-3标准公布，SHA-3中的四种Hash算法SHA3-224、SHA3-256和SHA3-512可完全替换SHA-2</p><h2 id="Hash函数算法"><a href="#Hash函数算法" class="headerlink" title="Hash函数算法"></a>Hash函数算法</h2><h3 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h3><p>SHA-1是当前使用最广泛的哈希算法，它接受输入消息的最大长度为(2^64^ -1)bit , 生成160bit的消息摘要。首先将输入消息划分为512bit块，若最后一个数据块不满足长度要求，按照一定规则填充512bit块。然后每个512bit块重复使用分块处理函数，最终输出160bit哈希值。每512bit块以32bit字为处理单位进行压缩，压缩函数包含4回合运算，每一回合20步，总共80步。</p><h3 id="SHA-256、SHA-384和SHA-512-算法"><a href="#SHA-256、SHA-384和SHA-512-算法" class="headerlink" title="SHA-256、SHA-384和SHA-512^*^ 算法"></a>SHA-256、SHA-384和SHA-512^*^ 算法</h3><p>SHA-256、SHA-384、SHA-512，统称SHA-2. SHA-256和SHA-1算法一样，以512bit分块为基本处理单位而SHA-384、SHA-512与SHA-1算法不同，是以1024bit分块为基本处理单位。</p><h3 id="SHA-3算法"><a href="#SHA-3算法" class="headerlink" title="SHA-3算法"></a>SHA-3算法</h3><p>2007年NIST发起SHA-3竞赛以征集新的Hash算法</p><p>2012年，NIST最终选择Keccak算法作为SHA-3标准</p><p>为了与SHA-2完全兼容，SHA-3也提出了四种Hash算法SHA3-224、SHA3-256、SHA3-384、SHA3-512，可完全替换SHA-2</p><h4 id="Keccak算法的总体描述"><a href="#Keccak算法的总体描述" class="headerlink" title="Keccak算法的总体描述"></a>Keccak算法的总体描述</h4><p>Keccak算法基于海绵结构，区别于多数Hash函数所采用的经典MD结构，处理过程分为吸收(absorbing)阶段和挤压(squeezing)阶段两个部分，消息被分为长度r bit的若干消息块(假设N组，p<del>1</del>,p<del>2</del>,p<del>3</del>,…,p<del>n</del>)</p><h3 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h3><p>MD5算法是由RSA创始人Rivest设计开发的，能接收任意长度的消息作为输入，并生成128bit哈希值。</p><h2 id="Hash算法的攻击现状分析"><a href="#Hash算法的攻击现状分析" class="headerlink" title="Hash算法的攻击现状分析"></a>Hash算法的攻击现状分析</h2><p>Hash函数主要用于数据完整性验证，确定消息是否被修改，对Hash函数攻击的目标能够生成与原消息不同的消息，但其哈希值与原消息的哈希值相等，即碰撞攻击</p><p>Hash函数的攻击可以分为如下几类：</p><p>（1）原像攻击，对给定的哈希值Y∈{0,1}^n^ ,能够找到一个原消息M，使得H(M)=Y</p><p>（2）第二原像攻击也称为弱碰撞攻击，对给定的消息M，找到另外一个消息M‘，使得M≠M’，而H(M)=H(M’)</p><p>（3）碰撞攻击也称为强碰撞攻击，找到任意两消息M和M‘(M≠M’)，使得H(M)=H(M’)</p><p>生日攻击是Hash函数碰撞攻击方法中最重要的一种攻击方法。生日攻击的名字起源于所谓的生日悖论。</p><blockquote><p>生日悖论是指在不少于 23 个人中至少有两人生日相同的<a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87/828845">概率</a>大于 50%。</p><p>严格来说，它并不是一个真正的悖论，只是令人吃惊的概率问题。</p></blockquote><p>将生日悖论推广位下述问题：已知在1到n之间均匀分布的整数型随机变量，若该变量的k个取值中至少有两个取值相同的概率大于0.5，则k至少多大？</p><p>k=1.18n^½^</p><h3 id="生日攻击"><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h3><p>生日攻击是基于下述结论:设单向Hash函数Y=H(X)，X、Y都是有限长度的，并且|X|≥2|Y|,记为|X|=n,|Y|=m,那么Hash函数H有2^m^个可能的输出，如果H的k个随机输入中至少有两个产生相同输出的概率大于0.5，k≈2^m/2^</p><p>另外一种攻击Hash函数的方法是采用密码分析学的办法，即利用算法逻辑上的缺陷，降低破译算法的代价。2004年，山东大学的王小云教授在美国加州圣巴巴拉召开的国际密码学会议上，做了破译MD5、HAVAL-128、MD4和RIPEMD算法的报告。王小云的研究成果被公认为MD5算法最优先的破解办法。</p><h2 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h2><p>消息认证是一个过程，用以验证接收消息的真实性(的确是由它所声称的实体发来的)和完整性，同时还用于验证消息的顺序性和时间性。</p><p>可用消息认证码(Mesage Authentication Code,MAC)对消息做认证.</p><p>消息认证码是指消息被一密钥控制的公开函数作用后产生的、用作认证符的固定长度的数值，MAC算法输入任意长度消息输出固定长度的数据，这点与Hash函数类似，但是与Hash函数不同的是，计算MAC值必须持有共享密钥.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇-认证理论与技术&quot;&gt;&lt;a href=&quot;#密码学之理论篇-认证理论与技术&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇(认证理论与技术)&quot;&gt;&lt;/a&gt;密码学之理论篇(&lt;strong&gt;认证理论与技术&lt;/strong&gt;)&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="密码学" scheme="http://websec.space/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://websec.space/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学之理论篇（非对称密码体制）</title>
    <link href="http://websec.space/2021/12/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/"/>
    <id>http://websec.space/2021/12/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%88%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/</id>
    <published>2021-12-09T16:00:00.000Z</published>
    <updated>2021-12-13T13:34:12.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇（非对称密码体制）"><a href="#密码学之理论篇（非对称密码体制）" class="headerlink" title="密码学之理论篇（非对称密码体制）"></a>密码学之理论篇（非对称密码体制）</h1><p>非对称密码体制中的经典算法——RSA密码算法和ElGamal密码算法，近年来广受关注的椭圆曲线密码体制。</p><p>分组密码和序列密码都属于对称密码体制。两个用户在用对称密码体制进行保密通信时，必须有一个双方共享的密钥。</p><p>（如何才能让两个不在同一个地方的用户安全地拥有共享密钥呢？如果要加密比较重要的信息，密钥分发这个环节，又被不怀好意的人“盯上了”，问题比较棘手。）</p><p>无论某种对称密码算法从理论上讲是多么安全，在实际运用中，都不可避免地遇到了”密钥分发“的问题，这就大大限制了它的可实施性和安全性。</p><h2 id="非对称密码体制概述"><a href="#非对称密码体制概述" class="headerlink" title="非对称密码体制概述"></a>非对称密码体制概述</h2><p>假设一个公司包含N个距离较远的机构，各个之间能相互进行秘密通信，他们每一个月要更换一次相互通信用的加密密钥，每次更换密钥的数量是N(N-1)/2。密钥是需要定期更换的。如果采用对称密码体制，更换密钥以及相应的“密钥分发”工作量相当大。</p><p>密钥分发成了战后密码学家要解决的最重要的问题。如果两个组织需要安全通信，却需要第三方来传送密钥，这就成了安全通信最薄弱的环节。那如何才能用较小的代价、较高的效率实现通信双方的密钥传递呢？正是这个需求，促使了非对称密码体制的产生。</p><p>（既然”密钥分发“工作量大，找专人负责这事儿不行了吗？也不行，也不放心！如果这个”专人“使坏，对密钥动了什么手脚，那就麻烦了！）</p><p>用户在登录和使用网上银行、电子邮箱、论坛或者即时聊天软件时，和服务器端是没有预先协商好加密密钥的，那么如何在网络上保护用户的账户信息及密码不被别人使用嗅探器之类的软件探测到呢?非对称密码体制的提出和使用解决了上面的这些问题。</p><p>（上面场景中的问题，对称密码体制是无法解决的。按照对称密码体制的思路，既然没有协商好密钥 就开始网上互动了，等于没对隐私信息进行加密，在网上全暴露了。）</p><p>1976年，<strong>Diffie和 Hellman</strong>发表了非对称密码的奠基性的论文——《<strong>密码学的新方向</strong>》.建立了公钥密码的概念。</p><p>麻省理工学院的Rivest、Shamir和Adleman提出的RSA算法。RSA算法则经过深入的研究和广泛使用，至今都被认为是计算上安全的。</p><h3 id="非对称密码体制的原理"><a href="#非对称密码体制的原理" class="headerlink" title="非对称密码体制的原理"></a>非对称密码体制的原理</h3><p>在对称密码体制中，除了加密及解密算法是公开的，一个重要的特点是加密算法与解密算法的密钥相同，或者容易从其中一个得到另一个，这要求通信双方要有共享的加密密钥。</p><p>序列密码：在加密和解密时，无论是种子密钥，还是生成密钥流，都是一样的。</p><p>分组密码：在加密和解密时，初始密钥是一样的，子密钥使用顺序相反或者可以互推。</p><p><img src="https://img-blog.csdnimg.cn/a10cab78b71049aab7fb77011bf423f5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>（1）密钥的产生，公钥公开，私钥存好。</p><p>主体A若需要其他主体利用非对称密码体制向他发送秘密消息，先要生成一对密钥，其中一个用于加密，另一个用于解密。用于加密的密钥在非对称密码体制中称为公开密钥，也称公开钥或公钥，是不需要保密的。A的公开密钥通常表示为PK<del>A</del>( public key of A)。用于解密的密钥称为秘密密钥，简称秘密钥或私钥，需要解密方严格保密。A的秘密密钼通常表示为SK<del>A</del>( secret key of A)。在知道密码算法和公开密钥的情况下，要得到秘密密钥在计算上是不可行的。</p><p>（2）人人都可以给接收者发送加密信息（接收者的公钥人人皆知）</p><p>B若要向A发送秘密消息m(Message)，先要获取A的加密密钥，也即公钥。计算c=E<del>PKa</del>(m)，得到消息m对应的密文c(Cipher)，然后把c发送给A。其中c表示加密消息得到的密文，E(Encrypt)表示对消息进行加密的算法。E<del>PKa</del>(m)表示用加密算法E和公开密钥PK<del>A</del>对消息m进行加密。</p><p>（3）只有合法接收者才能解密</p><p>A在接收到密文c后，计算m=D<del>SKa</del> (c)，得到密文c对应的消息m。其中 D(Decrypt)表示对密文进行解密的算法，Dsk<del>A</del>(c)表示用解密算法D和秘密密钥SK<del>A</del>;对密文c进行解密</p><p>（4）不合法接收者，无法进行解密。</p><p>由于只有接收者A有解密密钥，故密文c在公共信道的传输过程中是安全的。如果这个模型能够得以实现，假设传递的消息就是通信双方将要在对称密码体制中使用的密钥，则前面我们提到的密钥传递问题就容易被解决了。</p><p>对称密码体制和非对称密码体制（公钥密码）可以组成“黄金搭档”。</p><p>对称密码加密速度快，但密钥分发困难；公钥密码加密速度慢，但基本不存在密钥分发问题。</p><p>可以用公钥密码传递对称密码的密钥，完成密钥分发，之后利用对称密码进行大规模数据传输。</p><h3 id="非对称密码体制的分类"><a href="#非对称密码体制的分类" class="headerlink" title="非对称密码体制的分类"></a>非对称密码体制的分类</h3><p>（1）基于大数分解难题的，包括RSA密码体制、Rabin密码等。</p><p>大整数分解难题：已知大整数N是两个大素数的乘积，求大素数p和q，使得N=p*q</p><p>（2）基于离散对数难题，如ElGamal密码等。</p><p>已知大素数p，设g为乘法群Z<del>p</del>^<em>^的生成元，选择一个随机数x，计算g^x^mod p≡y是简单的，然而在已知g、p、y的情况下，反过来求x（即求Z<del>p</del>^</em>^ 上的离散对数 x=log y）</p><p>（3）基于椭圆曲线离散对数的密码体制。</p><p>已知椭圆曲线E<del>p</del>(a,b),以及两个点Q，R∈E<del>p</del>(a,b)由R，Q，E<del>p</del>（a，b）求k∈Z，使得R=kQ</p><p>还有基于网格理论的公钥密码体制，颇受关注的如NTRU</p><h2 id="RSA密码算法"><a href="#RSA密码算法" class="headerlink" title="RSA密码算法"></a>RSA密码算法</h2><h3 id="RSA发展简史"><a href="#RSA发展简史" class="headerlink" title="RSA发展简史"></a>RSA发展简史</h3><p>1976年，<strong>Diffie和 Hellman</strong>发表了非对称密码的奠基性的论文——《<strong>密码学的新方向</strong>》</p><p>1978年，麻省理工学院的Rivest、Shamir和Adleman提出的RSA算法</p><p>RSA密码算法在非对称密码算法发展史上有着重要的地位，也是至今为止理论上最为成熟完善的密钥密码体制，至今仍被广泛应用。</p><h4 id="密钥产生"><a href="#密钥产生" class="headerlink" title="密钥产生"></a>密钥产生</h4><p>1.选择两个满足需要的大素数p和q，计算n=p*q，φ(n)=(p-1) * (q-1) ,其中φ(n)是n的欧拉函数。</p><p>2.选一个整数e，满足1&lt;e&lt;φ(n),且gcd(φ(n),e)=1.通过d*e≡1mod φ(n)，计算出d（gcd()表示最大公因数）</p><p>3.以{e,n}为公开密钥，{d，n}为秘密密钥。准确地说秘密密钥就是d</p><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>如果发送方想发送需要保密的消息m给Alice，就选择Alice的公钥{e，n}，然后计算c≡m^e^ mod n ,然后把密文c发送给接收方Alice</p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p>接收方Alice收到密文c，根据自己掌握的私钥计算m≡c^d^mod n，所得结果m即为发送方欲发送的消息</p><h3 id="RSA算法的实现"><a href="#RSA算法的实现" class="headerlink" title="RSA算法的实现"></a>RSA算法的实现</h3><p>在实现RSA算法时，在提高指数运算速度上，可以采用模重复平方计算法或者平方乘算法</p><h2 id="ElGamal密码算法"><a href="#ElGamal密码算法" class="headerlink" title="ElGamal密码算法"></a>ElGamal密码算法</h2><p>ElGamal密码算法是基于离散对数难题的公钥密码体制。椭圆曲线公钥密码体制是基于椭圆曲线离散对数难题的，是ElGamal密码算法在椭圆曲线上的应用。</p><h3 id="ElGamal算法描述"><a href="#ElGamal算法描述" class="headerlink" title="ElGamal算法描述"></a>ElGamal算法描述</h3><p>Z<del>n</del>={0,1,2,3….，n-1}是模n的整数集，令Z<del>n</del>^*^ ={x∈Z<del>n</del>|gcd(x,n)=1}</p><p>例如，令n=10，则Z<del>10</del>={0,1,2,……，9}，Z<del>n</del>^<em>^={1,3,7,9}。当n是奇素数，Z<del>n</del>={0,1,2……，n-1}，Z<del>n</del>^</em>^={1,2,3,……，n-1}</p><h4 id="密钥的产生"><a href="#密钥的产生" class="headerlink" title="密钥的产生"></a>密钥的产生</h4><p>设p是一个大素数，求解(Z<del>p</del>^<em>^,X )上的离散对数问题在计算上是困难的。令g∈Z<del>p</del>^</em>^ 是一个本原元，选择x，1&lt;x&lt;p-1,计算y≡g^x^ mod p,则{g,y,p}是公开密钥，{g，x，p}是私密密钥。</p><h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><p>对于消息m，发送方选择一个秘密的随机数k,1&lt;k&lt;p,计算：</p><p>C<del>1</del> ≡ g^k^ mod p ,  C<del>2</del> ≡ my^k^ mod p</p><p>然后把C<del>1</del>、C<del>2</del>发送给接收方。</p><h4 id="解密算法"><a href="#解密算法" class="headerlink" title="解密算法"></a>解密算法</h4><p>接收方接收到了C<del>1</del>、C<del>2</del>后，计算C<del>1</del>^-x^C<del>2</del> mod p ≡ m ,即为发送方的秘密消息。</p><p> 因为（C<del>1</del>^-x^）C<del>2</del> ≡ g^-xk^  * m * g^xk^  ≡m mod p</p><p>在密钥产生过程中，要求1&lt;x&lt;p-1 因为g^1^=g , g^p-1^≡1 mod p, 1和g显然是不能用来作为公钥的。</p><p>（保证y≠1且y≠g（mod p））</p><p>ElGamal加密算法是一个非确定性算法。对于相同的消息m，由于随机数k的选择不同，所得到的密文也不同。</p><p>（前面学习的密码算法都是确定性算法。对于一个消息m，一旦密钥确定下来，这个消息只能被加密成唯一确定的密文）</p><p>ElGamal加密算法的一个缺点是“信息拓展”，即密文长度是所对应的明文长度的两倍</p><h3 id="椭圆曲线密码体制"><a href="#椭圆曲线密码体制" class="headerlink" title="椭圆曲线密码体制"></a>椭圆曲线密码体制</h3><p>1985年，Neal Koblitz和Victor Miller分别独立地提出了可以在低要求的计算环境里做到高强度加密的公钥算法，即椭圆曲线密码体制(ECC)。</p><p>椭圆曲线密码算法与RSA 算法的安全性相同时，其密钥较短，长度为160 bit的密钥相当于RSA算法1024 bit密钥的安全性，因而有利于容量受限的存储设备如智能卡等在安全领域的使用。</p><p>在我国，国家密码管理局2010年12月提出了SM2椭圆曲线公钥密码算法。</p><h4 id="椭圆曲线上的ElGamal密码体制"><a href="#椭圆曲线上的ElGamal密码体制" class="headerlink" title="椭圆曲线上的ElGamal密码体制"></a>椭圆曲线上的ElGamal密码体制</h4><p>先由系统选取一条椭圆曲线，该椭圆曲线上的点形成了循环群E,G∈E是椭圆曲线上的一个点，N是点G在循环群E的阶，即NG=O。用户选择一个整数a,0&lt;a&lt;N，计算β=aG ,a保密，但将β公开。即{a,G}是私钥，{β，G}是公钥，所选择的椭圆曲线也是公开的加密方知道点G的阶为N。</p><p>(“O”是群E的单位元，也是椭圆曲线中的无穷远点)</p><p>已知椭圆曲线E<del>p</del>(a,b),以及两个点Q，R∈E<del>p</del>(a,b) . 由R,Q,E<del>p</del>(a,b)求k∈Z，使得R=kQ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇（非对称密码体制）&quot;&gt;&lt;a href=&quot;#密码学之理论篇（非对称密码体制）&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇（非对称密码体制）&quot;&gt;&lt;/a&gt;密码学之理论篇（非对称密码体制）&lt;/h1&gt;&lt;p&gt;非对称密码体制中的经典算法—</summary>
      
    
    
    
    <category term="密码学" scheme="http://websec.space/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://websec.space/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学理论篇之序列密码体制</title>
    <link href="http://websec.space/2021/12/08/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%88%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/"/>
    <id>http://websec.space/2021/12/08/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%88%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/</id>
    <published>2021-12-07T16:00:00.000Z</published>
    <updated>2021-12-10T08:52:15.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学理论篇之序列密码体制"><a href="#密码学理论篇之序列密码体制" class="headerlink" title="密码学理论篇之序列密码体制"></a>密码学理论篇之序列密码体制</h1><h2 id="Vernam（弗纳姆）密码技术"><a href="#Vernam（弗纳姆）密码技术" class="headerlink" title="Vernam（弗纳姆）密码技术"></a>Vernam（弗纳姆）密码技术</h2><p>设明文m=m<sub>1</sub> , m<sub>2</sub> , ….. , 密钥k=k<sub>1</sub> k<sub>2</sub> k<sub>3</sub> …,其中m<sub>i</sub> k<sub> i</sub> ∈ GF(2) , i&gt;=1,则密文 c=c<sub>1</sub> c<sub>2</sub> ….,其中c<sub>i</sub> = m<sub>i</sub> ⊕  </p><p>k<sub>i</sub> .这里⊕为模二加法。</p><p>序列密码起源于20世纪20年代的Vernam密码体制，当Vernam密码体制中的密钥序列是随机的“0,1”序列时，就成为了所谓的“一次一密” 密码体制。香农已经证明“一次一密”密码体制在理论上是不可破译的。但由于随机密钥序列的产生、存储以及分配存在一定的困难，因此Vernam密码体制在当时并没有得到广泛的应用。</p><p>在Vernam密码体制中，用来做密钥的随机序列比较长，发送方和接收方都需要有这个随机序列。这个随机序列这么长，怎么产生、怎么分发、怎么存储？不是容易事儿。</p><p>在序列密码体制中，加密和解密密钥都是伪随机序列，而当前伪随机序列的产生比较容易且有比较成熟的数学理论工具。目前序列密码是世界各国的军事和外交等领域中使用的主要密码体制之一。</p><p>在序列密码中，用伪随机序列做密钥。所需的伪随机序列虽然比较长，但可以通过一个比较短的种子密钥产生。发送方和接收方只需要共同拥有这个种子密钥，再加解密时用种子密钥来产生所需的伪随机序列。</p><h2 id="密码学中的随机数"><a href="#密码学中的随机数" class="headerlink" title="密码学中的随机数"></a>密码学中的随机数</h2><h3 id="随机数及其性质"><a href="#随机数及其性质" class="headerlink" title="随机数及其性质"></a>随机数及其性质</h3><p>序列密码的保密性完全取决于密钥的随机性。如果密钥是真正的随机数，则这种密码体制在理论上是不可破译的。但这种方式所需的密钥量大得惊人，在实际中是不可行的。目前一般采用伪随机序列来代替随机作为密钥序列，也就是序列存在着一定的循环周期性。如果周期足够长，就会有比较好的保密性。现在周期小于10<sup>10</sup>的序列很少采用。</p><p>（分组密码算法本身比较复杂，也还算有点“秘密”（如果可可以隐瞒算法的话）。序列密码算法完全没有“秘密”可言，他就是将明文流和密钥流按位做异或运算，因而其安全性更是完全依赖于密钥。）</p><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p>通常所讲的随机数是指没有规律的数据。</p><h4 id="随机数的性质"><a href="#随机数的性质" class="headerlink" title="随机数的性质"></a>随机数的性质</h4><p>（1）随机性。在密码学的应用中要求随机数具有无规律性，无规律性主要体现在以下两个方面：</p><p>1.具有均匀分布、总体良好的随机统计特征。</p><p>2.不能重复产生，即在完全相同的条件下，将得到两个不相关的随机序列。</p><p>（2）不可预测性。即使给出产生序列的硬件和所有以前产生的序列的全部知识，也不能预测下一个随机位是什么，因而随机序列是非周期的</p><p>（喻：关于不能重复产生这事儿。比如说掷硬币确定10bit的比特串（正就是1，反就是0）。</p><h3 id="随机数的生成方法"><a href="#随机数的生成方法" class="headerlink" title="随机数的生成方法"></a>随机数的生成方法</h3><p>（1）物理方法利用自然界的一些真的随机物理量来生成随机数。比如，放射性衰变、电子设备的噪声、宇宙射线的触发时间。</p><p>（2）利用计算机来产生随机数，即数学方法。这类方法由一个初始状态（称为“种子”）开始，通过一个确定的算法来生成随机数。一旦给定算法和种子，输出的序列就是确定的，因而产生的序列具有周期性、规律性和重复性，不是真正的随机数，而是伪随机数（PRN），产生伪随机数的算法或硬件一般称之为伪随机生成器（PRNG）。</p><p>PRNG实现简单、速度快、经济，而且在目前的许多应用中并不一定必须使用真正的随机数，只要产生的伪随机数的随机性能满足应用需求就可以。</p><h3 id="伪随机的评价标准"><a href="#伪随机的评价标准" class="headerlink" title="伪随机的评价标准"></a>伪随机的评价标准</h3><p>（1）看起来随机的，表明他可以通过所有随机性统计检验。</p><p>（2）它是不可预测的。即使给出产生序列的算法或硬件，以及所有以前产生的比特流的全部知识，也不可能通过计算来预测下一个随机比特应是什么。</p><h3 id="序列密码的基本原理"><a href="#序列密码的基本原理" class="headerlink" title="序列密码的基本原理"></a>序列密码的基本原理</h3><h4 id="序列密码体制的概念"><a href="#序列密码体制的概念" class="headerlink" title="序列密码体制的概念"></a>序列密码体制的概念</h4><p>在序列密码中，明文表示成一个序列，称为明文流，加密时，先由种子密钥（或称为主密钥）通过密钥流生成器 产生一个密钥流序列，然后依次把明文流和密钥流中的对应项做二元加法运算（异或运算），产生相应的密文流。</p><p>解密过程是将同样的密钥流与密文流中的对应项做二元加法运算，恢复出原来的明文流。</p><p><img src="https://img-blog.csdnimg.cn/7546123a41b6434881d51a880baca84a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">明文字为01101010</span><br><span class="line">密钥字为10110111</span><br><span class="line">加密</span><br><span class="line">01101010⊕10110111=11011101</span><br><span class="line">解密</span><br><span class="line">11011101⊕10110111=01101010</span><br></pre></td></tr></table></figure><p>如果密钥流是无周期的（真正随机的）无限长随机序列，那么此时的序列密码即为“一次一密”的密码体制。</p><h4 id="序列密码体制的分类"><a href="#序列密码体制的分类" class="headerlink" title="序列密码体制的分类"></a>序列密码体制的分类</h4><p>根据状态函数是否独立于明文或密文，可以将序列密码分为同步序列密码和自同步序列密码。</p><h5 id="同步序列密码的特点："><a href="#同步序列密码的特点：" class="headerlink" title="同步序列密码的特点："></a>同步序列密码的特点：</h5><p>（1）同步要求：在一个同步序列中，发送方和接收方必须是同步的，即用同样的密钥且该密钥操作在同样的位置（状态），才能保证正确地解密。</p><p>（2）无错误传播：在传输期间，一个密文字（或位）被改变（不是删除和插入）只能影响该密文字（或位）的恢复，不会对后续密文字（或位）产生影响。</p><p>（3）主动攻击破坏同步：按照同步要求，一个主动攻击对密文进行插入、删除或重放操作都会立即破坏其同步。</p><p>同步序列密码需要人为地把密文和密钥给它们整同步（密文第几比特，密钥第几比特）才能正确解密。</p><h5 id="自同步序列密码的特点"><a href="#自同步序列密码的特点" class="headerlink" title="自同步序列密码的特点"></a>自同步序列密码的特点</h5><p>（1）自同步：解密只取决于先前固定数量的密文字。自同步序列密码在同步丢失后能够自动重新建立同步，并正确地解密，只有固定数量的明文字不能解密。</p><p>（2）有限的错误传播：若一个密文字（或位）在传输过程中被修改（插入或删除），则解密时最多只影响到后续t个密文字的解密，即只发生有限的错误传播。</p><p>（3）难检测主动攻击：自同步使得主动攻击者发起的对密文字的插入、删除。重放等攻击只会产生非常有限的影响，正确的解密能很快自动重建。</p><p>自同步序列密码：即使密文和密钥暂时失去了同步，过一会它们自己还能给整同步（无需人为干预）。</p><p>序列密码许多研究成果并没有完全公开，这或许是因为序列密码目前主要应用于军事、外交等机密部门的缘故。序列密码的安全强度取决于密钥流生成器的设计，产生密钥流最重要的部件是线性反馈移位寄存器（LFSR），这是因为LFSR非常适合硬件实现、能产生较大周期和统计特性良好的序列，以及能够用代数方法对产生的序列进行很好的分析。</p><h4 id="线性反馈移位寄存器及密钥序列的伪随机性"><a href="#线性反馈移位寄存器及密钥序列的伪随机性" class="headerlink" title="线性反馈移位寄存器及密钥序列的伪随机性"></a>线性反馈移位寄存器及密钥序列的伪随机性</h4><h5 id="线性反馈移位寄存器"><a href="#线性反馈移位寄存器" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h5><p>移位寄存器是流密码产生密钥流的一个主要组成部分。GF(2)上一个n级反馈移位寄存器由n个二元存储器与一个反馈函数f(a<sub>1</sub> , a<sub>2</sub> , …. , a<sub>n</sub>)组成</p><p><img src="https://img-blog.csdnimg.cn/20200727180102465.png" alt="img"></p><p>(时钟滴答一声，a<del>1</del> ， a<del>2</del> ，…. , a<del>n</del> 都右移一位，a<del>1</del> 被挤出去了，做为这一步的输出比特，左边a<del>n</del> 还腾出来一个位置，被f(a<del>1</del>,a<del>2</del>,..,a<del>n</del>)补位，原来的a<del>2</del>就是新的a<del>1</del>  </p><p>每一个寄存器称为移位寄存器的一级，在任一时刻，这些级的内容构成改反馈的内容构成该反馈移位寄存器的状态，每一个状态对应于GF（2）上的一个n维向量，共有2^n^种可能的状态。每一时刻的状态可用n长序列（a<del>1</del>，a<del>2</del>,….,a<del>n</del>）来表示，其中a<del>i</del>是第i级存储器的内容。<br>$$<br>因为a1 ，a2 ，……，an∈ {0,1}，他们都有两种选择<br>，所以（a1，a2,……，an)2^n种状态<br>$$<br>初始状态由用户确定，当第i个移位是钟脉冲到来时，每一级存储器a<del>i</del>都将其内容向下一级a<del>i-1</del>传递，并计算f（a<del>1</del>，a<del>2</del>,a<del>3</del>,….,a<del>n</del>)作为下一时刻的a<del>n</del>。反馈函数f(a<del>1</del>,a<del>2</del>,a<del>3</del>,….,a<del>n</del>)是n元布尔函数，函数中的运算有逻辑与、逻辑或、逻辑补等，最后函数值也为0或1.</p><p>上一个栗子：</p><p><img src="https://img-blog.csdnimg.cn/867fe70a80b1430bbe1514e78f830412.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>反馈函数f(a<del>1</del>,a<del>2</del>,a<del>3</del>,a<del>4</del>,a<del>5</del>)=a<del>1</del>⊕a<del>4</del></p><p>相当于是f(a<del>1</del>,a<del>2</del>,a<del>3</del>,a<del>4</del>,a<del>5</del>)=c<del>5</del>a<del>1</del>⊕c<del>4</del>a<del>2</del>⊕c<del>3</del>a<del>3</del>⊕c<del>2</del>a<del>4</del>⊕c<del>1</del>a<del>5</del></p><p>其中c<del>5</del>=c<del>2</del>=1，c<del>4</del>=c<del>3</del>=c<del>1</del>=0</p><p>状态（a<del>5</del>，a<del>4</del>，a<del>3</del>，a<del>2</del>，a<del>1</del>）    输出a<del>1</del></p><table><thead><tr><th>a<del>5</del></th><th>a<del>4</del></th><th>a<del>3</del></th><th>a~2</th><th>a<del>1</del></th><th></th><th>a<del>1</del></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td></td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td></td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td></td><td>0</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学理论篇之序列密码体制&quot;&gt;&lt;a href=&quot;#密码学理论篇之序列密码体制&quot; class=&quot;headerlink&quot; title=&quot;密码学理论篇之序列密码体制&quot;&gt;&lt;/a&gt;密码学理论篇之序列密码体制&lt;/h1&gt;&lt;h2 id=&quot;Vernam（弗纳姆）密码技术&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="密码学" scheme="http://websec.space/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://websec.space/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学之实践篇</title>
    <link href="http://websec.space/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>http://websec.space/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2021-12-10T08:52:12.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之实践篇"><a href="#密码学之实践篇" class="headerlink" title="密码学之实践篇"></a>密码学之实践篇</h1><h3 id="N1CTF-python-（Feistel网络）"><a href="#N1CTF-python-（Feistel网络）" class="headerlink" title="N1CTF python   （Feistel网络）"></a>N1CTF python   （Feistel网络）</h3><p>题的代码如下</p><p>N1SE.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round_add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    f = <span class="keyword">lambda</span> x, y: x + y - <span class="number">2</span> * (x &amp; y)</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        res += <span class="built_in">chr</span>(f(<span class="built_in">ord</span>(a[i]), <span class="built_in">ord</span>(b[i])))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutate</span>(<span class="params">table, block</span>):</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: block[x], table))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_to_bits</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line">    l = <span class="built_in">len</span>(data) * <span class="number">8</span></span><br><span class="line">    result = [<span class="number">0</span>] * l</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">            result[(pos&lt;&lt;<span class="number">3</span>)+i] = (ch&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">s_box = [<span class="number">54</span>, <span class="number">132</span>, <span class="number">138</span>, <span class="number">83</span>, <span class="number">16</span>, <span class="number">73</span>, <span class="number">187</span>, <span class="number">84</span>, <span class="number">146</span>, <span class="number">30</span>, <span class="number">95</span>, <span class="number">21</span>, <span class="number">148</span>, <span class="number">63</span>, <span class="number">65</span>, <span class="number">189</span>, <span class="number">188</span>, <span class="number">151</span>, <span class="number">72</span>, <span class="number">161</span>, <span class="number">116</span>, <span class="number">63</span>, <span class="number">161</span>, <span class="number">91</span>, <span class="number">37</span>, <span class="number">24</span>, <span class="number">126</span>, <span class="number">107</span>, <span class="number">87</span>, <span class="number">30</span>, <span class="number">117</span>, <span class="number">185</span>, <span class="number">98</span>, <span class="number">90</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">140</span>, <span class="number">70</span>, <span class="number">86</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">150</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">144</span>, <span class="number">153</span>, <span class="number">36</span>, <span class="number">90</span>, <span class="number">149</span>, <span class="number">54</span>, <span class="number">156</span>, <span class="number">8</span>, <span class="number">59</span>, <span class="number">40</span>, <span class="number">110</span>, <span class="number">56</span>,<span class="number">1</span>, <span class="number">84</span>, <span class="number">103</span>, <span class="number">22</span>, <span class="number">65</span>, <span class="number">17</span>, <span class="number">190</span>, <span class="number">41</span>, <span class="number">99</span>, <span class="number">151</span>, <span class="number">119</span>, <span class="number">124</span>, <span class="number">68</span>, <span class="number">17</span>, <span class="number">166</span>, <span class="number">125</span>, <span class="number">95</span>, <span class="number">65</span>, <span class="number">105</span>, <span class="number">133</span>, <span class="number">49</span>, <span class="number">19</span>, <span class="number">138</span>, <span class="number">29</span>, <span class="number">110</span>, <span class="number">7</span>, <span class="number">81</span>, <span class="number">134</span>, <span class="number">70</span>, <span class="number">87</span>, <span class="number">180</span>, <span class="number">78</span>, <span class="number">175</span>, <span class="number">108</span>, <span class="number">26</span>, <span class="number">121</span>, <span class="number">74</span>, <span class="number">29</span>, <span class="number">68</span>, <span class="number">162</span>, <span class="number">142</span>, <span class="number">177</span>, <span class="number">143</span>, <span class="number">86</span>, <span class="number">129</span>, <span class="number">101</span>, <span class="number">117</span>, <span class="number">41</span>, <span class="number">57</span>, <span class="number">34</span>, <span class="number">177</span>, <span class="number">103</span>, <span class="number">61</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">74</span>, <span class="number">69</span>, <span class="number">147</span>, <span class="number">90</span>, <span class="number">49</span>, <span class="number">135</span>, <span class="number">124</span>, <span class="number">106</span>, <span class="number">19</span>, <span class="number">89</span>, <span class="number">38</span>, <span class="number">21</span>, <span class="number">41</span>, <span class="number">17</span>, <span class="number">155</span>, <span class="number">83</span>, <span class="number">38</span>, <span class="number">159</span>, <span class="number">179</span>, <span class="number">19</span>, <span class="number">157</span>, <span class="number">68</span>, <span class="number">105</span>, <span class="number">151</span>, <span class="number">166</span>, <span class="number">171</span>, <span class="number">122</span>, <span class="number">179</span>, <span class="number">114</span>, <span class="number">52</span>, <span class="number">183</span>, <span class="number">89</span>, <span class="number">107</span>, <span class="number">113</span>, <span class="number">65</span>, <span class="number">161</span>, <span class="number">141</span>, <span class="number">18</span>, <span class="number">121</span>, <span class="number">95</span>, <span class="number">4</span>, <span class="number">95</span>, <span class="number">101</span>, <span class="number">81</span>, <span class="number">156</span>, <span class="number">17</span>, <span class="number">190</span>, <span class="number">38</span>, <span class="number">84</span>, <span class="number">9</span>, <span class="number">171</span>, <span class="number">180</span>, <span class="number">59</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">34</span>, <span class="number">89</span>, <span class="number">75</span>, <span class="number">164</span>, <span class="number">190</span>, <span class="number">140</span>, <span class="number">6</span>, <span class="number">41</span>, <span class="number">188</span>, <span class="number">77</span>, <span class="number">165</span>, <span class="number">105</span>, <span class="number">5</span>, <span class="number">107</span>, <span class="number">31</span>, <span class="number">183</span>, <span class="number">107</span>, <span class="number">141</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">125</span>, <span class="number">50</span>, <span class="number">2</span>, <span class="number">153</span>, <span class="number">156</span>, <span class="number">162</span>, <span class="number">186</span>, <span class="number">76</span>, <span class="number">158</span>, <span class="number">153</span>, <span class="number">117</span>, <span class="number">9</span>, <span class="number">77</span>, <span class="number">156</span>, <span class="number">11</span>, <span class="number">145</span>, <span class="number">12</span>, <span class="number">169</span>, <span class="number">52</span>, <span class="number">57</span>, <span class="number">161</span>, <span class="number">7</span>, <span class="number">158</span>, <span class="number">110</span>, <span class="number">191</span>, <span class="number">43</span>, <span class="number">82</span>, <span class="number">186</span>, <span class="number">49</span>, <span class="number">102</span>, <span class="number">166</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">5</span>, <span class="number">189</span>, <span class="number">27</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">o</span>):</span></span><br><span class="line">    k = permutate(s_box,o)</span><br><span class="line">    b = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(k), <span class="number">7</span>):</span><br><span class="line">        b.append(k[i:i+<span class="number">7</span>] + [<span class="number">1</span>])</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> b[i]:</span><br><span class="line">x += (j&lt;&lt;pos)</span><br><span class="line">pos += <span class="number">1</span></span><br><span class="line">c.append((<span class="number">0x10001</span>**x) % (<span class="number">0x7f</span>))</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">N1ES</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(key) != <span class="number">24</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(key, <span class="built_in">bytes</span>) == <span class="literal">False</span> ):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;key must be 24 bytes long&quot;</span>)</span><br><span class="line">        self.key = key</span><br><span class="line">        self.gen_subkey()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_subkey</span>(<span class="params">self</span>):</span></span><br><span class="line">        o = string_to_bits(self.key)</span><br><span class="line">        k = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        o = generate(o)</span><br><span class="line">        k.extend(o)</span><br><span class="line">        o = string_to_bits([<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> o[<span class="number">0</span>:<span class="number">24</span>]])</span><br><span class="line">        self.Kn = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            self.Kn.append(<span class="built_in">map</span>(<span class="built_in">chr</span>, k[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>]))</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">self, plaintext</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(plaintext) % <span class="number">16</span> != <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(plaintext, <span class="built_in">bytes</span>) == <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;plaintext must be a multiple of 16 in length&quot;</span>)</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext) / <span class="number">16</span>):</span><br><span class="line">            block = plaintext[i * <span class="number">16</span>:(i + <span class="number">1</span>) * <span class="number">16</span>]</span><br><span class="line">            L = block[:<span class="number">8</span>]</span><br><span class="line">            R = block[<span class="number">8</span>:]</span><br><span class="line">            <span class="keyword">for</span> round_cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                L, R = R, (round_add(L, self.Kn[round_cnt]))</span><br><span class="line">            L, R = R, L</span><br><span class="line">            res += L + R</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>challenge.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> N1ES <span class="keyword">import</span> N1ES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;wxy191iss00000000000cute&quot;</span></span><br><span class="line">n1es = N1ES(key)</span><br><span class="line">flag = <span class="string">&quot;N1CTF&#123;*****************************************&#125;&quot;</span></span><br><span class="line">cipher = n1es.encrypt(flag)</span><br><span class="line"><span class="built_in">print</span> base64.b64encode(cipher)  <span class="comment"># HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx</span></span><br></pre></td></tr></table></figure><p>python2的代码，但是电脑没有python2的环境  ，期初想就是不下，宁愿py2转py3我都不去下py2 ，后面我发现我错了，python2转为python3之后bug不是我能预料到的，遂乖乖下载了py2，开整。</p><p>开始调试，debug功能告诉我，首先调用这个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_to_bits</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line">    l = <span class="built_in">len</span>(data) * <span class="number">8</span></span><br><span class="line">    result = [<span class="number">0</span>] * l</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">            result[(pos&lt;&lt;<span class="number">3</span>)+i] = (ch&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def encrypt(self, plaintext):</span><br><span class="line">    if (len(plaintext) % 16 != 0 or isinstance(plaintext, bytes) == False):</span><br><span class="line">        raise Exception(&quot;plaintext must be a multiple of 16 in length&quot;)</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    for i in range(len(plaintext) / 16):</span><br><span class="line">        block = plaintext[i * 16:(i + 1) * 16]</span><br><span class="line">        L = block[:8]</span><br><span class="line">        R = block[8:]</span><br><span class="line">        for round_cnt in range(32):</span><br><span class="line">            L, R = R, (round_add(L, self.Kn[round_cnt]))</span><br><span class="line">        L, R = R, L</span><br><span class="line">        res += L + R</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure><p>我们由分组密码可知，这是一个很明显的Feistel结构，Feistel结构的特点就是加密与解密过程大体一致，及将密钥倒过来，就可以成功获取到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在challenge.py添加如下代码：</span><br><span class="line">s1=base64.b64decode(&#x27;HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx&#x27;)</span><br><span class="line">flag = n1es.decrypt(s1)</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">构造解密的函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">self, plaintext</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(plaintext) % <span class="number">16</span> != <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(plaintext, <span class="built_in">bytes</span>) == <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;plaintext must be a multiple of 16 in length&quot;</span>)</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext) / <span class="number">16</span>):</span><br><span class="line">            block = plaintext[i * <span class="number">16</span>:(i + <span class="number">1</span>) * <span class="number">16</span>]</span><br><span class="line">            L = block[:<span class="number">8</span>]</span><br><span class="line">            R = block[<span class="number">8</span>:]</span><br><span class="line">            <span class="keyword">for</span> round_cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                L, R = R, (round_add(L, self.Kn[<span class="number">31</span>-round_cnt]))</span><br><span class="line">            L, R = R, L</span><br><span class="line">            res += L + R</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之实践篇&quot;&gt;&lt;a href=&quot;#密码学之实践篇&quot; class=&quot;headerlink&quot; title=&quot;密码学之实践篇&quot;&gt;&lt;/a&gt;密码学之实践篇&lt;/h1&gt;&lt;h3 id=&quot;N1CTF-python-（Feistel网络）&quot;&gt;&lt;a href=&quot;#N1CTF-pyt</summary>
      
    
    
    
    <category term="密码学" scheme="http://websec.space/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://websec.space/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学之理论篇（分组密码体制）</title>
    <link href="http://websec.space/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/"/>
    <id>http://websec.space/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2021-12-15T14:25:05.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇（分组密码体制）"><a href="#密码学之理论篇（分组密码体制）" class="headerlink" title="密码学之理论篇（分组密码体制）"></a>密码学之理论篇（分组密码体制）</h1><h2 id="四、分组密码体制"><a href="#四、分组密码体制" class="headerlink" title="四、分组密码体制"></a>四、分组密码体制</h2><h3 id="分组密码学的基本概念"><a href="#分组密码学的基本概念" class="headerlink" title="分组密码学的基本概念"></a>分组密码学的基本概念</h3><p>分组密码：</p><p>1、一个0、1分组一个0、1分组进行加密（不是一个比特一个比特进行加密）；</p><p>2、不同的分组利用同一个密钥进行加密；</p><p>3、还有个分组密码工作模式的问题，这章稍后会学。</p><blockquote><p>明文分组长度为n bit，密文分组长度m bit，若n&gt;m , 明文分组长度大于密文分组长度，称其为有数据压缩的分组密码;若n&lt;m,明文分组长度小于密文分组长度，称之为有数据扩展的分组密码；若n=m，明文分组等于密文分组长度，则称之为无数据扩展和压缩的分组密码，事实上，通常的分组密码均取n=m</p></blockquote><h3 id="分组密码的原理"><a href="#分组密码的原理" class="headerlink" title="分组密码的原理"></a>分组密码的原理</h3><p>香农提出了设计密码系统的两个基本方法——-扩散和混淆。目的是抗击攻击者对密码系统的统计分析。</p><h4 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h4><p>​    扩散的含义是将明文和密钥的统计特性散步到密文中去，使得明文和密钥每一比特在密文中得到充分扩散，使得密文不在显示任何形式的规律。</p><p><strong>扩散使得明文和密钥的每一位都影响密文中多位的值</strong></p><p>（扩散属于线性变换，差不多相当于“洗牌”）</p><h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p>​    混淆的含义是使密文和对应的明文与密钥之间的统计关系变得尽可能复杂，使得攻击者无法得到密文和明文及密钥之间的统计规律。</p><p>在分组密码中，对数据重复执行某个s盒变换（非线性变换），可获得混淆。</p><p>扩散和混淆是分组密码的最本质的操作，是设计分组密码的基础。</p><h4 id="代替-置换网络（s-p结构）"><a href="#代替-置换网络（s-p结构）" class="headerlink" title="代替-置换网络（s-p结构）"></a>代替-置换网络（s-p结构）</h4><p>大多数分组密码同时使用代替-置换网络以达到混淆和扩散的目标。</p><p>​    代替-置换网络（s-p网络）是由多重非线性代替（S）和比特置换（P）构成，s代替起到混淆的作用，P置换起到扩散的作用。</p><p><img src="https://img-blog.csdnimg.cn/ffc3c8a97341430e9e07b2e20f8cf182.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>P置换差不多相当于是 一次“广义的洗牌”：</p><p>有可能 牌的张数 前后保持不变；</p><p>也可能  洗完牌 被抽出去了几张牌，总牌数变少了；</p><p>也可能 把部分牌“复制”了一下，又把它们“粘贴”到</p><p>原来那摞牌中，这样总牌数就增多了。</p></blockquote><p>相当于s盒对明文分块加密，p进行一次洗牌，然后s盒再去加密，循环。</p><p>从b站找了一个例子，对其进行一波解析。</p><p><img src="https://img-blog.csdnimg.cn/b3249f18e7494e21beaf547954c1a531.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一段sp网络的加密 </span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">text=<span class="string">&quot;C# was developed around 2000 by Microsoft as part of its .NET initiative and later approved as an international standard by Ecma (ECMA-334) in 2002 and ISO (ISO/IEC 23270) in 2003. &quot;</span></span><br><span class="line">binarylist = [ <span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  <span class="built_in">list</span>(text.lower().encode(<span class="string">&#x27;utf-8&#x27;</span>))]    <span class="comment">#lowe()将大写转换为小写  zfill()指定返回的长度  一个utf-8 一个字节，故保留了8个bit</span></span><br><span class="line">plaintext = <span class="string">&quot;&quot;</span>.join(binarylist)    <span class="comment">#将字符串进行拼接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">length = <span class="number">16</span>     <span class="comment"># total bits = 8*length</span></span><br><span class="line">plaintext = plaintext[<span class="number">0</span>: <span class="number">8</span>*length]</span><br><span class="line">master = <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(random.randint(<span class="number">0</span>,<span class="number">1</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)))    <span class="comment">#根据plantext的长度随机生成一串01字符串，暂且称其为密钥，但这里是随机生成的128bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build a bijective table     所谓的s盒</span></span><br><span class="line">y = [<span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>)]</span><br><span class="line">random.shuffle(y)</span><br><span class="line">sbox = &#123;<span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>):y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>)&#125;</span><br><span class="line"><span class="comment"># build permutation table       p盒</span></span><br><span class="line">y = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">random.shuffle(y)           <span class="comment">#分配算法利用了shuffle</span></span><br><span class="line">ptable = &#123;i:y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)&#125;</span><br><span class="line"></span><br><span class="line">code = plaintext</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    code = <span class="string">&quot;&quot;</span>.join( <span class="string">&quot;0&quot;</span> <span class="keyword">if</span> code[i] == master[i] <span class="keyword">else</span> <span class="string">&quot;1&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)))  <span class="comment">#进行一波异或操作，将明文通过</span></span><br><span class="line">    temp = [sbox[code[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    <span class="comment"># 每8个字符划分成一组加密</span></span><br><span class="line">    slist = [temp[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length) ]</span><br><span class="line">    code = <span class="string">&quot;&quot;</span>.join(slist)</span><br></pre></td></tr></table></figure><p>这里没有写密钥去定义s盒的部分，如果能够通过密钥去定义s盒，然后通过p盒对密文分组进行分发，可以起到一个很好的效果。        peace~</p><h4 id="Feistel密码结构"><a href="#Feistel密码结构" class="headerlink" title="Feistel密码结构"></a>Feistel密码结构</h4><p>主密钥生成一个子密钥集，每个阶段使用一个子密钥，明文首先分为左右两部分，分别记为L<sub>0</sub>和R<sub>0</sub> ,在进行完r轮迭代之后，左右两半合并在一起在产生密文，每轮迭代的运算逻辑关系</p><p>L<sub>i</sub>=R<sub>i-1</sub></p><p>R<sub>i</sub>=L<sub>i-1</sub>⊕F(R<sub>i-1</sub> , K<sub>i</sub>)</p><p>其中，K<sub>i</sub>表示第i轮用的子密钥，F表示轮函数</p><img src="https://static.oschina.net/uploads/img/201610/17141512_yJxg.jpg" alt="一轮" style="zoom:50%;" /><p>喻：制作葱油饼</p><p>Feistel密码结构的另外一个显著的特点就是其逆向操作和正向操作是指具有相同的结构，二者唯一的不同就是子密钥使用次序不同。</p><p>（很有趣，利用异或的可逆性）</p><p>采用Feistel密码结构设计分组密码算法时，加解密可采用同一种算法。</p><p><img src="https://static.oschina.net/uploads/img/201610/17142027_eJ9Q.jpg" alt="输入图片说明"></p><p>贴一个 利用feitel网络设计的密码，类DES</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strEncrypt</span>(<span class="params">s1, s2, key</span>):</span>  <span class="comment"># 每次传输8个字符,分成两组按位异或,密钥4个字符</span></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        temp = <span class="built_in">ord</span>(s1[i]) ^ <span class="built_in">ord</span>(s2[i]) ^ <span class="built_in">ord</span>(key[i])</span><br><span class="line">        result += <span class="built_in">chr</span>(temp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">plainText, keylist</span>):</span></span><br><span class="line">    cipherText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(plainText) // <span class="number">8</span>):</span><br><span class="line">        temp = plainText[i * <span class="number">8</span>:(i + <span class="number">1</span>) * <span class="number">8</span>]  <span class="comment"># 每8个字符划分成一组加密</span></span><br><span class="line">        L = temp[:<span class="number">4</span>]</span><br><span class="line">        R = temp[<span class="number">4</span>:]</span><br><span class="line">        <span class="keyword">for</span> currentKey <span class="keyword">in</span> keylist:</span><br><span class="line">            temp2 = R</span><br><span class="line">            R = strEncrypt(L, R, currentKey)</span><br><span class="line">            L = temp2</span><br><span class="line">        cipherText += R + L</span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    key = []</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&#x27;请输入要加密的字符串，目前算法能处理的明文字符为8的整数倍&#x27;</span>)</span><br><span class="line">    keynum = <span class="built_in">input</span>(<span class="string">&#x27;请输入加密循环次数&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(keynum)):</span><br><span class="line">        temp = <span class="built_in">input</span>(<span class="string">&#x27;请输入第&#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27;组加密时使用的密钥（4个字符）&#x27;</span>)</span><br><span class="line">        key.append(temp)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;要加密的明文为：&#x27;</span>, a)</span><br><span class="line">    a = encode(a, key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;密文：&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#####解密</span></span><br><span class="line">    key.reverse()           <span class="comment">#倒序输出</span></span><br><span class="line">    a = encode(a, key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;解密后的明文：&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>此处推荐去查看密码学之实践篇  N1CTF (python)</p><h3 id="DES算法概述"><a href="#DES算法概述" class="headerlink" title="DES算法概述"></a>DES算法概述</h3><h4 id="DES算法概述-1"><a href="#DES算法概述-1" class="headerlink" title="DES算法概述"></a>DES算法概述</h4><p>数据加密标准(Data Encryption Standard,DES)，于1997年1月15日由美国国家标准局（NBS）正式发布实施，是第一公开的商用密码算法标准，但随着密码分析技术和计算能力的提高，DES算法不在安全，在2000年，DES算法已被更为安全AES算法取代。</p><p>（DES的最主要问题是密钥长度太短，特别是有效密钥长度太短了（<strong>56比特</strong>）。以现在的计算能力，可以用密钥穷举攻击破解DES。给定一密文，算法已知，尝试利用所有的密钥对密文进行解密，若能解密出一个实际意义的明文，则所用密钥记为有效密钥。但其实这也好办，多加密几次，难度成指数级增长，咋可能解，套！属于工作模式研究的内容）</p><p>​    DES算法是一种典型的Feistel结构的分组密码算法，它的明文分组长度为64bit，密钥长度为64bit，其中密钥有8bit是奇偶校验，因此有效密钥长度为56bit。DES算法的加密和解密采用同一过程，它的安全性依赖于有效密钥。DES算法首先把需要加密的明文划分为每64bit的数据块，用56bit有效密钥和64bit数据块加密。</p><p>DES算法，运算速度快。</p><h4 id="DES-算法描述"><a href="#DES-算法描述" class="headerlink" title="DES 算法描述"></a>DES 算法描述</h4><h5 id="初始置换（IP）"><a href="#初始置换（IP）" class="headerlink" title="初始置换（IP）"></a>初始置换（IP）</h5><p>DES会对用户输入进行处理，称为<strong>初始置换</strong></p><p>首先将输入的64bit的明文块，进行置换。</p><p>即将用户输入的明文的第58位会成为这个过程的结果IP的第一位，以此类推。</p><table><thead><tr><th>58</th><th>50</th><th>42</th><th>34</th><th>26</th><th>18</th><th>10</th><th>2</th></tr></thead><tbody><tr><td>60</td><td>52</td><td>44</td><td>36</td><td>28</td><td>20</td><td>12</td><td>4</td></tr><tr><td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td><td>14</td><td>6</td></tr><tr><td>64</td><td>56</td><td>48</td><td>40</td><td>32</td><td>24</td><td>16</td><td>8</td></tr><tr><td>57</td><td>49</td><td>41</td><td>33</td><td>25</td><td>17</td><td>9</td><td>1</td></tr><tr><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td></tr><tr><td>61</td><td>53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td></tr><tr><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td></tr></tbody></table><p>完成上述步骤，IP被分为等长的两部分，就可以获得初始的L 和R的值。</p><h5 id="subkey的生成（密钥置换）"><a href="#subkey的生成（密钥置换）" class="headerlink" title="subkey的生成（密钥置换）"></a>subkey的生成（密钥置换）</h5><p>不考虑每个字节的第8位，DES的密钥由64位减至56位，每个字节的第8位作为奇偶校验位。产生的56位密钥由下表生成（注意表中没有8,16,24,32,40,48,56,64这8位）：</p><table><thead><tr><th>57</th><th>49</th><th>41</th><th>33</th><th>25</th><th>17</th><th>9</th><th>1</th><th>58</th><th>50</th><th>42</th><th>34</th><th>26</th><th>18</th></tr></thead><tbody><tr><td>10</td><td>2</td><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td><td>60</td><td>52</td><td>44</td><td>36</td></tr><tr><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td><td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td></tr><tr><td>14</td><td>6</td><td>61</td><td>53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td><td>28</td><td>20</td><td>12</td><td>4</td></tr></tbody></table><p>在DES的每一轮中，从56位密钥产生出不同的48位子密钥，确定这些子密钥的方式如下：</p><p>　　1).将56位的密钥分成两部分，每部分28位。</p><p>　　2).根据轮数，这两部分分别循环左移1位或2位。每轮移动的位数如下表：</p><table><thead><tr><th>轮数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>位数</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td></tr></tbody></table><p>移动一次产生一组密钥。共产生了16组。　　</p><p>移动后，从56位中选出48位。这个过程中，既置换了每位的顺序，又选择了子密钥，因此称为压缩置换。压缩置换规则如下表（注意表中没有9，18，22，25，35，38，43和54这8位）：</p><table><thead><tr><th>14</th><th>17</th><th>11</th><th>24</th><th>1</th><th>5</th><th>3</th><th>28</th><th>15</th><th>6</th><th>21</th><th>10</th></tr></thead><tbody><tr><td>23</td><td>19</td><td>12</td><td>4</td><td>26</td><td>8</td><td>16</td><td>7</td><td>27</td><td>20</td><td>13</td><td>2</td></tr><tr><td>41</td><td>52</td><td>31</td><td>37</td><td>47</td><td>55</td><td>30</td><td>40</td><td>51</td><td>45</td><td>33</td><td>48</td></tr><tr><td>44</td><td>49</td><td>39</td><td>56</td><td>34</td><td>53</td><td>46</td><td>42</td><td>50</td><td>36</td><td>29</td><td>32</td></tr></tbody></table><p>​     置换方法同上，此处省略。</p><p>根据此表，在知道一组C<sub>1</sub>和D<sub>1</sub>的情况下可以反推出K1</p><h5 id="轮结构"><a href="#轮结构" class="headerlink" title="轮结构"></a>轮结构</h5><p><img src="https://img-blog.csdnimg.cn/a8073c7b5a4b46d6831fd1cab1c448c0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_10,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>每一轮变换由下面公式</p><p>L<sub>i</sub>=R<sub>i-1</sub></p><p>R<sub>i</sub> = L<sub>i-1 </sub>⊕F (R<sub>i-1</sub> , K<sub>i</sub>)</p><p>经过一轮IP置换之后得到输出64 bit，可以进入16轮的轮变换 ，轮变换即传统的Feistel结构，先将其拆分成两个32 bit，然后进入E函数，后进入S盒进行置换</p><p>(1)每轮置换会进入E函数并拓展成48位，就是索引拓展，</p><table><thead><tr><th>32</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td></tr><tr><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td></tr><tr><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td></tr><tr><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td></tr><tr><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td></tr><tr><td>28</td><td>29</td><td>30</td><td>31</td><td>32</td><td>1</td></tr></tbody></table><p>（2）完成拓展后会与subkeys进行异或操作，得到48bit数据。</p><p>（3）48bit的数据被分为8组，每组6bit，分别进入8个s盒进行压缩，最终输出32bit</p><p><strong>注：S盒代替是DES算法唯一的非线性变换，是保证DES算法安全性的源泉 （s盒作用混淆）</strong></p><p>一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数。S盒的6个输入确定了其对应的输出在哪一行哪一列，输入的高低两位做为行数H，中间四位做为列数L，在S-BOX中查找第H行L列对应的数据(&lt;32)。</p><p><img src="https://img-blog.csdnimg.cn/a17e98f294ca4d5cb9de1f89678fc017.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>例如，假设S盒8的输入为110011，第1位和第6位组合为11，对应于S盒8的第3行；第2位到第5位为1001，对应于S盒8的第9列。S盒8的第3行第9列的数字为12，因此用1100来代替110011。注意，S盒的行列计数都是从0开始。代替过程产生8个4位的分组，组合在一起形成32位数据。</p><h4 id="DES的各种变形算法"><a href="#DES的各种变形算法" class="headerlink" title="DES的各种变形算法"></a>DES的各种变形算法</h4><p>只有56bit有效密钥长度的DES算法不再是安全的，目前DES算法已被更为安全的高级加密标准（AES算法）取代。另外一种替代DES的方式是将DES算法在多密钥下多重使用，如二重DES、3DES等DES变形算法</p><h5 id="二重DES"><a href="#二重DES" class="headerlink" title="二重DES"></a>二重DES</h5><p>对明文加密不是使用一个密钥，而采用两个互不相同的密钥K<sub>1</sub>和K<sub>2</sub>进行连续加密，因此二重DES的有效密钥长度实际为112bit  ，其安全强度得到了极大的提升。</p><p>即</p><p><img src="https://img-blog.csdnimg.cn/20200223103519611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI4NzM4,size_16,color_FFFFFF,t_70" alt="img"></p><p>因此密钥破解难度从 2<sup>56</sup> 变成 2<sup>112</sup></p><h5 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h5><img src="https://img-blog.csdnimg.cn/105df0b3b1f24e5a82559d0a31e0900a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><h4 id=""><a href="#" class="headerlink" title=""></a></h4><img src="https://img-blog.csdnimg.cn/6eb8f4a1b6fd447b86c8494b6854b0c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/86237374e4a54d2d8821c62c527fd134.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/401ba6c3049542388b92495873254083.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>AES（Advanced Encryption Standard）又称为Rijndael加密法(英语：瑞珍代傲)</p><p>2000年10月Rijndael凭借其安全性、高效率、可实现和使用灵活等优点成为美国新的高级加密标准(AES)，这一标准的问世取代了DES数据加密标准成为21世纪保护敏感信息的高级加密算法。</p><p>Rijndael算法的设计者是两位比利时的密码专家Joan Daemen 博士和Vincent Rijmen博士</p><h4 id="AES算法描述"><a href="#AES算法描述" class="headerlink" title="AES算法描述"></a>AES算法描述</h4><p>Rijndael是一种使用灵活的、明文分组长度可变、密钥长度也可变的分组密码算法。明文分组长度和密钥长度彼此独立地确定为128/192/256 bit，因而Rijndael算法可以有9种不同的版本。</p><p><img src="https://img-blog.csdnimg.cn/cfcd1361e97b44aeb4a4b05bce3ebfd5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>NIST选中Rijndael算法作为AES算法，限定了明文分组为128bit，而密钥长度为128、192 、256 bit，因而AES有三个版本：AES-128、 AES-192、 AES-256，相应的迭代轮数为10轮、12轮、14轮</p><p>AES的基本运算单位是Byte</p><h5 id="AES加密过程"><a href="#AES加密过程" class="headerlink" title="AES加密过程"></a>AES加密过程</h5><p><img src="https://img-blog.csdnimg.cn/a5f7058194274ff8b7f86c8f4cab60f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>（1）AddRoundKey：矩阵中的每字节都与该回合密钥（round key）做XOR运算，每个子密钥由密钥生成方案产生。</p><p>（2）SubBytes：透过一个非线性的替换函数，用查找表的方式把每字节替换成对应字节。</p><p>（3）ShifRows：将矩阵中的每个横列进行循环式移位。</p><p>（4）MixColumns：充分混合矩阵中各列的操作，使用线性转换混合每列的4字节，最后一个加密循环中省略本步骤，而以AddRoundKey</p><p><img src="https://img-blog.csdnimg.cn/f3dd942a56344ad89b0c1407fc15afbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><blockquote><p>有限域（Finite Field）是包含有限个元素的域，可以简单理解为包含有限个元素的集合，其中可以对包含的元素执行加、减、乘、除等操作。<br>在密码学中，有限域GF(p)是一个重要的域，其中p为素数。简单来说，GF(p)=mod p,因为一个数对p取模后，结果肯定在[0,p-1]区间内。对于域中的元素a和b，(a+b) mod p和(a<em>b) mod p的结果都是域中的元素。GF(p)中的加法和乘法与一般的加法和乘法相同，只是模上了p，但减法和除法利用其负元素进行运算。任意元素a∈GF(g)有乘法逆元素a和加法负元素-a，使得α</em>(a<sup>-1</sup>)=e和 a+(-a)=0。</p></blockquote><h4 id="Rijndael密钥生成"><a href="#Rijndael密钥生成" class="headerlink" title="Rijndael密钥生成"></a>Rijndael密钥生成</h4><p>AES的加密过程中用到的并不是输入的128~256位的短密钥，而是基于该短密钥生成的一系列子密钥，通过原密钥生成子密钥的算法称为 Rijndael密钥生成方案（Rijndael KeySchedule)。每轮中，数据都需要与128位的子密钥异或，根据原始密钥生成各轮子密钥的过程是由Rijndael密钥生成方案完成的。</p><p><img src="https://img-blog.csdnimg.cn/67b52402adc7445ab1a3b82122978422.png" alt="img"></p><p>先取出最后一行|17 e2 b8 70|，进行循环左移，变为|e2 b87017l，再对S盒进行索引，变为|cd 36 ee 77。然后，把第一位与Rcon数组中的第一个元素异或操作，Rcon是一个预先定义好的数组，其中的第i项是2在GF(2^8)下的i-1次方。</p><p>GF(2^8)扩展域下的运算与GF(2)的同理，在扩展域中，把一个数看成一个7次多项式:</p><p>多项式:x<sup>6</sup>+x<sup>4</sup>+x+1      二进制:{01010011}           十进制:{53}</p><p>可以看到，多项式中每个系数相当于二进制中对应的位，所以可以把GF(8)下的运算直接转换成多项式之间的运算。但是运算的结果可能超过255，所以需要对这些超过范围的数进行化简。在之前讲的GF(2)中，直接把结果对2取模，但在拓展域中直接规定了一个多项式，两个多项式相乘的结果直接对该多项式取模即可。在AES中采用了以下多项式:</p><p>p(x)= x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1</p><p>Rcon第9项可以用如下方法来计算:</p><p>x<sup>8</sup>=p(x)+x<sup>4</sup>+x<sup>3</sup>+x+1      —&gt;    x<sup>8</sup>≡(x<sup>4</sup>+x<sup>3</sup>+x+1 )mod p(x)</p><p>所以第9项对应的多项式为x<sup>4</sup>+x<sup>3</sup>+x+1，换算成十进制数就是27。</p><p>这样得到Rcon数组中的每一项，对于之前得到的数据|cd 36 ee 77|，将其第1位与Rcon[1]进行异或操作，得到|cc 36 ee 77|，将这组与第一行的数据| 5a 55 57 20|进行异或,就可以得到下一轮子密钥的第一行|96 63 b9 57|了。</p><p>接下来，第二轮子密钥的第2行等于第二轮子密钥的第1行与第一轮子密钥的第2行进行异或操作的结果。第二轮第3行和第4行的密钥也一样，详细的步骤见图7-3-8。</p><p>最后经过10轮运算，就可以得到AES 每轮所使用的子密钥了。</p><p><img src="https://img-blog.csdnimg.cn/0800330c5fb84e0b967856373f71502f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h4 id="基本变换"><a href="#基本变换" class="headerlink" title="基本变换"></a>基本变换</h4><p>AES算法中，加密和解密操作都是在一个4*4的字节矩阵上运作，这个矩阵称为状态</p><p>AES算法中初始状态矩阵由1组长度为128bit 明文分组构成，以字节为单位，则总共有16byte，记为B<sub>0</sub> , B<sub>1</sub> , B<sub>2</sub> , …. , B<sub>14</sub> , B<sub>15</sub> 。从左到右开始，则前4个字节组成明文状态矩阵第1阵，后四个字节组成第2列，依此类推。</p><p><img src="https://img-blog.csdnimg.cn/16313432c476407b9033dcd024a4cb31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h4 id="字节代替（SubBytes）"><a href="#字节代替（SubBytes）" class="headerlink" title="字节代替（SubBytes）"></a>字节代替（SubBytes）</h4><p>Rijndael算法的字节代替（SubBytes）使用一个S盒进行非线性置换，S盒是一个16*16的矩阵，字节代替将输入的状态矩阵的每一个字节通过一个简单查表操作映射为另外一个字节。映射方法是：输入字节的前4bit指定S盒的行值，后4bit指定S盒的列值，行和列所确定S盒位置的元素作为输出，例如输入字节“03”，行值为0，列值为3。可知第0行和第3列对应的值为“7B”，因此输出字节为”7B“。</p><p>s盒是非线性变换</p><p><img src="https://img-blog.csdnimg.cn/4b5ebf71a2f4457fbfe7b66768f89a34.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><p>AES密码算法采用的是S-P网络结构，加密过程与解密过程</p><p>(行移位 事实上也是一种置换（p），相当于是“洗牌”。)</p><img src="https://img-blog.csdnimg.cn/d5fffd0300cd49a8ae14987ad9434ff0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 80%;" /><h3 id="SM4加密算法"><a href="#SM4加密算法" class="headerlink" title="SM4加密算法"></a>SM4加密算法</h3><h4 id="SM4描述"><a href="#SM4描述" class="headerlink" title="SM4描述"></a>SM4描述</h4><p>中国国家密码管理局于2006年1月6日发布第7号公告，将我国无线局域网产品的加密算法确定为SM4算法。这是国内官方公布的<strong>第一个商用算法</strong>。（国密算法）</p><p>SM4是一个分组算法。该算法的分组长度为128比特，密钥长度为128比特。加密算法与密钥扩展算法都采用32轮非线性迭代结构。解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p><p>SM4算法采用的基本运算：异或和循环左移等。</p><h4 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h4><p>SM4算法采用以下基本运算：</p><p>（1）⊕                        表示32bit异或</p><p>（2）&lt;&lt;&lt;i                    表示32bit循环左移i位</p><p>2.轮函数F</p><p>SM4算法采用非线性迭代结构，以字（32bit）为单位。</p><p>1）合成置换 T</p><p>2)非线性变换 t</p><p>t是由4个并行的s盒代替构成，为固定的8bit输入盒8bit输出的代替，记为Sbox()</p><p><img src="https://img-blog.csdnimg.cn/170f10a8f9c74655a4904c1a28c51a4e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>S盒的代替规则：输入的前4位为行号，后4位为列号，行列交叉处S盒列表中的数值为输出。例如输入“2a”，则行号“2”，列号“a”，第二行第a列输出值为“0b”，</p><img src="https://img-blog.csdnimg.cn/f6981d10fafc43049dfa42a599a6ab38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><h3 id="其他类型的分组密码体制简介"><a href="#其他类型的分组密码体制简介" class="headerlink" title="其他类型的分组密码体制简介"></a>其他类型的分组密码体制简介</h3><h4 id="国际数据加密算法（IDEA）"><a href="#国际数据加密算法（IDEA）" class="headerlink" title="国际数据加密算法（IDEA）"></a>国际数据加密算法（IDEA）</h4><p>IDEA是X.J.Lai（来学嘉）和Massey在1990年提出，IDEA算法硬件和软件实现都很容易且比DES的实现速度更快。从它提出至今，还未发现明显的弱点，对密码分析具有很强的抵抗能力，在多种商业产品中被使用。</p><p>IDEA算法分组长度为64bit，密钥长度128bit</p><h5 id="基本运算-1"><a href="#基本运算-1" class="headerlink" title="基本运算"></a>基本运算</h5><p>IDEA算法整个运算过程全部在16bit子块上进行。</p><p>⊕：表示16bit的逐位异或。</p><p><img src="https://img-blog.csdnimg.cn/2dbb8feea29d4a51853ead90326f1e2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h5 id="加密算法流程"><a href="#加密算法流程" class="headerlink" title="加密算法流程"></a>加密算法流程</h5><p>IDEA算法一组明文是64 bit，首先被划分为4个子块X<sub>0</sub>、X<sub>1</sub>、X<sub>3</sub>、X<sub>4</sub>，每个子块16 bit。然后将4个16 bit子块作为算法第1轮输入，进行迭代运算。每一轮运算有4个16 bit子块和6个16 bit子密钥块参与运算，相互之间进行异或、相加、相乘，最后输出4个16 bit的子块，作为下一轮的输入。总共迭代8次，得到4个16 bit子块，再与4个 16 bit子密钥进行输出变换，最终得到64 bit密文Y<sub>1</sub>，Y<sub>1</sub>,Y<sub>2</sub>，Y<sub>3</sub> 。</p><img src="https://img-blog.csdnimg.cn/8c2f157d01e1418a93415d61c66c825d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><h3 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h3><p>即使有了安全的分组密码算法，也需要采用恰当的工作模式来隐蔽明文的统计特性、数据格式等</p><p>五种运行模式：电子码本（ECB）、密码分组链接（CBC）、计数器（CTR）、输出反馈（OFB）、密码反馈（CFB），任何分组密码算法都可以根据不同的应用场合选择使用其中一种模式。</p><h5 id="ECB（电子码本）模式"><a href="#ECB（电子码本）模式" class="headerlink" title="ECB（电子码本）模式"></a>ECB（电子码本）模式</h5><p>ECB模式是最简单的模式，每个分组用同一密钥加密，同样明文分组得到相同的密文。</p><p><img src="https://pic4.zhimg.com/80/v2-4dad7796144001832bc946fa69526ccb_720w.jpg" alt="img"></p><p>ECB模式的特性：</p><p>（1）在给定的密钥下，同意明文组总产生同样的密文组。</p><p>（2）各组的加密独立于其他分组。</p><p>（3）无错误传播。单个密文分组中有一个或多个比特错误只会影响该分组的解密结果。</p><p>（4）安全性有限。由于同一明文产生同样的密文，这回暴露明文数据的格式和统计特征。</p><p>当消息长度超过一个组或者重复使用密钥加密多个单组消息，不建议使用ECB。</p><h5 id="CBC（密码分组链接）模式"><a href="#CBC（密码分组链接）模式" class="headerlink" title="CBC（密码分组链接）模式"></a>CBC（密码分组链接）模式</h5><p>CBC模式比ECB模式实现起来复杂，更具有安全性，因此它是最普遍使用的分组密码运行模式。</p><p><img src="https://img-blog.csdnimg.cn/b305fe0eeec24a4ca22e1527c01ab056.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>C<sub>2</sub>和P<sub>1</sub> 、P<sub>2</sub>都有关系</p><p>…….</p><p>C<sub>N</sub>和P<sub>1</sub> 、P<sub>2</sub>，。。</p><p>反复加密解密加密解密，有点盐值的感觉</p><p>喻：利用第一个面团做出了第一个葱油饼；把第一个葱油饼和第二个面团进行和面，做出第二个葱油饼；把第二个葱油饼和第三个面团进行和面，做出第三个葱油饼；。。。</p><p>CBC模式的特性：</p><p>（1）能够隐蔽明文数据的格式规律和统计特性，相同的明文分组产生不同的密文分组。</p><p>（2）CBC模式各密文分组不仅与当前明文组有关，而且还通过反馈作用与以前明文组有关。</p><p>（3）具有错误传播。</p><p>一旦一个密文分组损坏，就会影响后面的进行</p><h5 id="CFB（密码反馈）模式"><a href="#CFB（密码反馈）模式" class="headerlink" title="CFB（密码反馈）模式"></a>CFB（密码反馈）模式</h5><p>DES是分组长度为64bit的分组密码，但利用CFB模式或OFB模式可将DES转换为序列密码（流密码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES-CFB与DES的一个重要不同：</span><br><span class="line">DES没有直接作用于明文分组，DES仅用来产生密钥了。</span><br><span class="line">DES-CFB中明文加密：</span><br><span class="line">直接与密钥做异或！</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/469f6b710be64046be14897a07db8282.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>加密算法输出的最左（最高有效位）j比特与明文的第一组P<sub>1</sub>进行异或，产生出1组j比特密文C<sub>1</sub>  ,    然后将移位寄存器的内容左移j位，并将C<sub>1</sub> 送入移位寄存器最右边（最低有效位）j 位。</p><p>CFB模式实际上是 一种自同步序列密码，分组密码算法用来提供复杂的非线性逻辑的密钥流生成器作用，若待加密消息必须按字符（如电传电报）或按比特处理，可采用CFB模式。CFB实际上是将加密算法DES作为一个密钥流产生器，当j=1时就退化为流密码。</p><p>密文分组C<sub>i</sub> 依赖于P<sub>i</sub> 和前面的所有明文分组。</p><h5 id="OFB（输出反馈）模式"><a href="#OFB（输出反馈）模式" class="headerlink" title="OFB（输出反馈）模式"></a>OFB（输出反馈）模式</h5><p>OFB模式的结构类似于CFB，将分组密码算法作为一个密钥流产生器。</p><p>与CFB模式相比不同之处如下：CFB模式是将密文单元反馈到移位寄存器，而OFB模式是将加密算法的输出反馈到移位寄存器</p><p><img src="https://pic2.zhimg.com/v2-942f1bd34096a8278766cabc74fd4765_r.jpg" alt="preview"></p><p>OFB模式传输过程中的比特错误不会被传播</p><h5 id="CTR（计数器）模式"><a href="#CTR（计数器）模式" class="headerlink" title="CTR（计数器）模式"></a>CTR（计数器）模式</h5><p>与CFB、OFB模式类似，CTR模式也是将分组密码作为序列密码密钥流生成器，CTR模式加密和解密采用相同方案，都使用加密函数而非解密函数。CTR模式实际就是一种通过逐次累加的计数器进行的加密来产生密钥流的序列密码。</p><p><img src="https://img-blog.csdnimg.cn/d183ac3ef8d7460a9310d69514422fa8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>CTR模式的特性：</p><p>（1）CTR模式能够对多个分组的加密、解密进行并行处理。</p><p>（2）密文分组的处理与其他密文无关，易于实现。</p><h3 id="分组密码算法的安全性分析"><a href="#分组密码算法的安全性分析" class="headerlink" title="分组密码算法的安全性分析"></a>分组密码算法的安全性分析</h3><h4 id="分组密码算法的分析方法"><a href="#分组密码算法的分析方法" class="headerlink" title="分组密码算法的分析方法"></a>分组密码算法的分析方法</h4><p>分组密码算法分析主要有基于数学方法的分析方法、结合物理实现方法的侧信道密码分析方法和强力攻击。</p><h5 id="基于数学方法的分析方法"><a href="#基于数学方法的分析方法" class="headerlink" title="基于数学方法的分析方法"></a>基于数学方法的分析方法</h5><p>自20世纪90年代提出差分分析和线性分析对DES算法成功破解以来，差分分析和线性分析成为了分组密码最有效的基于数学的分析方法。</p><p>（”对DES成功破解“ 有点夸大，最多也就是 找到密钥（或者子密钥）的部分信息。 对于一个新的分组密码算法来说，能抵挡差分分析和线性分析，这是最基本的要求。）</p><h5 id="结合物理实现方法的侧信道密码分析方法"><a href="#结合物理实现方法的侧信道密码分析方法" class="headerlink" title="结合物理实现方法的侧信道密码分析方法"></a>结合物理实现方法的侧信道密码分析方法</h5><p>结合密码算法具体实现所处的物理环境，通过探测密码算法在运行过程中泄露的某些侧信息，例如温度、时间、能量、电磁、声音等信息的差异，来推断密钥信息。这种结合物理实现方法的攻击方式一般称为侧信道攻击（边信道攻击）。</p><h5 id="强力攻击"><a href="#强力攻击" class="headerlink" title="强力攻击"></a>强力攻击</h5><p>1）穷举密钥搜索攻击</p><p>随着计算机计算力的快速提高，之前理论上安全的一些密码算法也变得不安全，如密钥长度为256bit的DES算法穷举攻击可行。</p><h4 id="差分分析"><a href="#差分分析" class="headerlink" title="差分分析"></a>差分分析</h4><p>差分分析是迄今已知最有效的攻击迭代密码的算法之一，差分分析适用于有固定S盒的密码算法</p><p>确定最后一轮的子密钥或其中一部分是可行的</p><p><img src="https://img-blog.csdnimg.cn/721976253c944c31ba122d696f8afeee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇（分组密码体制）&quot;&gt;&lt;a href=&quot;#密码学之理论篇（分组密码体制）&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇（分组密码体制）&quot;&gt;&lt;/a&gt;密码学之理论篇（分组密码体制）&lt;/h1&gt;&lt;h2 id=&quot;四、分组密码体制&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="密码学" scheme="http://websec.space/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://websec.space/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学之理论篇（概述及古典密码学）</title>
    <link href="http://websec.space/2021/12/01/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://websec.space/2021/12/01/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2021-12-18T08:19:55.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇（概述及古典密码学）"><a href="#密码学之理论篇（概述及古典密码学）" class="headerlink" title="密码学之理论篇（概述及古典密码学）"></a>密码学之理论篇（概述及古典密码学）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="密码学在信息安全中的作用"><a href="#密码学在信息安全中的作用" class="headerlink" title="密码学在信息安全中的作用"></a>密码学在信息安全中的作用</h3><p>密码学是信息安全的基石，是信息安全的核心技术。</p><p>密码学绝不是保证信息安全的唯一技术，确保信息安全，除了技术之外，管理也是非常重要的一个方面。（安全管理的重要性）</p><h3 id="密码学的发展历程"><a href="#密码学的发展历程" class="headerlink" title="密码学的发展历程"></a>密码学的发展历程</h3><p>古典密码学阶段，密码学基本上可以说是一门技巧性很强的艺术（玩不来艺术，呜呜呜），而不是一门科学。</p><p>1949年，香农在《贝尔系统技术》杂志上发表了<strong>“保密系统的通信理论”</strong> ，为密码学奠定了坚实的理论基础，是密码学真正成了一门科学。</p><p>1976年，W.E.Diffie 和 M.E.Hellman发表了《密码学新方向》一文，提出了一种全新的密码设计思想，导致了密码学史上的一场革命（公钥密码学或非对称密钥密码学）</p><p>1977年美国国家标准局，正式公布了数据加密标准DES</p><p>1978年 R.L.Rivest  、 A.Shamir 、L.Adleman确立了RSA公钥密码学，成为了公钥密码学的杰出代表。</p><p>1984年 Charles H.Bennett和Brassard Gille首次提出了量子密码学，他可以发现窃听等攻击。</p><p>1985年，N.Koblitz 和 V.Miller 把椭圆曲线理论运用到公钥密码学中</p><p>于此同时——-序列密码，主要用于政府、军事等国家要害部门，1989年 R.Mathews    D.Wheeler      L.M.Pecora 和 Carroll等人首次把混沌理论使用到序列密码及保密通信理论中</p><p>1994年,Adleman利用DNA计算解决了一个有向汉米尔顿路径问题，出现了一个新的密码学领域——–DNA密码</p><p>1996年，Ajtai在格问题困难性的基础上，（基于格的公钥密码）</p><p>2000年10月，由比利时密码学家Joan Daemen、Vincent Rijmen 发明的Rijndael密码算法成为新一代数据加密标准——-AES算法</p><p>都是大佬膜拜。。</p><h3 id="密码学的基本知识"><a href="#密码学的基本知识" class="headerlink" title="密码学的基本知识"></a>密码学的基本知识</h3><p>经典密码学包括<strong>密码编码学</strong>和<strong>密码分析学</strong></p><p>密码编码学是研究把信息（明文）变换成没有密钥就不能解读或很难解读的密文的方法。</p><p>密码分析学是研究分析破译密码的方法</p><p>现代密码学除了密码编码学和密码分析学两个学科之外，还包括近几年才形成的新分支——-<strong>密钥密码学</strong>，它是以密钥（现代密码学的核心）及密钥管理作为研究对象的学科</p><p>现代密码学最重要的原则是“一切秘密寓于密钥之中”。即算法是公开的，但密钥必须是保密的。</p><blockquote><p>密码编码学、密码分析学、密钥密码学</p></blockquote><h3 id="保密通信模型"><a href="#保密通信模型" class="headerlink" title="保密通信模型"></a>保密通信模型</h3><p>1949年，香农（C.E.Shannon）发表了一篇题为《保密系统的信息理论》的论文，该论文用信息论的观点对信息保密问题进行了全面的阐述</p><p>香农从概率统计的观点出发研究信息的传输和保密问题，保密系统设计的目的是使窃听者（或攻击者）即使在完全准确地收到了接受信号的情况下，也无法恢复出原始信息。</p><p><img src="https://img-blog.csdnimg.cn/9a6169fc98a1470ab902c170be3c188c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>如果假定信道是无干扰的，则合法的密文接收者能够利用解密变换和密钥从密文中恢复明文，即m=D<sub>k</sub>(c)=D<sub>k</sub>(E<sub>k</sub>(m)).</p><p>此处D为decode解密，E为encode，k为密钥</p><p>假定密码分析者能够从信道上截获密文，还假定密码分析者知道所用的密码体制，还知道明文空间和密钥空间机器统计特性（这就是所谓的Kerckhoffs假设）那么密码体制的安全性完全取决于所选用的密钥的安全性。（密钥的破解难度，以及分发的安全性）</p><p>料敌从宽，锁是公开的，锁芯和钥匙不公开。</p><h3 id="密码学基本知识"><a href="#密码学基本知识" class="headerlink" title="密码学基本知识"></a>密码学基本知识</h3><p>一个密码体制或密码算法通常由一下五个部分构成</p><p>（1）明文空间M（全体明文的集合）</p><p>（2）密文空间C（全体密文的集合）</p><p>（3）密钥空间K（全体密钥集合）</p><p>（4）加密器或加密变换（算法）E ，E<sub>k</sub>(m)=c ,m∈M， c∈C, k∈K</p><p>（5）解密器或解密变换（算法）D<sub>k</sub>(c)=m   ,m∈M， c∈C, k∈K</p><blockquote><p>明文 message——&gt;M</p><p>密文ciphertext—–&gt;C</p><p>密钥 key———-&gt;K</p><p>加密 enctypt——&gt;E</p><p>解密 dectypt—–&gt;D</p></blockquote><p>传统密码体制所采用的加密密钥和解密密钥相同，成为<strong>对称密钥密码体制</strong></p><p>最典型的就是美国数据加密标准DES。1976年，在由Diffe和Hellman提出的密码新体制中，加密密钥和解密密钥不同，也不能相互推导，成为公钥或<strong>非对称密钥密码体制</strong>。</p><p>现代密码学普遍依赖于数学</p><p>小结：</p><p>对称密码，可以理解为：锁门时需要用钥匙，开门还需要同样的钥匙。公钥密码，可以理解为：锁门时不需要密钥，锁就在门上挂则呢，按一下就锁上了；开门时需要钥匙。</p><h3 id="密码体制的安全性"><a href="#密码体制的安全性" class="headerlink" title="密码体制的安全性"></a>密码体制的安全性</h3><h3 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h3><p>密码分析是密码分析者在不知道密钥的情况下，从密文恢复出明文</p><h5 id="分析密码算法的方法"><a href="#分析密码算法的方法" class="headerlink" title="分析密码算法的方法"></a>分析密码算法的方法</h5><blockquote><p>（1）穷举法：试图试遍所有的明文或密钥来进行破译</p><p>（2）统计分析学：通过分析密文、明文和密钥的统计规律来破译密码技术</p><p>（3）密码体制分析法</p></blockquote><h5 id="对密码体制进行攻击"><a href="#对密码体制进行攻击" class="headerlink" title="对密码体制进行攻击"></a>对密码体制进行攻击</h5><p>（1）唯密文攻击：密码分析者仅知道两样东西：带破译的一些密文和加密算法，并试图恢复尽可能多的明文，并进一步推导出加密信息的密钥。</p><blockquote><p><strong>只知道 一堆密文 C<sub>1</sub>,C<sub>2</sub>,C<sub>3</sub>…….C<sub>t</sub>以及加密算法E</strong></p></blockquote><p>（2）已知明文攻击不仅知道一些带破译的密文和密文对应的加密，还知道与该密文对应的明文，根据明文—密文对试图推导出加密密钥</p><blockquote><p><strong>知道一堆明密文对(m<sub>1</sub>,c<sub>1</sub>),(m<sub>2</sub>,c<sub>2</sub>),以及加密算法E</strong></p></blockquote><p>（3）选择明文攻击可以任意选择一些明文，密码分析者用加密算法，并得到相应的密文，然后试图推导出加密密钥</p><blockquote><p><strong>知道加密算法E</strong></p><p><strong>挑选一些特殊的更有价值的明文，如m<sub>i1</sub>,m<sub>i2</sub>,…….,m<sub>it</sub></strong></p><p><strong>利用加密算法E对选择的明文进行加密，产生密文C<sub>i1</sub>,C<sub>i2</sub>,……..,C<sub>it</sub>这样就得到一些明密文对：</strong></p><p>（m<sub>i1</sub>,c<sub>i1</sub>),(m<sub>i2</sub>,c<sub>i2</sub>),………,(m<sub>it</sub>,c<sub>it</sub>)</p></blockquote><p>（4）选择密文攻击可以选择不同的密文，以及相应的被破解的明文，并试图推导出加密密钥</p><p>可类比 选择明文攻击 </p><p>（5）选择文本攻击：是选择明文攻击和选择密文攻击的结合</p><p>唯密文攻击是最困难的，因为分析者可利用的信息最少，一个密码体制是安全的，通常是指前三种攻击下是安全的</p><h3 id="1-4-2-密码体制的安全性及安全条件"><a href="#1-4-2-密码体制的安全性及安全条件" class="headerlink" title="1.4.2 密码体制的安全性及安全条件"></a>1.4.2 密码体制的安全性及安全条件</h3><h4 id="1-密码算法的安全性"><a href="#1-密码算法的安全性" class="headerlink" title="1.密码算法的安全性"></a>1.密码算法的安全性</h4><p>现代密码学最重要的原则是“一切秘密寓于密钥之中”，即这些算法的安全性都是基于密钥的安全性，算法是可以公开的，也可以被分析，即使攻击者知道算法也不对算法的安全性构成危害。</p><p>算法公开具有这样一些优点，可以防止算法设计者在算法中隐藏后门；是评估算法安全性的唯一最佳的方式</p><h4 id="2-评价密码体制安全性的方法和条件"><a href="#2-评价密码体制安全性的方法和条件" class="headerlink" title="2.评价密码体制安全性的方法和条件"></a>2.评价密码体制安全性的方法和条件</h4><p>（1）评价密码体制安全性的方法</p><p>​        1)无条件安全：即使破译者提供了无穷的资源，依然无法破译，除一次一密密码算法外，无条件安全算法是不存在的。</p><p>​        2）可证明安全性：将密码算法的安全性归结为某个经过深入研究的数学难题</p><p>​        3）计算机安全性，利用已有的最好的破译方法破译该密码算法所需要的努力超出了破译者的破译能力。</p><p>（2）破译的原则</p><p>​        1）破译密码算法的成本是否超过了被加密信息本身的价值。</p><p>​        2）破译密码的时间是否超过被加密信息有用的生命周期</p><p>​        如果满足上述两个准则之一，则可以认为该密码算法在实际上是安全的</p><h1 id="古典密码体制"><a href="#古典密码体制" class="headerlink" title="古典密码体制"></a>古典密码体制</h1><h3 id="古典密码概述"><a href="#古典密码概述" class="headerlink" title="古典密码概述"></a>古典密码概述</h3><p>古典密码知识对字母进行变换，而现代密码算法是对比特流进行变换。古典密码技术比较简单，是采用手工或机械操作来对明文进行加密和解密的，古典密码技术根据其基本原理大体上可以分为三类：传统隐写术、替换密码技术和换位密码技术。</p><h3 id="传统隐写术"><a href="#传统隐写术" class="headerlink" title="传统隐写术"></a>传统隐写术</h3><p>隐写术将秘密信息隐写于非秘密或者不太秘密的信息中的方法，是信息隐藏的技术之一，如：显隐墨水，藏头诗。</p><p>隐写术也可以用作数字水印。</p><h3 id="替换密码技术"><a href="#替换密码技术" class="headerlink" title="替换密码技术"></a>替换密码技术</h3><h4 id="单字符单表替换密码技术"><a href="#单字符单表替换密码技术" class="headerlink" title="单字符单表替换密码技术"></a>单字符单表替换密码技术</h4><p>单字符单表替换密码技术是对明文中的所有字符都使用一个固定的映射</p><p>（密钥确定之后，同样的明文字符，每次出现时都被加密成同样的密文字符）</p><p>典型的单字符单表替换密码技术有乘法密码技术、加法密码技术、仿射密码技术</p><h5 id="乘法密码技术"><a href="#乘法密码技术" class="headerlink" title="乘法密码技术"></a>乘法密码技术</h5><p>加密变换： E<sub>k</sub>(a<sub>i</sub>)=a<sub>j</sub> , j=i*k(mod n ), gcd(k,n)=1</p><p>解密变换：D<sub>k</sub>(a<sub>j</sub>)=a<sub>i</sub> , i=jk<sup>-1</sup>(mod n)                              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">k是密钥</span><br><span class="line">j=i*k(mod n)    -----&gt;j等于i和k的乘积除u的余数</span><br><span class="line">(k,n)=1 &lt;====&gt; 存在 a,b∈Z ,ak+bn=1 &lt;===&gt; k^-1(mod n)存在，就是a</span><br></pre></td></tr></table></figure><p>例 英文字母n=26，选取密钥k=9，则明文字母到密文字母的替换表</p><p>此时的字母表</p><p><img src="https://img-blog.csdnimg.cn/ff187e192b944eebbb8c242cc92b5703.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>解题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 字符串转单字符列表，并返回数字序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoc</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    ch_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">        ch_list.append(i)</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">ord</span>(i)-<span class="number">65</span> <span class="keyword">for</span> i <span class="keyword">in</span> ch_list]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Int to Chr</span></span><br><span class="line"><span class="comment"># 将数字序列还原成大写字母序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">itoc</span>(<span class="params">list_int</span>):</span></span><br><span class="line">    A = [<span class="built_in">chr</span>(i+<span class="number">65</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list_int]</span><br><span class="line">    ch = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        ch += i</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密文序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encrypt</span>(<span class="params">Message,k,n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;使用乘法密码算法进行加密（k=&#123;&#125;, n=&#123;&#125;）&#x27;</span>.<span class="built_in">format</span>(k,n))</span><br><span class="line">    <span class="keyword">return</span> itoc([i*k%n <span class="keyword">for</span> i <span class="keyword">in</span> stoc(Message)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算明文序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span>(<span class="params">Ciphertext,k,n</span>):</span></span><br><span class="line">    <span class="comment"># 解密方式1：通过构建密码表进行查表解密</span></span><br><span class="line">    <span class="comment"># 解密方式2：通过加密逆运算计算明文</span></span><br><span class="line">    DecryptionType = <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(DecryptionType == <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;构建密码表：&#x27;</span>)</span><br><span class="line">        A = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n)]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;明文字母表：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(itoc(A)))</span><br><span class="line">        B = Encrypt(itoc(A),k,n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;密文字母表：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(B))</span><br><span class="line">        CiphertextTables = <span class="built_in">dict</span>(<span class="built_in">zip</span>(B,A))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;构建密码表进行查表解密&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> itoc([CiphertextTables[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ciphertext])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> k1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">            <span class="keyword">if</span>(k1 * k % n == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;通过加密逆运算进行解密（k的逆元为:&#123;&#125;）&#x27;</span>.<span class="built_in">format</span>(k1))</span><br><span class="line">        <span class="keyword">return</span> itoc([c*k1%n <span class="keyword">for</span> c <span class="keyword">in</span> stoc(Ciphertext)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 当前仅支持大写字母串</span></span><br><span class="line">    A = (<span class="string">&#x27;AMAN&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入的明文字符串为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(A))</span><br><span class="line">    B = Encrypt(A,<span class="number">9</span>,<span class="number">26</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加密后的密文：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(B))</span><br><span class="line">    C = Decrypt(B,<span class="number">9</span>,<span class="number">26</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;解密后的明文：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(C))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="单字符多表替换密码技术"><a href="#单字符多表替换密码技术" class="headerlink" title="单字符多表替换密码技术"></a>单字符多表替换密码技术</h4><p>单字符多表替换密码技术在安全性方面比单字符表替换密码技术高</p><p>单字符多表替换密码技术有很多，典型的有Vigenere密码技术、Vernam密码技术、Hill密码技术、Playfair密码技术等。</p><h5 id="vernam（弗纳姆）密码技术"><a href="#vernam（弗纳姆）密码技术" class="headerlink" title="vernam（弗纳姆）密码技术"></a>vernam（弗纳姆）密码技术</h5><p>设明文m=m<sub>1</sub> , m<sub>2</sub> , ….,密钥k=k<sub>1</sub> ,k<sub>2</sub>  , ……., 其中m<sub>i</sub> , k<sub>i</sub> ∈ GF(2) , i&gt;=1 ,则密文 c = c<sub>1</sub>c<sub>2</sub> …..,</p><p>其中c<sub>i</sub>=m<sub>i</sub>⊕k<sub>i</sub>   .    这里⊕为模2加法</p><p>​            GF(2)={0,1}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模2加法</span><br><span class="line">规则是两个序列按位相加模二，即两个序列中对应位，相加，不进位，相同为0，不同为1。</span><br><span class="line">1+1=0+0=0</span><br><span class="line">1+0=0+1=1</span><br><span class="line">与计算机位运算符的 异或算法一致 1^1=0 ,0^0=0,1^0=1,0^1=1</span><br></pre></td></tr></table></figure><p>【例2-5】设明文m=01100001，密钥k=01001110，使用Vernam密码加密求密文解:加密得密文:c=m)k=01100001⊕ 01001110=00101111，即密文为00101111.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data=<span class="number">0b01100001</span></span><br><span class="line">key=<span class="number">0b01001110</span></span><br><span class="line">e=data^key</span><br></pre></td></tr></table></figure><h3 id="换位密码技术"><a href="#换位密码技术" class="headerlink" title="换位密码技术"></a>换位密码技术</h3><p>换位面吗技术本质上就是一种置换密码技术，是重新排列消息中的字母。</p><h4 id="列换位"><a href="#列换位" class="headerlink" title="列换位"></a>列换位</h4><p>列换位的原理：首先将明文按照密钥个数排列，然后再按照密钥在字母表中的顺序变换列的顺序，最后按照列的顺序写出的就是英文</p><h3 id="古典密码的安全性分析"><a href="#古典密码的安全性分析" class="headerlink" title="古典密码的安全性分析"></a>古典密码的安全性分析</h3><p>对于代替密码来说，密文中还保留了明文的统计特征，因此可以使用统计方法进行攻击</p><p>英文字母中出现的频率也是有统计规律的</p><p>单字母E出现频率最高</p><p>双字母TH出现频率最高</p><h4 id="移位密码安全性分析-（加法密码技术）"><a href="#移位密码安全性分析-（加法密码技术）" class="headerlink" title="移位密码安全性分析  （加法密码技术）"></a>移位密码安全性分析  （加法密码技术）</h4><p>以为密码是极不安全的（mod 26），因为它可被穷举密钥搜索分析，仅有26种可能的密钥</p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p><img src="https://img-blog.csdnimg.cn/20210415155325599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA5Nzc2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇（概述及古典密码学）&quot;&gt;&lt;a href=&quot;#密码学之理论篇（概述及古典密码学）&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇（概述及古典密码学）&quot;&gt;&lt;/a&gt;密码学之理论篇（概述及古典密码学）&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="密码学" scheme="http://websec.space/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://websec.space/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="http://websec.space/2021/11/26/TcpIP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://websec.space/2021/11/26/TcpIP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-11-25T16:00:00.000Z</published>
    <updated>2021-12-14T07:56:46.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><h2 id="TCP-IP-协议的具体含义"><a href="#TCP-IP-协议的具体含义" class="headerlink" title="TCP/IP 协议的具体含义"></a>TCP/IP 协议的具体含义</h2><p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的<strong>协议群的统称</strong>。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。<br>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><strong>计算机网络体系结构分层</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/690219fae5b0587fa26e2dee545e6200~tplv-t2oaga2asx-watermark.awebp" alt="计算机网络体系结构分层" style="zoom:150%;" /><p>TCP/IP协议族按照层次<strong>由上到下，层层包装</strong>。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/32269df6363944b0df8fe99204e92c91~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><blockquote><p>上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/7f693d4add34644a6268e0e11bec2cb7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p><p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p><p> A类IP地址: 0.0.0.0<del>127.0.0.0<br>B类IP地址:128.0.0.1</del>191.255.0.0<br>C类IP地址:192.168.0.0~239.255.255.0</p><h3 id="IP协议头"><a href="#IP协议头" class="headerlink" title="IP协议头"></a>IP协议头</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/dbb082d9806de01f5653423917a1f71b~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p><h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><blockquote><p>他们的目标都是在程序之间传输数据。<br>数据可以是文本，文件，可以是视频，也可以是图片。对于TCP协议和UDP协议来说，都是一对二进制数，并没有多大的区别。</p></blockquote><p><strong>TCP 是面向连接的、可靠的流协议。</strong>流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p><p><strong>UDP 是不具有可靠性的数据报协议。</strong>细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p><p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。<strong>TCP 和 UDP 应该根据应用的目的按需使用。</strong></p><h2 id="TCPUDP之间的区别是什么？"><a href="#TCPUDP之间的区别是什么？" class="headerlink" title="TCPUDP之间的区别是什么？"></a>TCPUDP之间的区别是什么？</h2><p>最大的区别是一个基于连接，一个基于非连接。<br>我们来举一个简单的例子，如果把人与人的通信比喻为进程与进程的通信，我们基本有两种方式。第一种方式是写信，第二种方式是打电话。</p><p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto3974789fb5ee497a87f35500480b4571" alt="image-20211105125454004"></p><p><strong>TCP是如何保证以上过程的？</strong></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP报文数据包"><a href="#TCP报文数据包" class="headerlink" title="TCP报文数据包"></a>TCP报文数据包</h3><p><img src="https://pic1.zhimg.com/80/v2-63955c8436410907d6fe4697d5bf0b0c_720w.jpg" alt="img"></p><p><img src="https://s1.ax1x.com/2018/03/02/9rzlJf.png" alt="img"></p><h3 id="TCP-首部各字段的意义和作用"><a href="#TCP-首部各字段的意义和作用" class="headerlink" title="TCP 首部各字段的意义和作用"></a>TCP 首部各字段的意义和作用</h3><blockquote><p>TCP首部最小为20字节，这20字节分为5行，每行4个字节也就是32个位。</p><h5 id="源端口和目的端口-Port"><a href="#源端口和目的端口-Port" class="headerlink" title="源端口和目的端口 Port"></a>源端口和目的端口 Port</h5><ul><li>源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。</li><li>目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 分别占用16位，也就是端口号最大是2^16，所以端口号的范围是0~65536</li></ul><p>端口号的分配：</p><ul><li>知名端口号一般位于：1 — 255 之间</li><li>256 — 1023的端口号，通常是由Unix系统占用（系统占用）</li><li>1024 —5000 是大多数TCP、IP实现的临时分配</li><li>大于5000的一般是给其他服务预留的（Internet上并不常用的服务）</li></ul><h5 id="序号-Sequence-Number"><a href="#序号-Sequence-Number" class="headerlink" title="序号 Sequence Number"></a>序号 Sequence Number</h5><p>TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。</p><h5 id="确认号-Acknowledgemt-Number"><a href="#确认号-Acknowledgemt-Number" class="headerlink" title="确认号 Acknowledgemt Number"></a>确认号 Acknowledgemt Number</h5><p>占 4 个字节，表示期望收到对方下一个报文段的序号值。 TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。</p><p>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。 例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个确认报文，其中的确认号 = 25600.</p><h5 id="数据偏移-Offset"><a href="#数据偏移-Offset" class="headerlink" title="数据偏移 Offset"></a>数据偏移 Offset</h5><p>占 0.5 个字节 (4 位)。 这个字段实际上是指出了 TCP 报文段的首部长度 ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）</p><p>一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。</p><h5 id="保留-Reserved"><a href="#保留-Reserved" class="headerlink" title="保留 Reserved"></a>保留 Reserved</h5><p>占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。</p><h5 id="标志位-TCP-Flags"><a href="#标志位-TCP-Flags" class="headerlink" title="标志位 TCP Flags"></a>标志位 TCP Flags</h5><p>标志位，一共有 6 个，分别占 1 位，共 6 位 。 每一位的值只有 0 和 1，分别表达不同意思。</p><ul><li>ACK：确认序号有效</li><li>RST：重置连接</li><li>SYN：发起了一个新连接</li><li>FIN：释放一个连接</li></ul><h5 id="确认-ACK-Acknowlegemt"><a href="#确认-ACK-Acknowlegemt" class="headerlink" title="确认 ACK (Acknowlegemt)"></a>确认 ACK (Acknowlegemt)</h5><p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。</p><p>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。</p><h5 id="推送-PSH-Push"><a href="#推送-PSH-Push" class="headerlink" title="推送 PSH (Push)"></a>推送 PSH (Push)</h5><p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。</p><h5 id="复位-RST-Reset"><a href="#复位-RST-Reset" class="headerlink" title="复位 RST (Reset)"></a>复位 RST (Reset)</h5><p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。</p><h5 id="同步-SYN-SYNchronization"><a href="#同步-SYN-SYNchronization" class="headerlink" title="同步 SYN (SYNchronization)"></a>同步 SYN (SYNchronization)</h5><p>当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。</p><p>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。</p><h5 id="终止-FIN-Finis"><a href="#终止-FIN-Finis" class="headerlink" title="终止 FIN (Finis)"></a>终止 FIN (Finis)</h5><p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。</p><p>一般称携带 FIN 的报文段为「结束报文段」。</p><p>在 TCP 四次挥手释放连接的时候，就会用到该标志。</p><h5 id="窗口大小-Window-Size"><a href="#窗口大小-Window-Size" class="headerlink" title="窗口大小 Window Size"></a>窗口大小 Window Size</h5><p>占 2 字节。</p><p>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。</p><p>例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。</p><h5 id="校验和-TCP-Checksum"><a href="#校验和-TCP-Checksum" class="headerlink" title="校验和 TCP Checksum"></a>校验和 TCP Checksum</h5><p>占 2 个字节。 由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。</p><p>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</p><h5 id="紧急指针-Urgent-Pointer"><a href="#紧急指针-Urgent-Pointer" class="headerlink" title="紧急指针 Urgent Pointer"></a>紧急指针 Urgent Pointer</h5><p>占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</p><p>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p></blockquote><p><strong>有三个关键的步骤，分别为三次握手、传输确认、四次挥手。</strong></p><h3 id="TCP的三次握手，四次挥手"><a href="#TCP的三次握手，四次挥手" class="headerlink" title="TCP的三次握手，四次挥手"></a>TCP的三次握手，四次挥手</h3><h4 id="需要了解的信息"><a href="#需要了解的信息" class="headerlink" title="需要了解的信息"></a>需要了解的信息</h4><ul><li>ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li><li>SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</li><li>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li></ul><p>TCP（Transmission Control Protocol，传输控制协议）是 面向连接的协议，也就是说在<strong>收发数据之前，必须先和对方建立连接</strong></p><blockquote><p>一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的 描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数 据。</p></blockquote><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。<strong>三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</strong></p><img src="https://pic2.zhimg.com/80/v2-1587e91f14923eae0fa7d846cb10df99_720w.jpg" alt="img" style="zoom:200%;" /><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入<strong>SYN_SEND</strong>状态，等待服务器的确认；    </p><p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入<strong>SYN_RECV</strong>状态；  </p><p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入<strong>ESTABLISHED</strong>状态，完成TCP三次握手。</p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto098b95dd1e884eefb56a114cbb1a529f"  /><p><strong>为什么要三次握手而不是两次握手？服务端回复完SYN+ACK之后就建立连接</strong></p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>假设采用两次握手建立连接客户端，向服务端发送了一个SYN来请求建立连接。<br>因为某些未知的原因并没有到达服务器在中间某个网络节点产生了滞留。<br>为了建立连接客户端，会重发SYN，这次的数据包正常送达，服务端回复SYN+ACK之后建立起来连接。<br>但是第一包数据阻塞的网络节点突然恢复，第一包省包又送达到服务端。这时服务端会误认为是客户端又发起了一个新的连接，从而在两次握手之后进入等待数据状态。<br><strong>服务端认为是两个连接，而客户端认为是一个连接，造成了状态不一致。</strong><br>如果在三次握手的情况下，服务端收不到最后的ACK自然不会认为连接建立成功。<br>所以三次握手本质上来说就是为了解决网络信道不可靠的问题。为了能够在不可靠的信道上建立起可靠的连接。<br>经过三次握手之后，客户端和服务端都进入了数据传输状态。</p><blockquote><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nnA &#x27;port 9999&#x27;</span><br><span class="line">nc -4vl 9999</span><br><span class="line">telnet swordk.cn 9999</span><br></pre></td></tr></table></figure><h4 id="传输确认"><a href="#传输确认" class="headerlink" title="传输确认"></a>传输确认</h4><p>TCP协议需要在不可靠的信道上保证可靠的连接。现在这有几个问题需要面对。</p><p>一包数据有可能会被拆成多包发送如何处理<strong>丢包</strong>问题？<br>这些数据包到达的先后顺序不同，如何处理<strong>乱序</strong>问题？</p><p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto683ac4ddaa994e71a7e04583ee9b9aa5" alt="image-20211105132602749"></p><p>针对这些要求，TCP协议为每一个连接建立了一个发送缓冲区。从建立连接后的第一个字节的序列号为零，后面每个字节的序列号就会增加一。<br>发送数据时，从发送缓冲区取一部分数据组成发送报文，在其TCP协议头中会附带序列号和长度。接收端在收到数据后需要回复确认报文。<br>确认报文中的ACK等于接收序列号加长度，也就是下一包数据需要发送的基础序列号。<br>这样一问一答的发送方式，能够使发送端确认发送的数据已经被对方收到。<br>发送端也可以一次发送连续的多包数据，接收端只需要回复一次ACK就可以了。<br>这样发送端可以把待发送的数据分割成一系列的碎片，发送到对端。对端根据序列号和长度在接收后重构出来完整的数据。<br>假设其中丢失了某些数据方在接收端可以要求发送端重传。比如丢失了100-199，这一百个字节接收端下发送端发送ACK=100的报文。<br>发送端收到后，重传这一包数据，接收端进行补齐。<br>以上过程不区分客户端和服务端，<strong>TCP连接是全双功能，对于两端来说均采用上述机制。</strong></p><hr><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><img src="https://pic2.zhimg.com/80/v2-6e5f05603526c1d259b300f20b8857a5_720w.jpg" alt="img" style="zoom:200%;" /><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><p><strong>第一次挥手：</strong> 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p><strong>第二次挥手：</strong> 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p><strong>第三次挥手：</strong> 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p><strong>第四次挥手：</strong> 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p><strong>为什么要四次挥手</strong>？</p><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p><strong>为什么客户端需要等待超时时间？</strong></p><p>这是为了保证对方已收到ACK。因为假设客户端发送完最后一包ACK后就释放了连接。一旦ACK在网络中丢失。服务端将一直停留在最后确认状态。</p><p>如果客户端发送最后一个ACK后等待一段时间，这时服务端因为没有收到ACK，会重发FIN。<br>客户端会响应这个分包重发ACK，用刷新超时时间这个机制跟三次握手一样，也是为了<strong>保证在不可靠的网络链路中进行可靠的连接，断开确认。</strong></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP协议是基于非连接的发送数据，就是简单的把数据包封装一下，然后从网卡发出去就可以了。数据包之间并没有状态上的联系。正因为UDP这种简单的处理方式，导致它的性能损耗非常少。对于CPU内存资源的占用也远小于TCP。但是对于网络传输过程中产生的丢包，UDP协议并不能保证。</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-4bcddf13416e9f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="什么时候应该使用TCP？"><a href="#什么时候应该使用TCP？" class="headerlink" title="什么时候应该使用TCP？"></a>什么时候应该使用TCP？</h3><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 </p><h3 id="什么时候应该使用UDP？"><a href="#什么时候应该使用UDP？" class="headerlink" title="什么时候应该使用UDP？"></a>什么时候应该使用UDP？</h3><p>UDP的优点是速度快，但是可能产生丢包。所以适用于对实时性要求较高，但是对少量丢包并没有太大要求的场景，比如域名查询与云通话、视频直播等。</p><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><table><thead><tr><th align="left">端口</th><th align="left">服务</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">21</td><td align="left">FTP</td><td align="left">FTP 服务器所开放的端口，用于上传、下载</td></tr><tr><td align="left">22</td><td align="left">SSH</td><td align="left">22 端口就是 ssh 端口，用于通过命令行模式远程连接 Linux 系统服务器</td></tr><tr><td align="left">25</td><td align="left">SMTP</td><td align="left">SMTP 服务器所开放的端口，用于发送邮件</td></tr><tr><td align="left">80</td><td align="left">HTTP</td><td align="left">用于网站服务例如 IIS、Apache、Nginx 等提供对外访问</td></tr><tr><td align="left">110</td><td align="left">POP3</td><td align="left">110 端口是为 POP3（邮件协议 3）服务开放的</td></tr><tr><td align="left">137/138/139</td><td align="left">NETBIOS</td><td align="left">其中 137、138 是 UDP 端口，当通过网上邻居传输文件时用这个端口。而 139 端口：通过这个端口进入的连接试图获得 NetBIOS/SMB 服务。这个协议被用于 windows 文件和打印机共享和 SAMBA</td></tr><tr><td align="left">143</td><td align="left">IMAP</td><td align="left">143 端口主要是用于“Internet Message AccessProtocol”v2（Internet 消息访问协议，简称 IMAP），和 POP3 一样，是用于电子邮件的接收的协议</td></tr><tr><td align="left">443</td><td align="left">HTTPS</td><td align="left">网页浏览端口，能提供加密和通过安全端口传输的另一种 HTTP</td></tr><tr><td align="left">1433</td><td align="left">SQL Server</td><td align="left">1433 端口，是 SQL Server 默认的端口，SQL Server 服务使用两个端口：TCP-1433、UDP-1434。其中 1433 用于供 SQL Server 对外提供服务，1434 用于向请求者返回 SQL Server 使用了哪个 TCP/IP 端口</td></tr><tr><td align="left">3306</td><td align="left">MySQL</td><td align="left">3306 端口，是 MySQL 数据库的默认端口，用于 MySQL 对外提供服务</td></tr><tr><td align="left">3389</td><td align="left">Windows Server Remote Desktop Services</td><td align="left">3389 端口是 Windows 远程桌面的服务端口，可以通过这个端口，用 “远程桌面” 等连接工具来连接到远程的服务器</td></tr><tr><td align="left">8080</td><td align="left">代理端口</td><td align="left">8080 端口同 80 端口，是被用于 WWW 代理服务的，可以实现网页浏览，经常在访问某个网站或使用代理服务器的时候，会加上 “:8080” 端口号。另外 Apache Tomcat web server 安装后，默认的服务端口就是 8080</td></tr></tbody></table><p>in the end</p><p>转自：brey.cn</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-IP协议&quot;&gt;&lt;a href=&quot;#TCP-IP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议&quot;&gt;&lt;/a&gt;TCP/IP协议&lt;/h1&gt;&lt;h2 id=&quot;TCP-IP-协议的具体含义&quot;&gt;&lt;a href=&quot;#TCP-IP-协议的具体含义&quot;</summary>
      
    
    
    
    <category term="基础" scheme="http://websec.space/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="基础" scheme="http://websec.space/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://websec.space/2021/11/25/hello-world/"/>
    <id>http://websec.space/2021/11/25/hello-world/</id>
    <published>2021-11-24T17:01:56.458Z</published>
    <updated>2021-12-13T13:32:28.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在博客最开头的小论文"><a href="#写在博客最开头的小论文" class="headerlink" title="写在博客最开头的小论文"></a>写在博客最开头的小论文</h1><p>之前想过要不要搭一个博客，但随着学习的深入，越发觉得自己的可能在某些领域没有摸到门道</p><p>如果成了某个领域的佼佼者，再来写这个博客，但是在安全组的培训算是给了一个很好的写文章的机会，</p><p>遂将其斗胆分享出来，里面的内容或有借鉴（cv）或有自己心得，若有侵权请联系我，会及时删掉。</p><p>​                                                                                                                                                QQ:970856057</p><p>​                                                                                                                                                                 鑫缘</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在博客最开头的小论文&quot;&gt;&lt;a href=&quot;#写在博客最开头的小论文&quot; class=&quot;headerlink&quot; title=&quot;写在博客最开头的小论文&quot;&gt;&lt;/a&gt;写在博客最开头的小论文&lt;/h1&gt;&lt;p&gt;之前想过要不要搭一个博客，但随着学习的深入，越发觉得自己的可能在某些</summary>
      
    
    
    
    <category term="闲聊" scheme="http://websec.space/categories/%E9%97%B2%E8%81%8A/"/>
    
    
    <category term="闲聊" scheme="http://websec.space/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
</feed>
