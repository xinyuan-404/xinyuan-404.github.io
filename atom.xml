<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinyuan&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/cb5dd586f32c8841e8838c89301eb7fa</icon>
  <subtitle>鑫缘的blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-05T02:56:23.744Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>鑫缘</name>
    <email>xy_404@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>密码学之实践篇</title>
    <link href="http://example.com/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2021-12-05T02:56:23.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之实践篇"><a href="#密码学之实践篇" class="headerlink" title="密码学之实践篇"></a>密码学之实践篇</h1><h3 id="N1CTF-python-（Feistel网络）"><a href="#N1CTF-python-（Feistel网络）" class="headerlink" title="N1CTF python   （Feistel网络）"></a>N1CTF python   （Feistel网络）</h3><p>题的代码如下</p><p>N1SE.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round_add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    f = <span class="keyword">lambda</span> x, y: x + y - <span class="number">2</span> * (x &amp; y)</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        res += <span class="built_in">chr</span>(f(<span class="built_in">ord</span>(a[i]), <span class="built_in">ord</span>(b[i])))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutate</span>(<span class="params">table, block</span>):</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: block[x], table))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_to_bits</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line">    l = <span class="built_in">len</span>(data) * <span class="number">8</span></span><br><span class="line">    result = [<span class="number">0</span>] * l</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">            result[(pos&lt;&lt;<span class="number">3</span>)+i] = (ch&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">s_box = [<span class="number">54</span>, <span class="number">132</span>, <span class="number">138</span>, <span class="number">83</span>, <span class="number">16</span>, <span class="number">73</span>, <span class="number">187</span>, <span class="number">84</span>, <span class="number">146</span>, <span class="number">30</span>, <span class="number">95</span>, <span class="number">21</span>, <span class="number">148</span>, <span class="number">63</span>, <span class="number">65</span>, <span class="number">189</span>, <span class="number">188</span>, <span class="number">151</span>, <span class="number">72</span>, <span class="number">161</span>, <span class="number">116</span>, <span class="number">63</span>, <span class="number">161</span>, <span class="number">91</span>, <span class="number">37</span>, <span class="number">24</span>, <span class="number">126</span>, <span class="number">107</span>, <span class="number">87</span>, <span class="number">30</span>, <span class="number">117</span>, <span class="number">185</span>, <span class="number">98</span>, <span class="number">90</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">140</span>, <span class="number">70</span>, <span class="number">86</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">150</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">144</span>, <span class="number">153</span>, <span class="number">36</span>, <span class="number">90</span>, <span class="number">149</span>, <span class="number">54</span>, <span class="number">156</span>, <span class="number">8</span>, <span class="number">59</span>, <span class="number">40</span>, <span class="number">110</span>, <span class="number">56</span>,<span class="number">1</span>, <span class="number">84</span>, <span class="number">103</span>, <span class="number">22</span>, <span class="number">65</span>, <span class="number">17</span>, <span class="number">190</span>, <span class="number">41</span>, <span class="number">99</span>, <span class="number">151</span>, <span class="number">119</span>, <span class="number">124</span>, <span class="number">68</span>, <span class="number">17</span>, <span class="number">166</span>, <span class="number">125</span>, <span class="number">95</span>, <span class="number">65</span>, <span class="number">105</span>, <span class="number">133</span>, <span class="number">49</span>, <span class="number">19</span>, <span class="number">138</span>, <span class="number">29</span>, <span class="number">110</span>, <span class="number">7</span>, <span class="number">81</span>, <span class="number">134</span>, <span class="number">70</span>, <span class="number">87</span>, <span class="number">180</span>, <span class="number">78</span>, <span class="number">175</span>, <span class="number">108</span>, <span class="number">26</span>, <span class="number">121</span>, <span class="number">74</span>, <span class="number">29</span>, <span class="number">68</span>, <span class="number">162</span>, <span class="number">142</span>, <span class="number">177</span>, <span class="number">143</span>, <span class="number">86</span>, <span class="number">129</span>, <span class="number">101</span>, <span class="number">117</span>, <span class="number">41</span>, <span class="number">57</span>, <span class="number">34</span>, <span class="number">177</span>, <span class="number">103</span>, <span class="number">61</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">74</span>, <span class="number">69</span>, <span class="number">147</span>, <span class="number">90</span>, <span class="number">49</span>, <span class="number">135</span>, <span class="number">124</span>, <span class="number">106</span>, <span class="number">19</span>, <span class="number">89</span>, <span class="number">38</span>, <span class="number">21</span>, <span class="number">41</span>, <span class="number">17</span>, <span class="number">155</span>, <span class="number">83</span>, <span class="number">38</span>, <span class="number">159</span>, <span class="number">179</span>, <span class="number">19</span>, <span class="number">157</span>, <span class="number">68</span>, <span class="number">105</span>, <span class="number">151</span>, <span class="number">166</span>, <span class="number">171</span>, <span class="number">122</span>, <span class="number">179</span>, <span class="number">114</span>, <span class="number">52</span>, <span class="number">183</span>, <span class="number">89</span>, <span class="number">107</span>, <span class="number">113</span>, <span class="number">65</span>, <span class="number">161</span>, <span class="number">141</span>, <span class="number">18</span>, <span class="number">121</span>, <span class="number">95</span>, <span class="number">4</span>, <span class="number">95</span>, <span class="number">101</span>, <span class="number">81</span>, <span class="number">156</span>, <span class="number">17</span>, <span class="number">190</span>, <span class="number">38</span>, <span class="number">84</span>, <span class="number">9</span>, <span class="number">171</span>, <span class="number">180</span>, <span class="number">59</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">34</span>, <span class="number">89</span>, <span class="number">75</span>, <span class="number">164</span>, <span class="number">190</span>, <span class="number">140</span>, <span class="number">6</span>, <span class="number">41</span>, <span class="number">188</span>, <span class="number">77</span>, <span class="number">165</span>, <span class="number">105</span>, <span class="number">5</span>, <span class="number">107</span>, <span class="number">31</span>, <span class="number">183</span>, <span class="number">107</span>, <span class="number">141</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">125</span>, <span class="number">50</span>, <span class="number">2</span>, <span class="number">153</span>, <span class="number">156</span>, <span class="number">162</span>, <span class="number">186</span>, <span class="number">76</span>, <span class="number">158</span>, <span class="number">153</span>, <span class="number">117</span>, <span class="number">9</span>, <span class="number">77</span>, <span class="number">156</span>, <span class="number">11</span>, <span class="number">145</span>, <span class="number">12</span>, <span class="number">169</span>, <span class="number">52</span>, <span class="number">57</span>, <span class="number">161</span>, <span class="number">7</span>, <span class="number">158</span>, <span class="number">110</span>, <span class="number">191</span>, <span class="number">43</span>, <span class="number">82</span>, <span class="number">186</span>, <span class="number">49</span>, <span class="number">102</span>, <span class="number">166</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">5</span>, <span class="number">189</span>, <span class="number">27</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">o</span>):</span></span><br><span class="line">    k = permutate(s_box,o)</span><br><span class="line">    b = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(k), <span class="number">7</span>):</span><br><span class="line">        b.append(k[i:i+<span class="number">7</span>] + [<span class="number">1</span>])</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> b[i]:</span><br><span class="line">x += (j&lt;&lt;pos)</span><br><span class="line">pos += <span class="number">1</span></span><br><span class="line">c.append((<span class="number">0x10001</span>**x) % (<span class="number">0x7f</span>))</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">N1ES</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(key) != <span class="number">24</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(key, <span class="built_in">bytes</span>) == <span class="literal">False</span> ):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;key must be 24 bytes long&quot;</span>)</span><br><span class="line">        self.key = key</span><br><span class="line">        self.gen_subkey()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_subkey</span>(<span class="params">self</span>):</span></span><br><span class="line">        o = string_to_bits(self.key)</span><br><span class="line">        k = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        o = generate(o)</span><br><span class="line">        k.extend(o)</span><br><span class="line">        o = string_to_bits([<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> o[<span class="number">0</span>:<span class="number">24</span>]])</span><br><span class="line">        self.Kn = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            self.Kn.append(<span class="built_in">map</span>(<span class="built_in">chr</span>, k[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>]))</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">self, plaintext</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(plaintext) % <span class="number">16</span> != <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(plaintext, <span class="built_in">bytes</span>) == <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;plaintext must be a multiple of 16 in length&quot;</span>)</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext) / <span class="number">16</span>):</span><br><span class="line">            block = plaintext[i * <span class="number">16</span>:(i + <span class="number">1</span>) * <span class="number">16</span>]</span><br><span class="line">            L = block[:<span class="number">8</span>]</span><br><span class="line">            R = block[<span class="number">8</span>:]</span><br><span class="line">            <span class="keyword">for</span> round_cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                L, R = R, (round_add(L, self.Kn[round_cnt]))</span><br><span class="line">            L, R = R, L</span><br><span class="line">            res += L + R</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>challenge.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> N1ES <span class="keyword">import</span> N1ES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;wxy191iss00000000000cute&quot;</span></span><br><span class="line">n1es = N1ES(key)</span><br><span class="line">flag = <span class="string">&quot;N1CTF&#123;*****************************************&#125;&quot;</span></span><br><span class="line">cipher = n1es.encrypt(flag)</span><br><span class="line"><span class="built_in">print</span> base64.b64encode(cipher)  <span class="comment"># HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx</span></span><br></pre></td></tr></table></figure><p>python2的代码，但是电脑没有python2的环境  ，期初想就是不下，宁愿py2转py3我都不去下py2 ，后面我发现我错了，python2转为python3之后bug不是我能预料到的，遂乖乖下载了py2，开整。</p><p>开始调试，debug功能告诉我，首先调用这个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_to_bits</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line">    l = <span class="built_in">len</span>(data) * <span class="number">8</span></span><br><span class="line">    result = [<span class="number">0</span>] * l</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">            result[(pos&lt;&lt;<span class="number">3</span>)+i] = (ch&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def encrypt(self, plaintext):</span><br><span class="line">    if (len(plaintext) % 16 != 0 or isinstance(plaintext, bytes) == False):</span><br><span class="line">        raise Exception(&quot;plaintext must be a multiple of 16 in length&quot;)</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    for i in range(len(plaintext) / 16):</span><br><span class="line">        block = plaintext[i * 16:(i + 1) * 16]</span><br><span class="line">        L = block[:8]</span><br><span class="line">        R = block[8:]</span><br><span class="line">        for round_cnt in range(32):</span><br><span class="line">            L, R = R, (round_add(L, self.Kn[round_cnt]))</span><br><span class="line">        L, R = R, L</span><br><span class="line">        res += L + R</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure><p>我们由分组密码可知，这是一个很明显的Feistel结构，Feistel结构的特点就是加密与解密过程大体一致，及将密钥倒过来，就可以成功获取到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在challenge.py添加如下代码：</span><br><span class="line">s1=base64.b64decode(&#x27;HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx&#x27;)</span><br><span class="line">flag = n1es.decrypt(s1)</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">构造解密的函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">self, plaintext</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(plaintext) % <span class="number">16</span> != <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(plaintext, <span class="built_in">bytes</span>) == <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;plaintext must be a multiple of 16 in length&quot;</span>)</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext) / <span class="number">16</span>):</span><br><span class="line">            block = plaintext[i * <span class="number">16</span>:(i + <span class="number">1</span>) * <span class="number">16</span>]</span><br><span class="line">            L = block[:<span class="number">8</span>]</span><br><span class="line">            R = block[<span class="number">8</span>:]</span><br><span class="line">            <span class="keyword">for</span> round_cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                L, R = R, (round_add(L, self.Kn[<span class="number">31</span>-round_cnt]))</span><br><span class="line">            L, R = R, L</span><br><span class="line">            res += L + R</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之实践篇&quot;&gt;&lt;a href=&quot;#密码学之实践篇&quot; class=&quot;headerlink&quot; title=&quot;密码学之实践篇&quot;&gt;&lt;/a&gt;密码学之实践篇&lt;/h1&gt;&lt;h3 id=&quot;N1CTF-python-（Feistel网络）&quot;&gt;&lt;a href=&quot;#N1CTF-pyt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学之理论篇（分组密码体制）</title>
    <link href="http://example.com/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/"/>
    <id>http://example.com/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2021-12-05T02:57:58.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇（分组密码体制）"><a href="#密码学之理论篇（分组密码体制）" class="headerlink" title="密码学之理论篇（分组密码体制）"></a>密码学之理论篇（分组密码体制）</h1><h1 id="四、分组密码体制"><a href="#四、分组密码体制" class="headerlink" title="四、分组密码体制"></a>四、分组密码体制</h1><h3 id="4-1-分组密码学的基本概念"><a href="#4-1-分组密码学的基本概念" class="headerlink" title="4.1 分组密码学的基本概念"></a>4.1 分组密码学的基本概念</h3><p>分组密码：</p><p>1、一个0、1分组一个0、1分组进行加密（不是一个比特一个比特进行加密）；</p><p>2、不同的分组利用同一个密钥进行加密；</p><p>3、还有个分组密码工作模式的问题，这章稍后会学。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">明文分组长度为n bit，密文分组长度m bit，若n&gt;m , 明文分组长度大于密文分组长度，称其为有数据压缩的分组密码;若n&lt;m,明文分组长度小于密文分组长度，称之为有数据扩展的分组密码；若n=m，明文分组等于密文分组长度，则称之为无数据扩展和压缩的分组密码，事实上，通常的分组密码均取n=m</span><br></pre></td></tr></table></figure><h3 id="4-2-分组密码的原理"><a href="#4-2-分组密码的原理" class="headerlink" title="4.2 分组密码的原理"></a>4.2 分组密码的原理</h3><p>香农提出了设计密码系统的两个基本方法——-扩散和混淆。目的是抗击攻击者对密码系统的统计分析。</p><h4 id="1-扩散"><a href="#1-扩散" class="headerlink" title="1.扩散"></a>1.扩散</h4><p>​    扩散的含义是将明文和密钥的统计特性散步到密文中去，是的明文和密钥每一比特在密文中得到充分扩散，是的密文不在显示任何形式的规律。</p><p><strong>扩散使得明文和密钥的每一位都影响密文中多位的值</strong></p><p>（扩散属于线性变换，差不多相当于“洗牌”</p><h4 id="2-混淆"><a href="#2-混淆" class="headerlink" title="2.混淆"></a>2.混淆</h4><p>​    混淆的含义是使密文和对应的明文与密钥之间的统计关系变得尽可能复杂，使得攻击者无法得到密文和明文及密钥之间的统计规律。</p><p>在分组密码中，对数据重复执行某个s盒变换（非线性变换），可获得混淆。</p><p>扩散和混淆是分组密码的最本质的操作，是设计分组密码的基础。</p><h4 id="4-2-1-代替-置换网络（s-p结构）"><a href="#4-2-1-代替-置换网络（s-p结构）" class="headerlink" title="4.2.1 代替-置换网络（s-p结构）"></a>4.2.1 代替-置换网络（s-p结构）</h4><p>大多数分组密码同时使用代替-置换网络以达到混淆和扩散的目标。</p><p>​    代替-置换网络（s-p网络）是由多重非线性代替（S）和比特置换（P）构成，s代替起到混淆的作用，P置换起到扩散的作用。</p><p><img src="https://img-blog.csdnimg.cn/ffc3c8a97341430e9e07b2e20f8cf182.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P置换差不多相当于是 一次“广义的洗牌”：</span><br><span class="line"></span><br><span class="line">有可能 牌的张数 前后保持不变；</span><br><span class="line"></span><br><span class="line">也可能  洗完牌 被抽出去了几张牌，总牌数变少了；</span><br><span class="line"></span><br><span class="line">也可能 把部分牌“复制”了一下，又把它们“粘贴”到</span><br><span class="line"></span><br><span class="line">原来那摞牌中，这样总牌数就增多了。</span><br></pre></td></tr></table></figure><p>相当于s盒对明文分块加密，p进行一次洗牌，然后s盒再去加密，循环。</p><p>从b站找了一个例子，对其进行一波解析。</p><p>对于输入值<img src="https://api.bilibili.com/x/web-frontend/mathjax/tex?formula=x%5Cin%20%5Cleft%5C%7B%200,1%20%5Cright%5C%7D%20%5El" alt="x%5Cin%20%5Cleft%5C%7B%200%2C1%20%5Cright%5C%7D%20%5El">，做如下的事情：</p><ol><li>从key里面抽取一个round key <img src="https://api.bilibili.com/x/web-frontend/mathjax/tex?formula=k%E2%80%99=F(k)" alt="k%E2%80%99%3DF(k)">，F在这里只是一个形式，并不代表一定要用某个函数来获取round key</li><li>计算<img src="https://api.bilibili.com/x/web-frontend/mathjax/tex?formula=x%27=x%5Coplus%20k%27" alt="x&#39;%3Dx%5Coplus%20k&#39;"></li><li>将<img src="https://api.bilibili.com/x/web-frontend/mathjax/tex?formula=x%27" alt="x&#39;">拆分为多个小型的block <img src="https://api.bilibili.com/x/web-frontend/mathjax/tex?formula=x_1,x_2,...,x_t" alt="x_1%2Cx_2%2C...%2Cx_t"></li><li>计算<img src="https://api.bilibili.com/x/web-frontend/mathjax/tex?formula=x%27_i=S(x_i),i=1...t" alt="x&#39;_i%3DS(x_i)%2Ci%3D1...t"></li><li>将每一个小型的block <img src="https://api.bilibili.com/x/web-frontend/mathjax/tex?formula=x_i%27" alt="x_i&#39;">按照一定的方式重组</li><li>重复以上步骤多次。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一段sp网络的加密 </span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">text=<span class="string">&quot;C# was developed around 2000 by Microsoft as part of its .NET initiative and later approved as an international standard by Ecma (ECMA-334) in 2002 and ISO (ISO/IEC 23270) in 2003. &quot;</span></span><br><span class="line">binarylist = [ <span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  <span class="built_in">list</span>(text.lower().encode(<span class="string">&#x27;utf-8&#x27;</span>))]    <span class="comment">#lowe()将大写转换为小写  zfill()指定返回的长度  一个utf-8 一个字节，故保留了8个bit</span></span><br><span class="line">plaintext = <span class="string">&quot;&quot;</span>.join(binarylist)    <span class="comment">#将字符串进行拼接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">length = <span class="number">16</span>     <span class="comment"># total bits = 8*length</span></span><br><span class="line">plaintext = plaintext[<span class="number">0</span>: <span class="number">8</span>*length]</span><br><span class="line">master = <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(random.randint(<span class="number">0</span>,<span class="number">1</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)))    <span class="comment">#根据plantext的长度随机生成一串01字符串，暂且称其为密钥，但这里是随机生成的128bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build a bijective table     所谓的s盒</span></span><br><span class="line">y = [<span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>)]</span><br><span class="line">random.shuffle(y)</span><br><span class="line">sbox = &#123;<span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>):y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>)&#125;</span><br><span class="line"><span class="comment"># build permutation table       p盒</span></span><br><span class="line">y = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">random.shuffle(y)           <span class="comment">#分配算法利用了shuffle</span></span><br><span class="line">ptable = &#123;i:y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)&#125;</span><br><span class="line"></span><br><span class="line">code = plaintext</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    code = <span class="string">&quot;&quot;</span>.join( <span class="string">&quot;0&quot;</span> <span class="keyword">if</span> code[i] == master[i] <span class="keyword">else</span> <span class="string">&quot;1&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)))  <span class="comment">#进行一波异或操作，将明文通过</span></span><br><span class="line">    temp = [sbox[code[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    <span class="comment"># 每8个字符划分成一组加密</span></span><br><span class="line">    slist = [temp[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length) ]</span><br><span class="line">    code = <span class="string">&quot;&quot;</span>.join(slist)</span><br></pre></td></tr></table></figure><p>这里没有写密钥去定义s盒的部分，如果能够通过密钥去定义s盒，然后通过p盒对密文分组进行分发，可以起到一个很好的效果。        peace~</p><h4 id="4-2-2-Feitel密码结构"><a href="#4-2-2-Feitel密码结构" class="headerlink" title="4.2.2 Feitel密码结构"></a>4.2.2 Feitel密码结构</h4><p>主密钥生成一个子密钥集，每个阶段使用一个子密钥，明文首先分为左右两部分，分别记为L<sub>0</sub>和R<sub>0</sub> ,在进行完r轮迭代之后，左右两半合并在一起在产生密文，每轮迭代的运算逻辑关系</p><p>L<sub>i</sub>=R<sub>i-1</sub></p><p>R<sub>i</sub>=L<sub>i-1</sub>⊕F(R<sub>i-1</sub> , K<sub>i</sub>)</p><p>其中，K<sub>i</sub>表示第i轮用的子密钥，F表示轮函数</p><img src="https://static.oschina.net/uploads/img/201610/17141512_yJxg.jpg" alt="一轮" style="zoom: 50%;" /><p>喻：制作葱油饼</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Feistel密码结构的另外一个显著的特点就是其逆向操作和正向操作是指具有相同的结构，二者唯一的不同就是子密钥使用次序不同。</p><p>（很有趣，利用异或的可逆性）</p><p>采用Feistel密码结构设计分组密码算法时，加解密可采用同一种算法。</p><p><img src="https://static.oschina.net/uploads/img/201610/17142027_eJ9Q.jpg" alt="输入图片说明"></p><p>贴一个 利用feitel网络设计的密码，类DES</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strEncrypt</span>(<span class="params">s1, s2, key</span>):</span>  <span class="comment"># 每次传输8个字符,分成两组按位异或,密钥4个字符</span></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        temp = <span class="built_in">ord</span>(s1[i]) ^ <span class="built_in">ord</span>(s2[i]) ^ <span class="built_in">ord</span>(key[i])</span><br><span class="line">        result += <span class="built_in">chr</span>(temp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">plainText, keylist</span>):</span></span><br><span class="line">    cipherText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(plainText) // <span class="number">8</span>):</span><br><span class="line">        temp = plainText[i * <span class="number">8</span>:(i + <span class="number">1</span>) * <span class="number">8</span>]  <span class="comment"># 每8个字符划分成一组加密</span></span><br><span class="line">        L = temp[:<span class="number">4</span>]</span><br><span class="line">        R = temp[<span class="number">4</span>:]</span><br><span class="line">        <span class="keyword">for</span> currentKey <span class="keyword">in</span> keylist:</span><br><span class="line">            temp2 = R</span><br><span class="line">            R = strEncrypt(L, R, currentKey)</span><br><span class="line">            L = temp2</span><br><span class="line">        cipherText += R + L</span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    key = []</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&#x27;请输入要加密的字符串，目前算法能处理的明文字符为8的整数倍&#x27;</span>)</span><br><span class="line">    keynum = <span class="built_in">input</span>(<span class="string">&#x27;请输入加密循环次数&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(keynum)):</span><br><span class="line">        temp = <span class="built_in">input</span>(<span class="string">&#x27;请输入第&#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27;组加密时使用的密钥（4个字符）&#x27;</span>)</span><br><span class="line">        key.append(temp)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;要加密的明文为：&#x27;</span>, a)</span><br><span class="line">    a = encode(a, key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;密文：&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#####解密</span></span><br><span class="line">    key.reverse()           <span class="comment">#倒序输出</span></span><br><span class="line">    a = encode(a, key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;解密后的明文：&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>此处推荐去查看密码学之实践篇  N1CTF (python)</p><h3 id="4-3-DES算法概述"><a href="#4-3-DES算法概述" class="headerlink" title="4.3 DES算法概述"></a>4.3 DES算法概述</h3><h4 id="4-3-1-DES算法概述"><a href="#4-3-1-DES算法概述" class="headerlink" title="4.3.1 DES算法概述"></a>4.3.1 DES算法概述</h4><p>数据加密标准(Data Encryption Standard,DES)，于1997年1月15日由美国国家标准局（NBS）正式发布实施，是第一公开的商用密码算法标准，但随着密码分析技术和计算能力的提高，DES算法不在安全，在2000年，DES算法已被更为安全AES算法取代。</p><p>（DES的最主要问题是密钥长度太短，特别是有效密钥长度太短了（<strong>56比特</strong>）。以现在的计算能力，可以用密钥穷举攻击破解DES。给定一密文，算法已知，尝试利用所有的密钥对密文进行解密，若能解密出一个实际意义的明文，则所用密钥记为有效密钥。但其实这也好办，多加密几次，难度成指数级增长，咋可能解，套！）</p><p>​    DES算法是一种典型的Feistel结构的分组密码算法，它的明文分组长度为64bit，密钥长度为64bit，其中密钥有8bit是奇偶校验，因此有效密钥长度为56bit。DES算法的加密和解密采用同一过程，它的安全性依赖于有效密钥。DES算法首先把需要加密的明文划分为每64bit的数据块，用56bit有效密钥和64bit数据块加密。</p><p>DES算法，运算速度快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇（分组密码体制）&quot;&gt;&lt;a href=&quot;#密码学之理论篇（分组密码体制）&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇（分组密码体制）&quot;&gt;&lt;/a&gt;密码学之理论篇（分组密码体制）&lt;/h1&gt;&lt;h1 id=&quot;四、分组密码体制&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学之理论篇（概述及古典密码学）</title>
    <link href="http://example.com/2021/12/01/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/12/01/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2021-12-05T02:51:50.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇（概述及古典密码学）"><a href="#密码学之理论篇（概述及古典密码学）" class="headerlink" title="密码学之理论篇（概述及古典密码学）"></a>密码学之理论篇（概述及古典密码学）</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-1-密码学在信息安全中的作用"><a href="#1-1-1-密码学在信息安全中的作用" class="headerlink" title="1.1.1 密码学在信息安全中的作用"></a>1.1.1 密码学在信息安全中的作用</h3><p>密码学是信息安全的基石，是信息安全的核心技术。</p><p>密码学绝不是保证信息安全的唯一技术，确保信息安全，除了技术之外，管理也是非常重要的一个方面。（安全管理的重要性）</p><h3 id="1-1-2密码学的发展历程"><a href="#1-1-2密码学的发展历程" class="headerlink" title="1.1.2密码学的发展历程"></a>1.1.2密码学的发展历程</h3><p>古典密码学阶段，密码学基本上可以说是一门技巧性很强的艺术（玩不来艺术，呜呜呜），而不是一门科学。</p><p>1949年，香农在《贝尔系统技术》杂志上发表了<strong>“保密系统的通信理论”</strong> ，为密码学奠定了坚实的理论基础，是密码学真正成了一门科学。</p><p>1976年，W.E.Diffie 和 M.E.Hellman发表了《密码学新方向》一文，提出了一种全新的密码设计思想，导致了密码学史上的一场革命，，，公钥密码学或非对称密钥密码学</p><p>1977年美国国家标准局，正式公布了数据加密标准DES</p><p>1978年 R.L.Rivest    A.Shamir  L.Adleman确立了RSA公钥密码学，成为了公钥密码学的杰出代表。</p><p>1984年 Charles H.Bennett和Brassard Gille首次提出了量子密码学，他可以发现窃听等攻击。</p><p>1985年，N.Koblitz 和 V.Miller 把椭圆曲线理论运用到公钥密码学中</p><p>于此同时——-序列密码，主要用于政府、军事等国家要害部门，1989年 R.Mathews    D.Wheeler      L.M.Pecora 和 Carroll等人首次把混沌理论使用到序列密码及保密通信理论中</p><p>1994年,Adleman利用DNA计算解决了一个有向汉米尔顿路径问题，出现了一个新的密码学领域——–DNA密码</p><p>1996年，Ajtai在格问题困难性的基础上，（基于格的公钥密码）</p><p>2000年10月，由比利时密码学家Joan Daemen、Vincent Rijmen</p><p>密码算法成为新一代数据加密标准——-AES算法</p><p>都是大佬膜拜。。</p><h3 id="1-2-密码学的基本知识"><a href="#1-2-密码学的基本知识" class="headerlink" title="1.2 密码学的基本知识"></a>1.2 密码学的基本知识</h3><p>经典密码学包括<strong>密码编码学</strong>和**密码分析学 **  </p><p>密码编码学是研究把信息（明文）变换成没有密钥就不能解读或很难解读的密文的方法。</p><p>密码分析学是研究分析破译密码的方法</p><p>现代密码学除了密码编码学和密码分析学两个学科之外，还包括近几年才形成的新分支——-<strong>密钥密码学</strong>，它是以密钥（现代密码学的核心）及密钥管理作为研究对象的学科</p><p>现代密码学最重要的原则是“一切秘密寓于密钥之中”。即算法是公开的，但密钥必须是保密的。</p><h3 id="1-3-1-保密通信模型"><a href="#1-3-1-保密通信模型" class="headerlink" title="1.3.1 保密通信模型"></a>1.3.1 保密通信模型</h3><p>1949年，香农（C.E.Shannon）发表了一篇题为《保密系统的信息理论》的论文，该论文用信息论的观点对信息保密问题进行了全面的阐述</p><p>香农从概率统计的观点出发研究信息的传输和保密问题，保密系统设计的目的是使窃听者（或攻击者）即使在完全准确地收到了接受信号的情况下，也无法恢复出原始信息。</p><p><img src="https://img-blog.csdnimg.cn/9a6169fc98a1470ab902c170be3c188c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>如果假定信道是无干扰的，则合法的密文接收者能够利用解密变换和密钥从密文中恢复明文，即m=D<sub>k</sub>(c)=D<sub>k</sub>(E<sub>k</sub>(m)).</p><p>此处D为decode解密，E为encode，k为密钥</p><p>假定密码分析者能够从信道上截获密文，还假定密码分析者知道所用的密码体制，还知道明文空间和密钥空间机器统计特性（这就是所谓的Kerckhoffs假设）那么密码体制的安全性完全取决于所选用的密钥的安全性。（密钥的破解难度，以及分发的安全性）</p><p>料敌从宽，锁是公开的，锁芯和钥匙不公开。</p><h3 id="1-3-2密码学基本知识"><a href="#1-3-2密码学基本知识" class="headerlink" title="1.3.2密码学基本知识"></a>1.3.2密码学基本知识</h3><p>一个密码体制或密码算法通常由一下五个部分构成</p><p>（1）明文空间M（全体明文的集合）</p><p>（2）密文空间C（全体密文的集合）</p><p>（3）密钥空间K（全体密钥集合）</p><p>（4）加密器或加密变换（算法）E ，E<sub>k</sub>(m)=c ,m∈M， c∈C, k∈K</p><p>（5）解密器或解密变换（算法）D<sub>k</sub>(c)=m   ,m∈M， c∈C, k∈K</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">明文 message------&gt;M</span><br><span class="line"></span><br><span class="line">密文ciphertext-----&gt;C</span><br><span class="line"></span><br><span class="line">密钥 key----------&gt;K</span><br><span class="line"></span><br><span class="line">加密 enctypt------&gt;E</span><br><span class="line"></span><br><span class="line">解密 dectypt-----&gt;D</span><br></pre></td></tr></table></figure><p>传统密码体制所采用的加密密钥和解密密钥相同，成为<strong>对称密钥密码体制</strong></p><p>最典型的就是美国数据加密标准DES。1976年，在由Diffe和Hellman提出的密码新体制中，加密密钥和解密密钥不同，也不能相互推导，成为公钥或<strong>非对称密钥密码体制</strong>。</p><p>现代密码学普遍依赖于数学</p><p>小结：</p><p>对称密码，可以理解为：锁门时需要用钥匙，开门还需要同样的钥匙。公钥密码，可以理解为：锁门时不需要密钥，锁就在门上挂则呢，按一下就锁上了；开门时需要钥匙。</p><h3 id="1-4密码体制的安全性"><a href="#1-4密码体制的安全性" class="headerlink" title="1.4密码体制的安全性"></a>1.4密码体制的安全性</h3><h3 id="1-4-1密码分析"><a href="#1-4-1密码分析" class="headerlink" title="1.4.1密码分析"></a>1.4.1密码分析</h3><p>密码分析是密码分析者在不知道密钥的情况下，从密文恢复出明文</p><h5 id="1-分析密码算法的方法"><a href="#1-分析密码算法的方法" class="headerlink" title="1.分析密码算法的方法"></a>1.分析密码算法的方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）穷举法：试图试遍所有的明文或密钥来进行破译</span><br><span class="line"></span><br><span class="line">（2）统计分析学：通过分析密文、明文和密钥的统计规律来破译密码技术</span><br><span class="line"></span><br><span class="line">（3）密码体制分析法</span><br></pre></td></tr></table></figure><h5 id="2-对密码体制进行攻击"><a href="#2-对密码体制进行攻击" class="headerlink" title="2.对密码体制进行攻击"></a>2.对密码体制进行攻击</h5><p>（1）唯密文攻击：密码分析者仅知道两样东西：带破译的一些密文和加密算法，并试图恢复尽可能多的明文，并进一步推导出加密信息的密钥。</p><p><strong>只知道 一堆密文 C<sub>1</sub>,C<sub>2</sub>,C<sub>3</sub>…….C<sub>t</sub>以及加密算法E</strong></p><p>（2）已知明文攻击不仅知道一些带破译的密文，还知道与该密文对应的明文，根据明文—密文对试图推导出加密密钥</p><p><strong>知道一堆明密文对(m<sub>1</sub>,c<sub>1</sub>),(m<sub>2</sub>,c<sub>2</sub>),以及加密算法E</strong></p><p>（3）选择明文攻击可以任意选择一些明文，密码分析者用加密算法，并得到相应的密文，然后试图推导出加密密钥</p><p><strong>1.知道加密算法E</strong></p><p><strong>2.挑选一些特殊的更有价值的明文，如m<sub>i1</sub>,m<sub>i2</sub>,…….,m<sub>it</sub></strong></p><p><strong>3.利用加密算法E对选择的明文进行加密，产生密文C<sub>i1</sub>,C<sub>i2</sub>,……..,C<sub>it</sub>这样就得到一些明密文对：</strong></p><p>（m<sub>i1</sub>,c<sub>i1</sub>),(m<sub>i2</sub>,c<sub>i2</sub>),………,(m<sub>it</sub>,c<sub>it</sub>)</p><p>（4）选择密文攻击可以选择不同的密文，以及相应的被破解的明文，并试图推导出加密密钥</p><p>可类比 选择明文攻击 </p><p>（5）选择文本攻击：是选择明文攻击和选择密文攻击的结合</p><p>唯密文攻击是最困难的，因为分析者可利用的信息最少，一个密码体制是安全的，通常是指前三种攻击下是安全的</p><h3 id="1-4-2-密码体制的安全性及安全条件"><a href="#1-4-2-密码体制的安全性及安全条件" class="headerlink" title="1.4.2 密码体制的安全性及安全条件"></a>1.4.2 密码体制的安全性及安全条件</h3><h4 id="1-密码算法的安全性"><a href="#1-密码算法的安全性" class="headerlink" title="1.密码算法的安全性"></a>1.密码算法的安全性</h4><p>现代密码学最重要的原则是“一切秘密寓于密钥之中”，即这些算法的安全性都是基于密钥的安全性，算法是可以公开的，也可以被分析，即使攻击者知道算法也不对算法的安全性构成危害。</p><p>算法公开具有这样一些优点，可以防止算法设计者在算法中隐藏后门；是评估算法安全性的唯一最佳的方式</p><h4 id="2-评价密码体制安全性的方法和条件"><a href="#2-评价密码体制安全性的方法和条件" class="headerlink" title="2.评价密码体制安全性的方法和条件"></a>2.评价密码体制安全性的方法和条件</h4><p>（1）评价密码体制安全性的方法</p><p>​        1)无条件安全：即使破译者提供了无穷的资源，依然无法破译，除一次一密密码算法外，无条件安全算法是不存在的。</p><p>​        2）可证明安全性：将密码算法的安全性归结为某个经过深入研究的数学难题</p><p>​        3）计算机安全性，利用已有的最好的破译方法破译该密码算法所需要的努力超出了破译者的破译能力。</p><p>（2）破译的原则</p><p>​        1）破译密码算法的成本是否超过了被加密信息本身的价值。</p><p>​        2）破译密码的时间是否超过被加密信息有用的生命周期</p><p>​        如果满足上述两个准则之一，则可以认为该密码算法在实际上是安全的</p><h1 id="二、古典密码体制"><a href="#二、古典密码体制" class="headerlink" title="二、古典密码体制"></a>二、古典密码体制</h1><h3 id="2-1-古典密码概述"><a href="#2-1-古典密码概述" class="headerlink" title="2.1 古典密码概述"></a>2.1 古典密码概述</h3><p>古典密码知识对字母进行变换，而现代密码算法是对比特流进行变换。古典密码技术比较简单，是采用手工或机械操作来对明文进行加密和解密的，古典密码技术根据其基本原理大体上可以分为三类：传统隐写术、替换密码技术和换位密码技术。</p><h3 id="2-2传统隐写术"><a href="#2-2传统隐写术" class="headerlink" title="2.2传统隐写术"></a>2.2传统隐写术</h3><p>隐写术将秘密信息隐写于非秘密或者不太秘密的信息中的方法，是信息隐藏的技术之一，如：显隐墨水，藏头诗。</p><p>隐写术也可以用作数字水印。</p><h3 id="2-3替换密码技术"><a href="#2-3替换密码技术" class="headerlink" title="2.3替换密码技术"></a>2.3替换密码技术</h3><h4 id="2-3-1-单字符单表替换密码技术"><a href="#2-3-1-单字符单表替换密码技术" class="headerlink" title="2.3.1 单字符单表替换密码技术"></a>2.3.1 单字符单表替换密码技术</h4><p>单字符单表替换密码技术是对明文中的所有字符都使用一个固定的映射</p><p>（密钥确定之后，同样的明文字符，每次出现时都被加密成同样的密文字符）</p><p>典型的单字符单表替换密码技术有乘法密码技术、加法密码技术、仿射密码技术</p><h5 id="1-乘法密码技术"><a href="#1-乘法密码技术" class="headerlink" title="1.乘法密码技术"></a>1.乘法密码技术</h5><p>加密变换： E<sub>k</sub>(a<sub>i</sub>)=a<sub>j</sub> , j=i*k(mod n ), gcd(k,n)=1</p><p>解密变换：D<sub>k</sub>(a<sub>j</sub>)=a<sub>i</sub> , i=jk<sup>-1</sup>(mod n)                              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">k是密钥</span><br><span class="line">j=i*k(mod n)    -----&gt;j等于i和k的乘积除u的余数</span><br><span class="line">(k,n)=1 &lt;====&gt; 存在 a,b∈Z ,ak+bn=1 &lt;===&gt; k^-1(mod n)存在，就是a</span><br></pre></td></tr></table></figure><p>例 英文字母n=26，选取密钥k=9，则明文字母到密文字母的替换表</p><p>此时的字母表</p><p><img src="https://img-blog.csdnimg.cn/ff187e192b944eebbb8c242cc92b5703.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>解题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 字符串转单字符列表，并返回数字序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoc</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    ch_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">        ch_list.append(i)</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">ord</span>(i)-<span class="number">65</span> <span class="keyword">for</span> i <span class="keyword">in</span> ch_list]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Int to Chr</span></span><br><span class="line"><span class="comment"># 将数字序列还原成大写字母序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">itoc</span>(<span class="params">list_int</span>):</span></span><br><span class="line">    A = [<span class="built_in">chr</span>(i+<span class="number">65</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list_int]</span><br><span class="line">    ch = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        ch += i</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密文序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encrypt</span>(<span class="params">Message,k,n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;使用乘法密码算法进行加密（k=&#123;&#125;, n=&#123;&#125;）&#x27;</span>.<span class="built_in">format</span>(k,n))</span><br><span class="line">    <span class="keyword">return</span> itoc([i*k%n <span class="keyword">for</span> i <span class="keyword">in</span> stoc(Message)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算明文序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span>(<span class="params">Ciphertext,k,n</span>):</span></span><br><span class="line">    <span class="comment"># 解密方式1：通过构建密码表进行查表解密</span></span><br><span class="line">    <span class="comment"># 解密方式2：通过加密逆运算计算明文</span></span><br><span class="line">    DecryptionType = <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(DecryptionType == <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;构建密码表：&#x27;</span>)</span><br><span class="line">        A = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n)]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;明文字母表：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(itoc(A)))</span><br><span class="line">        B = Encrypt(itoc(A),k,n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;密文字母表：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(B))</span><br><span class="line">        CiphertextTables = <span class="built_in">dict</span>(<span class="built_in">zip</span>(B,A))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;构建密码表进行查表解密&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> itoc([CiphertextTables[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ciphertext])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> k1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">            <span class="keyword">if</span>(k1 * k % n == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;通过加密逆运算进行解密（k的逆元为:&#123;&#125;）&#x27;</span>.<span class="built_in">format</span>(k1))</span><br><span class="line">        <span class="keyword">return</span> itoc([c*k1%n <span class="keyword">for</span> c <span class="keyword">in</span> stoc(Ciphertext)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 当前仅支持大写字母串</span></span><br><span class="line">    A = (<span class="string">&#x27;AMAN&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入的明文字符串为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(A))</span><br><span class="line">    B = Encrypt(A,<span class="number">9</span>,<span class="number">26</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加密后的密文：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(B))</span><br><span class="line">    C = Decrypt(B,<span class="number">9</span>,<span class="number">26</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;解密后的明文：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(C))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-3-2-单字符多表替换密码技术"><a href="#2-3-2-单字符多表替换密码技术" class="headerlink" title="2.3.2 单字符多表替换密码技术"></a>2.3.2 单字符多表替换密码技术</h4><p>单字符多表替换密码技术在安全性方面比单字符表替换密码技术高</p><p>单字符多表替换密码技术有很多，典型的有Vigenere密码技术、Vernam密码技术、Hill密码技术、Playfair密码技术等。</p><h5 id="1-vernam（弗纳姆）密码技术"><a href="#1-vernam（弗纳姆）密码技术" class="headerlink" title="1.vernam（弗纳姆）密码技术"></a>1.vernam（弗纳姆）密码技术</h5><p>设明文m=m<sub>1</sub> , m<sub>2</sub> , ….,密钥k=k<sub>1</sub> ,k<sub>2</sub>  , ……., 其中m<sub>i</sub> , k<sub>i</sub> ∈ GF(2) , i&gt;=1 ,则密文 c = c<sub>1</sub>c<sub>2</sub> …..,</p><p>其中c<sub>i</sub>=m<sub>i</sub>⊕k<sub>i</sub>   .    这里⊕为模2加法</p><p>​            GF(2)={0,1}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模2加法</span><br><span class="line">规则是两个序列按位相加模二，即两个序列中对应位，相加，不进位，相同为0，不同为1。</span><br><span class="line">1+1=0+0=0</span><br><span class="line">1+0=0+1=1</span><br><span class="line">与计算机位运算符的 异或算法一致 1^1=0 ,0^0=0,1^0=1,0^1=1</span><br></pre></td></tr></table></figure><p>【例2-5】设明文m=01100001，密钥k=01001110，使用Vernam密码加密求密文解:加密得密文:c=m)k=01100001⊕ 01001110=00101111，即密文为00101111.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data=<span class="number">0b01100001</span></span><br><span class="line">key=<span class="number">0b01001110</span></span><br><span class="line">e=data^key</span><br></pre></td></tr></table></figure><h3 id="2-4-换位密码技术"><a href="#2-4-换位密码技术" class="headerlink" title="2.4 换位密码技术"></a>2.4 换位密码技术</h3><p>换位面吗技术本质上就是一种置换密码技术，是重新排列消息中的字母。</p><h4 id="2-4-1列换位"><a href="#2-4-1列换位" class="headerlink" title="2.4.1列换位"></a>2.4.1列换位</h4><p>列换位的原理：首先将明文按照密钥个数排列，然后再按照密钥在字母表中的顺序变换列的顺序，最后按照列的顺序写出的就是英文</p><h3 id="2-5古典密码的安全性分析"><a href="#2-5古典密码的安全性分析" class="headerlink" title="2.5古典密码的安全性分析"></a>2.5古典密码的安全性分析</h3><p>对于代替密码来说，密文中还保留了明文的统计特征，因此可以使用统计方法进行攻击</p><p>英文字母中出现的频率也是有统计规律的</p><p>单字母E出现频率最高</p><p>双字母TH出现频率最高</p><h4 id="2-5-1移位密码安全性分析-（加法密码技术）"><a href="#2-5-1移位密码安全性分析-（加法密码技术）" class="headerlink" title="2.5.1移位密码安全性分析  （加法密码技术）"></a>2.5.1移位密码安全性分析  （加法密码技术）</h4><p>以为密码是极不安全的（mod 26），因为它可被穷举密钥搜索分析，仅有26种可能的密钥</p><h1 id="三、数学基础"><a href="#三、数学基础" class="headerlink" title="三、数学基础"></a>三、数学基础</h1><p><img src="https://img-blog.csdnimg.cn/20210415155325599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA5Nzc2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇（概述及古典密码学）&quot;&gt;&lt;a href=&quot;#密码学之理论篇（概述及古典密码学）&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇（概述及古典密码学）&quot;&gt;&lt;/a&gt;密码学之理论篇（概述及古典密码学）&lt;/h1&gt;&lt;h2 id=&quot;一、概述&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/11/25/hello-world/"/>
    <id>http://example.com/2021/11/25/hello-world/</id>
    <published>2021-11-24T17:01:56.458Z</published>
    <updated>2021-11-26T15:50:21.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在博客最开头的小论文"><a href="#写在博客最开头的小论文" class="headerlink" title="写在博客最开头的小论文"></a>写在博客最开头的小论文</h1><p>之前想过要不要搭一个博客，但随着学习的深入，越发觉得自己的可能在某些领域没有摸到门道</p><p>如果成了某个领域的佼佼者，再来写这个博客，但是在安全组的培训算是给了一个很好的写文章的机会，</p><p>遂将其斗胆分享出来，里面的内容或有借鉴（cv）或有自己心得，若有侵权请联系我，会及时删掉。</p><p>​                                                                                                                                                QQ:970856057</p><p>​                                                                                                                                                                 鑫缘</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在博客最开头的小论文&quot;&gt;&lt;a href=&quot;#写在博客最开头的小论文&quot; class=&quot;headerlink&quot; title=&quot;写在博客最开头的小论文&quot;&gt;&lt;/a&gt;写在博客最开头的小论文&lt;/h1&gt;&lt;p&gt;之前想过要不要搭一个博客，但随着学习的深入，越发觉得自己的可能在某些</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="http://example.com/2021/11/25/TcpIP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/11/25/TcpIP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-11-24T16:00:00.000Z</published>
    <updated>2021-11-26T15:53:13.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><h2 id="TCP-IP-协议的具体含义"><a href="#TCP-IP-协议的具体含义" class="headerlink" title="TCP/IP 协议的具体含义"></a>TCP/IP 协议的具体含义</h2><p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的<strong>协议群的统称</strong>。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。<br>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><strong>计算机网络体系结构分层</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/690219fae5b0587fa26e2dee545e6200~tplv-t2oaga2asx-watermark.awebp" alt="计算机网络体系结构分层" style="zoom:150%;" /><p>TCP/IP协议族按照层次<strong>由上到下，层层包装</strong>。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/32269df6363944b0df8fe99204e92c91~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><blockquote><p>上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/7f693d4add34644a6268e0e11bec2cb7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p><p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p><p> A类IP地址: 0.0.0.0<del>127.0.0.0<br>B类IP地址:128.0.0.1</del>191.255.0.0<br>C类IP地址:192.168.0.0~239.255.255.0</p><h3 id="IP协议头"><a href="#IP协议头" class="headerlink" title="IP协议头"></a>IP协议头</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/dbb082d9806de01f5653423917a1f71b~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p><h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><blockquote><p>他们的目标都是在程序之间传输数据。<br>数据可以是文本，文件，可以是视频，也可以是图片。对于TCP协议和UDP协议来说，都是一对二进制数，并没有多大的区别。</p></blockquote><p><strong>TCP 是面向连接的、可靠的流协议。</strong>流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p><p><strong>UDP 是不具有可靠性的数据报协议。</strong>细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p><p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。<strong>TCP 和 UDP 应该根据应用的目的按需使用。</strong></p><h2 id="TCPUDP之间的区别是什么？"><a href="#TCPUDP之间的区别是什么？" class="headerlink" title="TCPUDP之间的区别是什么？"></a>TCPUDP之间的区别是什么？</h2><p>最大的区别是一个基于连接，一个基于非连接。<br>我们来举一个简单的例子，如果把人与人的通信比喻为进程与进程的通信，我们基本有两种方式。第一种方式是写信，第二种方式是打电话。</p><p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto3974789fb5ee497a87f35500480b4571" alt="image-20211105125454004"></p><p><strong>TCP是如何保证以上过程的？</strong></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP报文数据包"><a href="#TCP报文数据包" class="headerlink" title="TCP报文数据包"></a>TCP报文数据包</h3><p><img src="https://pic1.zhimg.com/80/v2-63955c8436410907d6fe4697d5bf0b0c_720w.jpg" alt="img"></p><p><img src="https://s1.ax1x.com/2018/03/02/9rzlJf.png" alt="img"></p><h3 id="TCP-首部各字段的意义和作用"><a href="#TCP-首部各字段的意义和作用" class="headerlink" title="TCP 首部各字段的意义和作用"></a>TCP 首部各字段的意义和作用</h3><blockquote><p>TCP首部最小为20字节，这20字节分为5行，每行4个字节也就是32个位。</p><h5 id="源端口和目的端口-Port"><a href="#源端口和目的端口-Port" class="headerlink" title="源端口和目的端口 Port"></a>源端口和目的端口 Port</h5><ul><li>源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。</li><li>目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 分别占用16位，也就是端口号最大是2^16，所以端口号的范围是0~65536</li></ul><p>端口号的分配：</p><ul><li>知名端口号一般位于：1 — 255 之间</li><li>256 — 1023的端口号，通常是由Unix系统占用（系统占用）</li><li>1024 —5000 是大多数TCP、IP实现的临时分配</li><li>大于5000的一般是给其他服务预留的（Internet上并不常用的服务）</li></ul><h5 id="序号-Sequence-Number"><a href="#序号-Sequence-Number" class="headerlink" title="序号 Sequence Number"></a>序号 Sequence Number</h5><p>TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。</p><h5 id="确认号-Acknowledgemt-Number"><a href="#确认号-Acknowledgemt-Number" class="headerlink" title="确认号 Acknowledgemt Number"></a>确认号 Acknowledgemt Number</h5><p>占 4 个字节，表示期望收到对方下一个报文段的序号值。 TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。</p><p>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。 例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个确认报文，其中的确认号 = 25600.</p><h5 id="数据偏移-Offset"><a href="#数据偏移-Offset" class="headerlink" title="数据偏移 Offset"></a>数据偏移 Offset</h5><p>占 0.5 个字节 (4 位)。 这个字段实际上是指出了 TCP 报文段的首部长度 ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）</p><p>一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。</p><h5 id="保留-Reserved"><a href="#保留-Reserved" class="headerlink" title="保留 Reserved"></a>保留 Reserved</h5><p>占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。</p><h5 id="标志位-TCP-Flags"><a href="#标志位-TCP-Flags" class="headerlink" title="标志位 TCP Flags"></a>标志位 TCP Flags</h5><p>标志位，一共有 6 个，分别占 1 位，共 6 位 。 每一位的值只有 0 和 1，分别表达不同意思。</p><ul><li>ACK：确认序号有效</li><li>RST：重置连接</li><li>SYN：发起了一个新连接</li><li>FIN：释放一个连接</li></ul><h5 id="确认-ACK-Acknowlegemt"><a href="#确认-ACK-Acknowlegemt" class="headerlink" title="确认 ACK (Acknowlegemt)"></a>确认 ACK (Acknowlegemt)</h5><p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。</p><p>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。</p><h5 id="推送-PSH-Push"><a href="#推送-PSH-Push" class="headerlink" title="推送 PSH (Push)"></a>推送 PSH (Push)</h5><p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。</p><h5 id="复位-RST-Reset"><a href="#复位-RST-Reset" class="headerlink" title="复位 RST (Reset)"></a>复位 RST (Reset)</h5><p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。</p><h5 id="同步-SYN-SYNchronization"><a href="#同步-SYN-SYNchronization" class="headerlink" title="同步 SYN (SYNchronization)"></a>同步 SYN (SYNchronization)</h5><p>当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。</p><p>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。</p><h5 id="终止-FIN-Finis"><a href="#终止-FIN-Finis" class="headerlink" title="终止 FIN (Finis)"></a>终止 FIN (Finis)</h5><p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。</p><p>一般称携带 FIN 的报文段为「结束报文段」。</p><p>在 TCP 四次挥手释放连接的时候，就会用到该标志。</p><h5 id="窗口大小-Window-Size"><a href="#窗口大小-Window-Size" class="headerlink" title="窗口大小 Window Size"></a>窗口大小 Window Size</h5><p>占 2 字节。</p><p>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。</p><p>例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。</p><h5 id="校验和-TCP-Checksum"><a href="#校验和-TCP-Checksum" class="headerlink" title="校验和 TCP Checksum"></a>校验和 TCP Checksum</h5><p>占 2 个字节。 由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。</p><p>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</p><h5 id="紧急指针-Urgent-Pointer"><a href="#紧急指针-Urgent-Pointer" class="headerlink" title="紧急指针 Urgent Pointer"></a>紧急指针 Urgent Pointer</h5><p>占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</p><p>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p></blockquote><p><strong>有三个关键的步骤，分别为三次握手、传输确认、四次挥手。</strong></p><h3 id="TCP的三次握手，四次挥手"><a href="#TCP的三次握手，四次挥手" class="headerlink" title="TCP的三次握手，四次挥手"></a>TCP的三次握手，四次挥手</h3><h4 id="需要了解的信息"><a href="#需要了解的信息" class="headerlink" title="需要了解的信息"></a>需要了解的信息</h4><ul><li>ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li><li>SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</li><li>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li></ul><p>TCP（Transmission Control Protocol，传输控制协议）是 面向连接的协议，也就是说在<strong>收发数据之前，必须先和对方建立连接</strong></p><blockquote><p>一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的 描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数 据。</p></blockquote><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。<strong>三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</strong></p><img src="https://pic2.zhimg.com/80/v2-1587e91f14923eae0fa7d846cb10df99_720w.jpg" alt="img" style="zoom:200%;" /><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入<strong>SYN_SEND</strong>状态，等待服务器的确认；    </p><p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入<strong>SYN_RECV</strong>状态；  </p><p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入<strong>ESTABLISHED</strong>状态，完成TCP三次握手。</p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto098b95dd1e884eefb56a114cbb1a529f"  /><p><strong>为什么要三次握手而不是两次握手？服务端回复完SYN+ACK之后就建立连接</strong></p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>假设采用两次握手建立连接客户端，向服务端发送了一个SYN来请求建立连接。<br>因为某些未知的原因并没有到达服务器在中间某个网络节点产生了滞留。<br>为了建立连接客户端，会重发SYN，这次的数据包正常送达，服务端回复SYN+ACK之后建立起来连接。<br>但是第一包数据阻塞的网络节点突然恢复，第一包省包又送达到服务端。这时服务端会误认为是客户端又发起了一个新的连接，从而在两次握手之后进入等待数据状态。<br><strong>服务端认为是两个连接，而客户端认为是一个连接，造成了状态不一致。</strong><br>如果在三次握手的情况下，服务端收不到最后的ACK自然不会认为连接建立成功。<br>所以三次握手本质上来说就是为了解决网络信道不可靠的问题。为了能够在不可靠的信道上建立起可靠的连接。<br>经过三次握手之后，客户端和服务端都进入了数据传输状态。</p><blockquote><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nnA &#x27;port 9999&#x27;</span><br><span class="line">nc -4vl 9999</span><br><span class="line">telnet swordk.cn 9999</span><br></pre></td></tr></table></figure><h4 id="传输确认"><a href="#传输确认" class="headerlink" title="传输确认"></a>传输确认</h4><p>TCP协议需要在不可靠的信道上保证可靠的连接。现在这有几个问题需要面对。</p><p>一包数据有可能会被拆成多包发送如何处理<strong>丢包</strong>问题？<br>这些数据包到达的先后顺序不同，如何处理<strong>乱序</strong>问题？</p><p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto683ac4ddaa994e71a7e04583ee9b9aa5" alt="image-20211105132602749"></p><p>针对这些要求，TCP协议为每一个连接建立了一个发送缓冲区。从建立连接后的第一个字节的序列号为零，后面每个字节的序列号就会增加一。<br>发送数据时，从发送缓冲区取一部分数据组成发送报文，在其TCP协议头中会附带序列号和长度。接收端在收到数据后需要回复确认报文。<br>确认报文中的ACK等于接收序列号加长度，也就是下一包数据需要发送的基础序列号。<br>这样一问一答的发送方式，能够使发送端确认发送的数据已经被对方收到。<br>发送端也可以一次发送连续的多包数据，接收端只需要回复一次ACK就可以了。<br>这样发送端可以把待发送的数据分割成一系列的碎片，发送到对端。对端根据序列号和长度在接收后重构出来完整的数据。<br>假设其中丢失了某些数据方在接收端可以要求发送端重传。比如丢失了100-199，这一百个字节接收端下发送端发送ACK=100的报文。<br>发送端收到后，重传这一包数据，接收端进行补齐。<br>以上过程不区分客户端和服务端，<strong>TCP连接是全双功能，对于两端来说均采用上述机制。</strong></p><hr><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><img src="https://pic2.zhimg.com/80/v2-6e5f05603526c1d259b300f20b8857a5_720w.jpg" alt="img" style="zoom:200%;" /><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><p><strong>第一次挥手：</strong> 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p><strong>第二次挥手：</strong> 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p><strong>第三次挥手：</strong> 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p><strong>第四次挥手：</strong> 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p><strong>为什么要四次挥手</strong>？</p><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p><strong>为什么客户端需要等待超时时间？</strong></p><p>这是为了保证对方已收到ACK。因为假设客户端发送完最后一包ACK后就释放了连接。一旦ACK在网络中丢失。服务端将一直停留在最后确认状态。</p><p>如果客户端发送最后一个ACK后等待一段时间，这时服务端因为没有收到ACK，会重发FIN。<br>客户端会响应这个分包重发ACK，用刷新超时时间这个机制跟三次握手一样，也是为了<strong>保证在不可靠的网络链路中进行可靠的连接，断开确认。</strong></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP协议是基于非连接的发送数据，就是简单的把数据包封装一下，然后从网卡发出去就可以了。数据包之间并没有状态上的联系。正因为UDP这种简单的处理方式，导致它的性能损耗非常少。对于CPU内存资源的占用也远小于TCP。但是对于网络传输过程中产生的丢包，UDP协议并不能保证。</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-4bcddf13416e9f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="什么时候应该使用TCP？"><a href="#什么时候应该使用TCP？" class="headerlink" title="什么时候应该使用TCP？"></a>什么时候应该使用TCP？</h3><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 </p><h3 id="什么时候应该使用UDP？"><a href="#什么时候应该使用UDP？" class="headerlink" title="什么时候应该使用UDP？"></a>什么时候应该使用UDP？</h3><p>UDP的优点是速度快，但是可能产生丢包。所以适用于对实时性要求较高，但是对少量丢包并没有太大要求的场景，比如域名查询与云通话、视频直播等。</p><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><table><thead><tr><th align="left">端口</th><th align="left">服务</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">21</td><td align="left">FTP</td><td align="left">FTP 服务器所开放的端口，用于上传、下载</td></tr><tr><td align="left">22</td><td align="left">SSH</td><td align="left">22 端口就是 ssh 端口，用于通过命令行模式远程连接 Linux 系统服务器</td></tr><tr><td align="left">25</td><td align="left">SMTP</td><td align="left">SMTP 服务器所开放的端口，用于发送邮件</td></tr><tr><td align="left">80</td><td align="left">HTTP</td><td align="left">用于网站服务例如 IIS、Apache、Nginx 等提供对外访问</td></tr><tr><td align="left">110</td><td align="left">POP3</td><td align="left">110 端口是为 POP3（邮件协议 3）服务开放的</td></tr><tr><td align="left">137/138/139</td><td align="left">NETBIOS</td><td align="left">其中 137、138 是 UDP 端口，当通过网上邻居传输文件时用这个端口。而 139 端口：通过这个端口进入的连接试图获得 NetBIOS/SMB 服务。这个协议被用于 windows 文件和打印机共享和 SAMBA</td></tr><tr><td align="left">143</td><td align="left">IMAP</td><td align="left">143 端口主要是用于“Internet Message AccessProtocol”v2（Internet 消息访问协议，简称 IMAP），和 POP3 一样，是用于电子邮件的接收的协议</td></tr><tr><td align="left">443</td><td align="left">HTTPS</td><td align="left">网页浏览端口，能提供加密和通过安全端口传输的另一种 HTTP</td></tr><tr><td align="left">1433</td><td align="left">SQL Server</td><td align="left">1433 端口，是 SQL Server 默认的端口，SQL Server 服务使用两个端口：TCP-1433、UDP-1434。其中 1433 用于供 SQL Server 对外提供服务，1434 用于向请求者返回 SQL Server 使用了哪个 TCP/IP 端口</td></tr><tr><td align="left">3306</td><td align="left">MySQL</td><td align="left">3306 端口，是 MySQL 数据库的默认端口，用于 MySQL 对外提供服务</td></tr><tr><td align="left">3389</td><td align="left">Windows Server Remote Desktop Services</td><td align="left">3389 端口是 Windows 远程桌面的服务端口，可以通过这个端口，用 “远程桌面” 等连接工具来连接到远程的服务器</td></tr><tr><td align="left">8080</td><td align="left">代理端口</td><td align="left">8080 端口同 80 端口，是被用于 WWW 代理服务的，可以实现网页浏览，经常在访问某个网站或使用代理服务器的时候，会加上 “:8080” 端口号。另外 Apache Tomcat web server 安装后，默认的服务端口就是 8080</td></tr></tbody></table><p>in the end</p><p>转自：brey.cn</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-IP协议&quot;&gt;&lt;a href=&quot;#TCP-IP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议&quot;&gt;&lt;/a&gt;TCP/IP协议&lt;/h1&gt;&lt;h2 id=&quot;TCP-IP-协议的具体含义&quot;&gt;&lt;a href=&quot;#TCP-IP-协议的具体含义&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
