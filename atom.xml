<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xinyuan&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/cb5dd586f32c8841e8838c89301eb7fa</icon>
  <subtitle>鑫缘的blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-05T02:56:23.744Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>鑫缘</name>
    <email>xy_404@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>密码学之实践篇</title>
    <link href="http://example.com/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2021-12-05T02:56:23.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之实践篇"><a href="#密码学之实践篇" class="headerlink" title="密码学之实践篇"></a>密码学之实践篇</h1><h3 id="N1CTF-python-（Feistel网络）"><a href="#N1CTF-python-（Feistel网络）" class="headerlink" title="N1CTF python   （Feistel网络）"></a>N1CTF python   （Feistel网络）</h3><p>题的代码如下</p><p>N1SE.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round_add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    f = <span class="keyword">lambda</span> x, y: x + y - <span class="number">2</span> * (x &amp; y)</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        res += <span class="built_in">chr</span>(f(<span class="built_in">ord</span>(a[i]), <span class="built_in">ord</span>(b[i])))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutate</span>(<span class="params">table, block</span>):</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: block[x], table))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_to_bits</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line">    l = <span class="built_in">len</span>(data) * <span class="number">8</span></span><br><span class="line">    result = [<span class="number">0</span>] * l</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">            result[(pos&lt;&lt;<span class="number">3</span>)+i] = (ch&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">s_box = [<span class="number">54</span>, <span class="number">132</span>, <span class="number">138</span>, <span class="number">83</span>, <span class="number">16</span>, <span class="number">73</span>, <span class="number">187</span>, <span class="number">84</span>, <span class="number">146</span>, <span class="number">30</span>, <span class="number">95</span>, <span class="number">21</span>, <span class="number">148</span>, <span class="number">63</span>, <span class="number">65</span>, <span class="number">189</span>, <span class="number">188</span>, <span class="number">151</span>, <span class="number">72</span>, <span class="number">161</span>, <span class="number">116</span>, <span class="number">63</span>, <span class="number">161</span>, <span class="number">91</span>, <span class="number">37</span>, <span class="number">24</span>, <span class="number">126</span>, <span class="number">107</span>, <span class="number">87</span>, <span class="number">30</span>, <span class="number">117</span>, <span class="number">185</span>, <span class="number">98</span>, <span class="number">90</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">140</span>, <span class="number">70</span>, <span class="number">86</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">150</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">144</span>, <span class="number">153</span>, <span class="number">36</span>, <span class="number">90</span>, <span class="number">149</span>, <span class="number">54</span>, <span class="number">156</span>, <span class="number">8</span>, <span class="number">59</span>, <span class="number">40</span>, <span class="number">110</span>, <span class="number">56</span>,<span class="number">1</span>, <span class="number">84</span>, <span class="number">103</span>, <span class="number">22</span>, <span class="number">65</span>, <span class="number">17</span>, <span class="number">190</span>, <span class="number">41</span>, <span class="number">99</span>, <span class="number">151</span>, <span class="number">119</span>, <span class="number">124</span>, <span class="number">68</span>, <span class="number">17</span>, <span class="number">166</span>, <span class="number">125</span>, <span class="number">95</span>, <span class="number">65</span>, <span class="number">105</span>, <span class="number">133</span>, <span class="number">49</span>, <span class="number">19</span>, <span class="number">138</span>, <span class="number">29</span>, <span class="number">110</span>, <span class="number">7</span>, <span class="number">81</span>, <span class="number">134</span>, <span class="number">70</span>, <span class="number">87</span>, <span class="number">180</span>, <span class="number">78</span>, <span class="number">175</span>, <span class="number">108</span>, <span class="number">26</span>, <span class="number">121</span>, <span class="number">74</span>, <span class="number">29</span>, <span class="number">68</span>, <span class="number">162</span>, <span class="number">142</span>, <span class="number">177</span>, <span class="number">143</span>, <span class="number">86</span>, <span class="number">129</span>, <span class="number">101</span>, <span class="number">117</span>, <span class="number">41</span>, <span class="number">57</span>, <span class="number">34</span>, <span class="number">177</span>, <span class="number">103</span>, <span class="number">61</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">74</span>, <span class="number">69</span>, <span class="number">147</span>, <span class="number">90</span>, <span class="number">49</span>, <span class="number">135</span>, <span class="number">124</span>, <span class="number">106</span>, <span class="number">19</span>, <span class="number">89</span>, <span class="number">38</span>, <span class="number">21</span>, <span class="number">41</span>, <span class="number">17</span>, <span class="number">155</span>, <span class="number">83</span>, <span class="number">38</span>, <span class="number">159</span>, <span class="number">179</span>, <span class="number">19</span>, <span class="number">157</span>, <span class="number">68</span>, <span class="number">105</span>, <span class="number">151</span>, <span class="number">166</span>, <span class="number">171</span>, <span class="number">122</span>, <span class="number">179</span>, <span class="number">114</span>, <span class="number">52</span>, <span class="number">183</span>, <span class="number">89</span>, <span class="number">107</span>, <span class="number">113</span>, <span class="number">65</span>, <span class="number">161</span>, <span class="number">141</span>, <span class="number">18</span>, <span class="number">121</span>, <span class="number">95</span>, <span class="number">4</span>, <span class="number">95</span>, <span class="number">101</span>, <span class="number">81</span>, <span class="number">156</span>, <span class="number">17</span>, <span class="number">190</span>, <span class="number">38</span>, <span class="number">84</span>, <span class="number">9</span>, <span class="number">171</span>, <span class="number">180</span>, <span class="number">59</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">34</span>, <span class="number">89</span>, <span class="number">75</span>, <span class="number">164</span>, <span class="number">190</span>, <span class="number">140</span>, <span class="number">6</span>, <span class="number">41</span>, <span class="number">188</span>, <span class="number">77</span>, <span class="number">165</span>, <span class="number">105</span>, <span class="number">5</span>, <span class="number">107</span>, <span class="number">31</span>, <span class="number">183</span>, <span class="number">107</span>, <span class="number">141</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">125</span>, <span class="number">50</span>, <span class="number">2</span>, <span class="number">153</span>, <span class="number">156</span>, <span class="number">162</span>, <span class="number">186</span>, <span class="number">76</span>, <span class="number">158</span>, <span class="number">153</span>, <span class="number">117</span>, <span class="number">9</span>, <span class="number">77</span>, <span class="number">156</span>, <span class="number">11</span>, <span class="number">145</span>, <span class="number">12</span>, <span class="number">169</span>, <span class="number">52</span>, <span class="number">57</span>, <span class="number">161</span>, <span class="number">7</span>, <span class="number">158</span>, <span class="number">110</span>, <span class="number">191</span>, <span class="number">43</span>, <span class="number">82</span>, <span class="number">186</span>, <span class="number">49</span>, <span class="number">102</span>, <span class="number">166</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">5</span>, <span class="number">189</span>, <span class="number">27</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">o</span>):</span></span><br><span class="line">    k = permutate(s_box,o)</span><br><span class="line">    b = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(k), <span class="number">7</span>):</span><br><span class="line">        b.append(k[i:i+<span class="number">7</span>] + [<span class="number">1</span>])</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> b[i]:</span><br><span class="line">x += (j&lt;&lt;pos)</span><br><span class="line">pos += <span class="number">1</span></span><br><span class="line">c.append((<span class="number">0x10001</span>**x) % (<span class="number">0x7f</span>))</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">N1ES</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(key) != <span class="number">24</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(key, <span class="built_in">bytes</span>) == <span class="literal">False</span> ):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;key must be 24 bytes long&quot;</span>)</span><br><span class="line">        self.key = key</span><br><span class="line">        self.gen_subkey()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_subkey</span>(<span class="params">self</span>):</span></span><br><span class="line">        o = string_to_bits(self.key)</span><br><span class="line">        k = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        o = generate(o)</span><br><span class="line">        k.extend(o)</span><br><span class="line">        o = string_to_bits([<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> o[<span class="number">0</span>:<span class="number">24</span>]])</span><br><span class="line">        self.Kn = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            self.Kn.append(<span class="built_in">map</span>(<span class="built_in">chr</span>, k[i * <span class="number">8</span>: i * <span class="number">8</span> + <span class="number">8</span>]))</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">self, plaintext</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(plaintext) % <span class="number">16</span> != <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(plaintext, <span class="built_in">bytes</span>) == <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;plaintext must be a multiple of 16 in length&quot;</span>)</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext) / <span class="number">16</span>):</span><br><span class="line">            block = plaintext[i * <span class="number">16</span>:(i + <span class="number">1</span>) * <span class="number">16</span>]</span><br><span class="line">            L = block[:<span class="number">8</span>]</span><br><span class="line">            R = block[<span class="number">8</span>:]</span><br><span class="line">            <span class="keyword">for</span> round_cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                L, R = R, (round_add(L, self.Kn[round_cnt]))</span><br><span class="line">            L, R = R, L</span><br><span class="line">            res += L + R</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>challenge.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> N1ES <span class="keyword">import</span> N1ES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;wxy191iss00000000000cute&quot;</span></span><br><span class="line">n1es = N1ES(key)</span><br><span class="line">flag = <span class="string">&quot;N1CTF&#123;*****************************************&#125;&quot;</span></span><br><span class="line">cipher = n1es.encrypt(flag)</span><br><span class="line"><span class="built_in">print</span> base64.b64encode(cipher)  <span class="comment"># HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx</span></span><br></pre></td></tr></table></figure><p>python2的代码，但是电脑没有python2的环境  ，期初想就是不下，宁愿py2转py3我都不去下py2 ，后面我发现我错了，python2转为python3之后bug不是我能预料到的，遂乖乖下载了py2，开整。</p><p>开始调试，debug功能告诉我，首先调用这个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_to_bits</span>(<span class="params">data</span>):</span></span><br><span class="line">    data = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line">    l = <span class="built_in">len</span>(data) * <span class="number">8</span></span><br><span class="line">    result = [<span class="number">0</span>] * l</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">            result[(pos&lt;&lt;<span class="number">3</span>)+i] = (ch&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def encrypt(self, plaintext):</span><br><span class="line">    if (len(plaintext) % 16 != 0 or isinstance(plaintext, bytes) == False):</span><br><span class="line">        raise Exception(&quot;plaintext must be a multiple of 16 in length&quot;)</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    for i in range(len(plaintext) / 16):</span><br><span class="line">        block = plaintext[i * 16:(i + 1) * 16]</span><br><span class="line">        L = block[:8]</span><br><span class="line">        R = block[8:]</span><br><span class="line">        for round_cnt in range(32):</span><br><span class="line">            L, R = R, (round_add(L, self.Kn[round_cnt]))</span><br><span class="line">        L, R = R, L</span><br><span class="line">        res += L + R</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure><p>我们由分组密码可知，这是一个很明显的Feistel结构，Feistel结构的特点就是加密与解密过程大体一致，及将密钥倒过来，就可以成功获取到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在challenge.py添加如下代码：</span><br><span class="line">s1=base64.b64decode(&#x27;HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx&#x27;)</span><br><span class="line">flag = n1es.decrypt(s1)</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">构造解密的函数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">self, plaintext</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(plaintext) % <span class="number">16</span> != <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(plaintext, <span class="built_in">bytes</span>) == <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;plaintext must be a multiple of 16 in length&quot;</span>)</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext) / <span class="number">16</span>):</span><br><span class="line">            block = plaintext[i * <span class="number">16</span>:(i + <span class="number">1</span>) * <span class="number">16</span>]</span><br><span class="line">            L = block[:<span class="number">8</span>]</span><br><span class="line">            R = block[<span class="number">8</span>:]</span><br><span class="line">            <span class="keyword">for</span> round_cnt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                L, R = R, (round_add(L, self.Kn[<span class="number">31</span>-round_cnt]))</span><br><span class="line">            L, R = R, L</span><br><span class="line">            res += L + R</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之实践篇&quot;&gt;&lt;a href=&quot;#密码学之实践篇&quot; class=&quot;headerlink&quot; title=&quot;密码学之实践篇&quot;&gt;&lt;/a&gt;密码学之实践篇&lt;/h1&gt;&lt;h3 id=&quot;N1CTF-python-（Feistel网络）&quot;&gt;&lt;a href=&quot;#N1CTF-pyt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学之理论篇（分组密码体制）</title>
    <link href="http://example.com/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/"/>
    <id>http://example.com/2021/12/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%EF%BC%89/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2021-12-07T12:41:25.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇（分组密码体制）"><a href="#密码学之理论篇（分组密码体制）" class="headerlink" title="密码学之理论篇（分组密码体制）"></a>密码学之理论篇（分组密码体制）</h1><h1 id="四、分组密码体制"><a href="#四、分组密码体制" class="headerlink" title="四、分组密码体制"></a>四、分组密码体制</h1><h3 id="分组密码学的基本概念"><a href="#分组密码学的基本概念" class="headerlink" title="分组密码学的基本概念"></a>分组密码学的基本概念</h3><p>分组密码：</p><p>1、一个0、1分组一个0、1分组进行加密（不是一个比特一个比特进行加密）；</p><p>2、不同的分组利用同一个密钥进行加密；</p><p>3、还有个分组密码工作模式的问题，这章稍后会学。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">明文分组长度为n bit，密文分组长度m bit，若n&gt;m , 明文分组长度大于密文分组长度，称其为有数据压缩的分组密码;若n&lt;m,明文分组长度小于密文分组长度，称之为有数据扩展的分组密码；若n=m，明文分组等于密文分组长度，则称之为无数据扩展和压缩的分组密码，事实上，通常的分组密码均取n=m</span><br></pre></td></tr></table></figure><h3 id="分组密码的原理"><a href="#分组密码的原理" class="headerlink" title="分组密码的原理"></a>分组密码的原理</h3><p>香农提出了设计密码系统的两个基本方法——-扩散和混淆。目的是抗击攻击者对密码系统的统计分析。</p><h4 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h4><p>​    扩散的含义是将明文和密钥的统计特性散步到密文中去，是的明文和密钥每一比特在密文中得到充分扩散，是的密文不在显示任何形式的规律。</p><p><strong>扩散使得明文和密钥的每一位都影响密文中多位的值</strong></p><p>（扩散属于线性变换，差不多相当于“洗牌”</p><h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p>​    混淆的含义是使密文和对应的明文与密钥之间的统计关系变得尽可能复杂，使得攻击者无法得到密文和明文及密钥之间的统计规律。</p><p>在分组密码中，对数据重复执行某个s盒变换（非线性变换），可获得混淆。</p><p>扩散和混淆是分组密码的最本质的操作，是设计分组密码的基础。</p><h4 id="代替-置换网络（s-p结构）"><a href="#代替-置换网络（s-p结构）" class="headerlink" title="代替-置换网络（s-p结构）"></a>代替-置换网络（s-p结构）</h4><p>大多数分组密码同时使用代替-置换网络以达到混淆和扩散的目标。</p><p>​    代替-置换网络（s-p网络）是由多重非线性代替（S）和比特置换（P）构成，s代替起到混淆的作用，P置换起到扩散的作用。</p><p><img src="https://img-blog.csdnimg.cn/ffc3c8a97341430e9e07b2e20f8cf182.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P置换差不多相当于是 一次“广义的洗牌”：</span><br><span class="line"></span><br><span class="line">有可能 牌的张数 前后保持不变；</span><br><span class="line"></span><br><span class="line">也可能  洗完牌 被抽出去了几张牌，总牌数变少了；</span><br><span class="line"></span><br><span class="line">也可能 把部分牌“复制”了一下，又把它们“粘贴”到</span><br><span class="line"></span><br><span class="line">原来那摞牌中，这样总牌数就增多了。</span><br></pre></td></tr></table></figure><p>相当于s盒对明文分块加密，p进行一次洗牌，然后s盒再去加密，循环。</p><p>从b站找了一个例子，对其进行一波解析。</p><p><img src="https://img-blog.csdnimg.cn/b3249f18e7494e21beaf547954c1a531.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一段sp网络的加密 </span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">text=<span class="string">&quot;C# was developed around 2000 by Microsoft as part of its .NET initiative and later approved as an international standard by Ecma (ECMA-334) in 2002 and ISO (ISO/IEC 23270) in 2003. &quot;</span></span><br><span class="line">binarylist = [ <span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  <span class="built_in">list</span>(text.lower().encode(<span class="string">&#x27;utf-8&#x27;</span>))]    <span class="comment">#lowe()将大写转换为小写  zfill()指定返回的长度  一个utf-8 一个字节，故保留了8个bit</span></span><br><span class="line">plaintext = <span class="string">&quot;&quot;</span>.join(binarylist)    <span class="comment">#将字符串进行拼接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">length = <span class="number">16</span>     <span class="comment"># total bits = 8*length</span></span><br><span class="line">plaintext = plaintext[<span class="number">0</span>: <span class="number">8</span>*length]</span><br><span class="line">master = <span class="string">&quot;&quot;</span>.join(<span class="built_in">str</span>(random.randint(<span class="number">0</span>,<span class="number">1</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)))    <span class="comment">#根据plantext的长度随机生成一串01字符串，暂且称其为密钥，但这里是随机生成的128bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build a bijective table     所谓的s盒</span></span><br><span class="line">y = [<span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>)]</span><br><span class="line">random.shuffle(y)</span><br><span class="line">sbox = &#123;<span class="built_in">format</span>(i, <span class="string">&#x27;b&#x27;</span>).zfill(<span class="number">8</span>):y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>)&#125;</span><br><span class="line"><span class="comment"># build permutation table       p盒</span></span><br><span class="line">y = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">random.shuffle(y)           <span class="comment">#分配算法利用了shuffle</span></span><br><span class="line">ptable = &#123;i:y[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)&#125;</span><br><span class="line"></span><br><span class="line">code = plaintext</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    code = <span class="string">&quot;&quot;</span>.join( <span class="string">&quot;0&quot;</span> <span class="keyword">if</span> code[i] == master[i] <span class="keyword">else</span> <span class="string">&quot;1&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plaintext)))  <span class="comment">#进行一波异或操作，将明文通过</span></span><br><span class="line">    temp = [sbox[code[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    <span class="comment"># 每8个字符划分成一组加密</span></span><br><span class="line">    slist = [temp[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length) ]</span><br><span class="line">    code = <span class="string">&quot;&quot;</span>.join(slist)</span><br></pre></td></tr></table></figure><p>这里没有写密钥去定义s盒的部分，如果能够通过密钥去定义s盒，然后通过p盒对密文分组进行分发，可以起到一个很好的效果。        peace~</p><h4 id="Feitel密码结构"><a href="#Feitel密码结构" class="headerlink" title="Feitel密码结构"></a>Feitel密码结构</h4><p>主密钥生成一个子密钥集，每个阶段使用一个子密钥，明文首先分为左右两部分，分别记为L<sub>0</sub>和R<sub>0</sub> ,在进行完r轮迭代之后，左右两半合并在一起在产生密文，每轮迭代的运算逻辑关系</p><p>L<sub>i</sub>=R<sub>i-1</sub></p><p>R<sub>i</sub>=L<sub>i-1</sub>⊕F(R<sub>i-1</sub> , K<sub>i</sub>)</p><p>其中，K<sub>i</sub>表示第i轮用的子密钥，F表示轮函数</p><img src="https://static.oschina.net/uploads/img/201610/17141512_yJxg.jpg" alt="一轮" style="zoom:50%;" /><p>喻：制作葱油饼</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Feistel密码结构的另外一个显著的特点就是其逆向操作和正向操作是指具有相同的结构，二者唯一的不同就是子密钥使用次序不同。</p><p>（很有趣，利用异或的可逆性）</p><p>采用Feistel密码结构设计分组密码算法时，加解密可采用同一种算法。</p><p><img src="https://static.oschina.net/uploads/img/201610/17142027_eJ9Q.jpg" alt="输入图片说明"></p><p>贴一个 利用feitel网络设计的密码，类DES</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strEncrypt</span>(<span class="params">s1, s2, key</span>):</span>  <span class="comment"># 每次传输8个字符,分成两组按位异或,密钥4个字符</span></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">        temp = <span class="built_in">ord</span>(s1[i]) ^ <span class="built_in">ord</span>(s2[i]) ^ <span class="built_in">ord</span>(key[i])</span><br><span class="line">        result += <span class="built_in">chr</span>(temp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">plainText, keylist</span>):</span></span><br><span class="line">    cipherText = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(plainText) // <span class="number">8</span>):</span><br><span class="line">        temp = plainText[i * <span class="number">8</span>:(i + <span class="number">1</span>) * <span class="number">8</span>]  <span class="comment"># 每8个字符划分成一组加密</span></span><br><span class="line">        L = temp[:<span class="number">4</span>]</span><br><span class="line">        R = temp[<span class="number">4</span>:]</span><br><span class="line">        <span class="keyword">for</span> currentKey <span class="keyword">in</span> keylist:</span><br><span class="line">            temp2 = R</span><br><span class="line">            R = strEncrypt(L, R, currentKey)</span><br><span class="line">            L = temp2</span><br><span class="line">        cipherText += R + L</span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    key = []</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&#x27;请输入要加密的字符串，目前算法能处理的明文字符为8的整数倍&#x27;</span>)</span><br><span class="line">    keynum = <span class="built_in">input</span>(<span class="string">&#x27;请输入加密循环次数&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(keynum)):</span><br><span class="line">        temp = <span class="built_in">input</span>(<span class="string">&#x27;请输入第&#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27;组加密时使用的密钥（4个字符）&#x27;</span>)</span><br><span class="line">        key.append(temp)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;要加密的明文为：&#x27;</span>, a)</span><br><span class="line">    a = encode(a, key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;密文：&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#####解密</span></span><br><span class="line">    key.reverse()           <span class="comment">#倒序输出</span></span><br><span class="line">    a = encode(a, key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;解密后的明文：&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>此处推荐去查看密码学之实践篇  N1CTF (python)</p><h3 id="DES算法概述"><a href="#DES算法概述" class="headerlink" title="DES算法概述"></a>DES算法概述</h3><h4 id="DES算法概述-1"><a href="#DES算法概述-1" class="headerlink" title="DES算法概述"></a>DES算法概述</h4><p>数据加密标准(Data Encryption Standard,DES)，于1997年1月15日由美国国家标准局（NBS）正式发布实施，是第一公开的商用密码算法标准，但随着密码分析技术和计算能力的提高，DES算法不在安全，在2000年，DES算法已被更为安全AES算法取代。</p><p>（DES的最主要问题是密钥长度太短，特别是有效密钥长度太短了（<strong>56比特</strong>）。以现在的计算能力，可以用密钥穷举攻击破解DES。给定一密文，算法已知，尝试利用所有的密钥对密文进行解密，若能解密出一个实际意义的明文，则所用密钥记为有效密钥。但其实这也好办，多加密几次，难度成指数级增长，咋可能解，套！）</p><p>​    DES算法是一种典型的Feistel结构的分组密码算法，它的明文分组长度为64bit，密钥长度为64bit，其中密钥有8bit是奇偶校验，因此有效密钥长度为56bit。DES算法的加密和解密采用同一过程，它的安全性依赖于有效密钥。DES算法首先把需要加密的明文划分为每64bit的数据块，用56bit有效密钥和64bit数据块加密。</p><p>DES算法，运算速度快。</p><h4 id="DES-算法描述"><a href="#DES-算法描述" class="headerlink" title="DES 算法描述"></a>DES 算法描述</h4><h5 id="初始置换（IP）"><a href="#初始置换（IP）" class="headerlink" title="初始置换（IP）"></a>初始置换（IP）</h5><p>DES会对用户输入进行处理，称为<strong>初始置换</strong></p><p>首先将输入的64bit的明文块，进行置换。</p><p>即将用户输入的明文的第58位会成为这个过程的结果IP的第一位，以此类推。</p><table><thead><tr><th>58</th><th>50</th><th>42</th><th>34</th><th>26</th><th>18</th><th>10</th><th>2</th></tr></thead><tbody><tr><td>60</td><td>52</td><td>44</td><td>36</td><td>28</td><td>20</td><td>12</td><td>4</td></tr><tr><td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td><td>14</td><td>6</td></tr><tr><td>64</td><td>56</td><td>48</td><td>40</td><td>32</td><td>24</td><td>16</td><td>8</td></tr><tr><td>57</td><td>49</td><td>41</td><td>33</td><td>25</td><td>17</td><td>9</td><td>1</td></tr><tr><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td></tr><tr><td>61</td><td>53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td></tr><tr><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td></tr></tbody></table><p>完成上述步骤，IP被分为等长的两部分，就可以获得初始的L 和R的值。</p><h5 id="subkey的生成（密钥置换）"><a href="#subkey的生成（密钥置换）" class="headerlink" title="subkey的生成（密钥置换）"></a>subkey的生成（密钥置换）</h5><p>不考虑每个字节的第8位，DES的密钥由64位减至56位，每个字节的第8位作为奇偶校验位。产生的56位密钥由下表生成（注意表中没有8,16,24，32,40,48,56和64这8位）：</p><table><thead><tr><th>57</th><th>49</th><th>41</th><th>33</th><th>25</th><th>17</th><th>9</th><th>1</th><th>58</th><th>50</th><th>42</th><th>34</th><th>26</th><th>18</th></tr></thead><tbody><tr><td>10</td><td>2</td><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td><td>60</td><td>52</td><td>44</td><td>36</td></tr><tr><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td><td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td></tr><tr><td>14</td><td>6</td><td>61</td><td>53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td><td>28</td><td>20</td><td>12</td><td>4</td></tr></tbody></table><p>在DES的每一轮中，从56位密钥产生出不同的48位子密钥，确定这些子密钥的方式如下：</p><p>　　1).将56位的密钥分成两部分，每部分28位。</p><p>　　2).根据轮数，这两部分分别循环左移1位或2位。每轮移动的位数如下表：</p><table><thead><tr><th>轮数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>位数</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td></tr></tbody></table><p>移动一次产生一组密钥。共产生了16组。　　</p><p>移动后，从56位中选出48位。这个过程中，既置换了每位的顺序，又选择了子密钥，因此称为压缩置换。压缩置换规则如下表（注意表中没有9，18，22，25，35，38，43和54这8位）：</p><table><thead><tr><th>14</th><th>17</th><th>11</th><th>24</th><th>1</th><th>5</th><th>3</th><th>28</th><th>15</th><th>6</th><th>21</th><th>10</th></tr></thead><tbody><tr><td>23</td><td>19</td><td>12</td><td>4</td><td>26</td><td>8</td><td>16</td><td>7</td><td>27</td><td>20</td><td>13</td><td>2</td></tr><tr><td>41</td><td>52</td><td>31</td><td>37</td><td>47</td><td>55</td><td>30</td><td>40</td><td>51</td><td>45</td><td>33</td><td>48</td></tr><tr><td>44</td><td>49</td><td>39</td><td>56</td><td>34</td><td>53</td><td>46</td><td>42</td><td>50</td><td>36</td><td>29</td><td>32</td></tr></tbody></table><p>​     置换方法同上，此处省略。</p><p>根据此表，在知道一组C<sub>1</sub>和D<sub>1</sub>的情况下可以反推出K1</p><h5 id="轮结构"><a href="#轮结构" class="headerlink" title="轮结构"></a>轮结构</h5><p><img src="https://img-blog.csdnimg.cn/a8073c7b5a4b46d6831fd1cab1c448c0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_10,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>每一轮变换由下面公式</p><p>L<sub>i</sub>=R<sub>i-1</sub></p><p>R<sub>i</sub> = L<sub>i-1 </sub>⊕F (R<sub>i-1</sub> , K<sub>i</sub>)</p><p>经过一轮IP置换之后得到输出64 bit，可以进入16轮的轮变换 ，轮变换即传统的Feistel结构，先将其拆分成两个32 bit，然后进入E函数，后进入S盒进行置换</p><p>(1)每轮置换会进入E函数并拓展成48位，就是索引拓展，</p><table><thead><tr><th>32</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td></tr><tr><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td></tr><tr><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td></tr><tr><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td></tr><tr><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td></tr><tr><td>28</td><td>29</td><td>30</td><td>31</td><td>32</td><td>1</td></tr></tbody></table><p>（2）完成拓展后会与subkeys进行异或操作，得到48bit数据。</p><p>（3）48bit的数据被分为8组，每组6bit，分别进入8个s盒进行压缩，最终输出32bit</p><p><strong>注：S盒代替是DES算法唯一的非线性变换，是保证DES算法安全性的源泉 （s盒作用混淆）</strong></p><p>一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数。S盒的6个输入确定了其对应的输出在哪一行哪一列，输入的高低两位做为行数H，中间四位做为列数L，在S-BOX中查找第H行L列对应的数据(&lt;32)。</p><p><img src="https://img-blog.csdnimg.cn/a17e98f294ca4d5cb9de1f89678fc017.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>例如，假设S盒8的输入为110011，第1位和第6位组合为11，对应于S盒8的第3行；第2位到第5位为1001，对应于S盒8的第9列。S盒8的第3行第9列的数字为12，因此用1100来代替110011。注意，S盒的行列计数都是从0开始。代替过程产生8个4位的分组，组合在一起形成32位数据。</p><h4 id="DES的各种变形算法"><a href="#DES的各种变形算法" class="headerlink" title="DES的各种变形算法"></a>DES的各种变形算法</h4><p>只有56bit有效密钥长度的DES算法不再是安全的，目前DES算法已被更为安全的高级加密标准（AES算法）取代。另外一种替代DES的方式是将DES算法在多密钥下多重使用，如二重DES、3DES等DES变形算法</p><h5 id="二重DES"><a href="#二重DES" class="headerlink" title="二重DES"></a>二重DES</h5><p>对明文加密不是使用一个密钥，而采用两个互不相同的密钥K<sub>1</sub>和K<sub>2</sub>进行连续加密，因此二重DES的有效密钥长度实际为112bit  ，其安全强度得到了极大的提升。</p><p>即</p><p><img src="https://img-blog.csdnimg.cn/20200223103519611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODI4NzM4,size_16,color_FFFFFF,t_70" alt="img"></p><p>因此密钥破解难度从 2<sup>56</sup> 变成 2<sup>112</sup></p><h5 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h5><img src="https://img-blog.csdnimg.cn/105df0b3b1f24e5a82559d0a31e0900a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><img src="https://img-blog.csdnimg.cn/6eb8f4a1b6fd447b86c8494b6854b0c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/86237374e4a54d2d8821c62c527fd134.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/401ba6c3049542388b92495873254083.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>AES（Advanced Encryption Standard）又称为Rijndael加密法</p><p>2000年10月Rijndael凭借其安全性、高效率、可实现和使用灵活等优点成为美国新的高级加密标准(AES)，这一标准的问世取代了DES数据加密标准成为21世纪保护敏感信息的高级加密算法。</p><p>Rijndael算法的设计者是两位比利时的密码专家Joan Daemen 博士和Vincent Rijmen博士</p><h4 id="AES算法描述"><a href="#AES算法描述" class="headerlink" title="AES算法描述"></a>AES算法描述</h4><p>Rijndael是一种使用灵活的、明文分组长度可变、密钥长度也可变的分组密码算法。明文分组长度和密钥长度彼此独立地确定为128/192/256 bit，因而Rijndael算法可以有9种不同的版本。</p><p><img src="https://img-blog.csdnimg.cn/cfcd1361e97b44aeb4a4b05bce3ebfd5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>NIST选中Rijndael算法作为AES算法，限定了明文分组为128bit，而密钥长度为128、192 、256 bit，因而AES有三个版本：AES-128、 AES-192、 AES-256，相应的迭代轮数为10轮、12轮、14轮</p><p>AES的基本运算单位是Byte</p><h5 id="AES加密过程"><a href="#AES加密过程" class="headerlink" title="AES加密过程"></a>AES加密过程</h5><p><img src="https://img-blog.csdnimg.cn/a5f7058194274ff8b7f86c8f4cab60f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>（1）AddRoundKey：矩阵中的每字节都与该回合密钥（round key）做XOR运算，每个子密钥由密钥生成方案产生。</p><p>（2）SubBytes：透过一个非线性的替换函数，用查找表的方式把每字节替换成对应字节。</p><p>（3）ShifRows：将矩阵中的每个横列进行循环式移位。</p><p>（4）MixColumns：充分混合矩阵中各列的操作，使用线性转换混合每列的4字节，最后一个加密循环中省略本步骤，而以AddRoundKey</p><p><img src="https://img-blog.csdnimg.cn/f3dd942a56344ad89b0c1407fc15afbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有限域（Finite Field）是包含有限个元素的域，可以简单理解为包含有限个元素的集合，其中可以对包含的元素执行加、减、乘、除等操作。</span><br><span class="line">在密码学中，有限域GF(p)是一个重要的域，其中p为素数。简单来说，GF(p)=mod p,因为一个数对p取模后，结果肯定在[0,p-1]区间内。对于域中的元素a和b，(a+b) mod p和(a*b) mod p的结果都是域中的元素。GF(p)中的加法和乘法与一般的加法和乘法相同，只是模上了p，但减法和除法利用其负元素进行运算。任意元素a∈GF(g)有乘法逆元素a和加法负元素-a，使得α*(a^-1)=e和 a+(-a)=0。</span><br></pre></td></tr></table></figure><h4 id="Rijndael密钥生成"><a href="#Rijndael密钥生成" class="headerlink" title="Rijndael密钥生成"></a>Rijndael密钥生成</h4><p>AES的加密过程中用到的并不是输入的128~256位的短密钥，而是基于该短密钥生成的一系列子密钥，通过原密钥生成子密钥的算法称为 Rijndael密钥生成方案（Rijndael KeySchedule)。每轮中，数据都需要与128位的子密钥异或，根据原始密钥生成各轮子密钥的过程是由Rijndael密钥生成方案完成的。</p><p><img src="https://img-blog.csdnimg.cn/67b52402adc7445ab1a3b82122978422.png" alt="img"></p><p>先取出最后一行|17 e2 b8 70|，进行循环左移，变为|e2 b87017l，再对S盒进行索引，变为|cd 36 ee 77。然后，把第一位与Rcon数组中的第一个元素异或操作，Rcon是一个预先定义好的数组，其中的第i项是2在GF(2^8)下的i-1次方。</p><p>GF(2^8)扩展域下的运算与GF(2)的同理，在扩展域中，把一个数看成一个7次多项式:</p><p>多项式:x6+A+x+1      二进制:{01010011}           十进制:{53}</p><p>可以看到，多项式中每个系数相当于二进制中对应的位，所以可以把GF(8)下的运算直接转换成多项式之间的运算。但是运算的结果可能超过255，所以需要对这些超过范围的数进行化简。在之前讲的GF(2)中，直接把结果对2取模，但在拓展域中直接规定了一个多项式，两个多项式相乘的结果直接对该多项式取模即可。在AES中采用了以下多项式:</p><p>p(x)= x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1</p><p>Rcon第9项可以用如下方法来计算:</p><p>x<sup>8</sup>=p(x)+x<sup>4</sup>+x<sup>3</sup>+x+1      —&gt;    x<sup>8</sup>≡(x<sup>4</sup>+x<sup>3</sup>+x+1 )mod p(x)</p><p>所以第9项对应的多项式为x<sup>4</sup>+x<sup>3</sup>+x+1，换算成十进制数就是27。</p><p>这样得到Rcon数组中的每一项，对于之前得到的数据|cd 36 ee 77|，将其第1位与Rcon[1]进行异或操作，得到|cc 36 ee 77|，将这组与第一行的数据| 5a 55 57 20|进行异或,就可以得到下一轮子密钥的第一行|96 63 b9 57|了。</p><p>接下来，第二轮子密钥的第2行等于第二轮子密钥的第1行与第一轮子密钥的第2行进行异或操作的结果。第二轮第3行和第4行的密钥也一样，详细的步骤见图7-3-8。</p><p>最后经过10轮运算，就可以得到AES 每轮所使用的子密钥了。</p><p><img src="https://img-blog.csdnimg.cn/0800330c5fb84e0b967856373f71502f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h4 id="基本变换"><a href="#基本变换" class="headerlink" title="基本变换"></a>基本变换</h4><p>AES算法中，加密和解密操作都是在一个4*4的字节矩阵上运作，这个矩阵称为状态</p><p>AES算法中初始状态矩阵由1组长度为128bit 明文分组构成，以字节为单位，则总共有16byte，记为B<sub>0</sub> , B<sub>1</sub> , B<sub>2</sub> , …. , B<sub>14</sub> , B<sub>15</sub> 。从左到右开始，则前4个字节组成明文状态矩阵第1阵，后四个字节组成第2列，依此类推。</p><p><img src="https://img-blog.csdnimg.cn/16313432c476407b9033dcd024a4cb31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h4 id="字节代替（SubBytes）"><a href="#字节代替（SubBytes）" class="headerlink" title="字节代替（SubBytes）"></a>字节代替（SubBytes）</h4><p>Rijndael算法的字节代替（SubBytes）使用一个S盒进行非线性置换，S盒是一个16*16的矩阵，字节代替将输入的状态矩阵的每一个字节通过一个简单查表操作映射为另外一个字节。映射方法是：输入字节的前4bit指定S盒的行值，后4bit指定S盒的列值，行和列所确定S盒位置的元素作为输出，例如输入字节“03”，行值为0，列值为3。可知第0行和第3列对应的值为“7B”，因此输出字节为”7B“。</p><p>s盒是非线性变换</p><p><img src="https://img-blog.csdnimg.cn/4b5ebf71a2f4457fbfe7b66768f89a34.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><p>AES密码算法采用的是S-P网络结构，加密过程与解密过程</p><p>(行移位 事实上也是一种置换（p），相当于是“洗牌”。)</p><img src="https://img-blog.csdnimg.cn/d5fffd0300cd49a8ae14987ad9434ff0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 80%;" /><h3 id="SM4加密算法"><a href="#SM4加密算法" class="headerlink" title="SM4加密算法"></a>SM4加密算法</h3><h4 id="SM4描述"><a href="#SM4描述" class="headerlink" title="SM4描述"></a>SM4描述</h4><p>中国国家密码管理局于2006年1月6日发布第7号公告，将我国无线局域网产品的加密算法确定为SM4算法。这是国内官方公布的<strong>第一个商用算法</strong>。（国密算法）</p><p>SM4是一个分组算法。该算法的分组长度为128比特，密钥长度为128比特。加密算法与密钥扩展算法都采用32轮非线性迭代结构。解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p><p>SM4算法采用的基本运算：异或和循环左移等。</p><h4 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h4><p>SM4算法采用以下基本运算：</p><p>（1）⊕                        表示32bit异或</p><p>（2）&lt;&lt;&lt;i                    表示32bit循环左移i位</p><p>2.轮函数F</p><p>SM4算法采用非线性迭代结构，以字（32bit）为单位。</p><p>1）合成置换 T</p><p>2)非线性变换 t</p><p>t是由4个并行的s盒代替构成，为固定的8bit输入盒8bit输出的代替，记为Sbox()</p><p><img src="https://img-blog.csdnimg.cn/170f10a8f9c74655a4904c1a28c51a4e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>S盒的代替规则：输入的前4位为行号，后4位为列号，行列交叉处S盒列表中的数值为输出。例如输入“2a”，则行号“2”，列号“a”，第二行第a列输出值为“0b”，</p><img src="https://img-blog.csdnimg.cn/f6981d10fafc43049dfa42a599a6ab38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" /><h3 id="其他类型的分组密码体制简介"><a href="#其他类型的分组密码体制简介" class="headerlink" title="其他类型的分组密码体制简介"></a>其他类型的分组密码体制简介</h3><h4 id="国际数据加密算法（IDEA）"><a href="#国际数据加密算法（IDEA）" class="headerlink" title="国际数据加密算法（IDEA）"></a>国际数据加密算法（IDEA）</h4><p>IDEA是X.J.Lai（来学嘉）和Massey在1990年提出，IDEA算法硬件和软件实现都很容易且比DES的实现速度更快。从它提出至今，还未发现明显的弱点，对密码分析具有很强的抵抗能力，在多种商业产品中被使用。</p><p>IDEA算法分组长度为64bit，密钥长度128bit</p><h5 id="基本运算-1"><a href="#基本运算-1" class="headerlink" title="基本运算"></a>基本运算</h5><p>IDEA算法整个运算过程全部在16bit子块上进行。</p><p>⊕：表示16bit的逐位异或。</p><p><img src="https://img-blog.csdnimg.cn/2dbb8feea29d4a51853ead90326f1e2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h5 id="加密算法流程"><a href="#加密算法流程" class="headerlink" title="加密算法流程"></a>加密算法流程</h5><p>IDEA算法一组明文是64 bit，首先被划分为4个子块X<sub>0</sub>、X<sub>1</sub>、X<sub>3</sub>、X<sub>4</sub>，每个子块16 bit。然后将4个16 bit子块作为算法第1轮输入，进行迭代运算。每一轮运算有4个16 bit子块和6个16 bit子密钥块参与运算，相互之间进行异或、相加、相乘，最后输出4个16 bit的子块，作为下一轮的输入。总共迭代8次，得到4个16 bit子块，再与4个 16 bit子密钥进行输出变换，最终得到64 bit密文Y<sub>1</sub>，Y<sub>1</sub>,Y<sub>2</sub>，Y<sub>3</sub> 。</p><img src="https://bkimg.cdn.bcebos.com/pic/b7fd5266d0160924ab18b2d4744f22fae6cd7a899eee?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxNTA=,g_7,xp_5,yp_5/format,f_auto" alt="img" style="zoom:67%;" /><h3 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h3><p>即使有了安全的分组密码算法，也需要采用恰当的工作模式来隐蔽明文的统计特性、数据格式等</p><p>五种运行模式：电子码本（ECB）、密码分组链接（CBC）、计数器（CTR）、输出反馈（OFB）、密码反馈（CFB），任何分组密码算法都可以根据不同的应用场合选择使用其中一种模式。</p><h5 id="ECB（电子码本）模式"><a href="#ECB（电子码本）模式" class="headerlink" title="ECB（电子码本）模式"></a>ECB（电子码本）模式</h5><p>ECB模式是最简单的模式，每个分组用同一密钥加密，同样明文分组得到相同的密文。</p><p><img src="https://pic4.zhimg.com/80/v2-4dad7796144001832bc946fa69526ccb_720w.jpg" alt="img"></p><p>ECB模式的特性：</p><p>（1）在给定的密钥下，同意明文组总产生同样的密文组。</p><p>（2）各组的加密独立于其他分组。</p><p>（3）无错误传播。单个密文分组中有一个或多个比特错误只会影响该分组的解密结果。</p><p>（4）安全性有限。由于同一明文产生同样的密文，这回暴露明文数据的格式和统计特征。</p><p>当消息长度超过一个组或者重复使用密钥加密多个单组消息，不建议使用ECB。</p><h5 id="CBC（密码分组链接）模式"><a href="#CBC（密码分组链接）模式" class="headerlink" title="CBC（密码分组链接）模式"></a>CBC（密码分组链接）模式</h5><p>CBC模式比ECB模式实现起来复杂，更具有安全性，因此它是最普遍使用的分组密码运行模式。</p><p><img src="https://img-blog.csdnimg.cn/b305fe0eeec24a4ca22e1527c01ab056.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>C<sub>2</sub>和P<sub>1</sub> 、P<sub>2</sub>都有关系</p><p>…….</p><p>C<sub>N</sub>和P<sub>1</sub> 、P<sub>2</sub>，。。</p><p>反复加密解密加密解密，有点盐值的感觉</p><p>喻：利用第一个面团做出了第一个葱油饼；把第一个葱油饼和第二个面团进行和面，做出第二个葱油饼；把第二个葱油饼和第三个面团进行和面，做出第三个葱油饼；。。。</p><p>CBC模式的特性：</p><p>（1）能够隐蔽明文数据的格式规律和统计特性，相同的明文分组产生不同的密文分组。</p><p>（2）CBC模式各密文分组不仅与当前明文组有关，而且还通过反馈作用与以前明文组有关。</p><p>（3）具有错误传播。</p><p>一旦一个密文分组损坏，就会影响后面的进行</p><h5 id="CFB（密码反馈）模式"><a href="#CFB（密码反馈）模式" class="headerlink" title="CFB（密码反馈）模式"></a>CFB（密码反馈）模式</h5><p>DES是分组长度为64bit的分组密码，但利用CFB模式或OFB模式可将DES转换为序列密码（流密码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DES-CFB与DES的一个重要不同：</span><br><span class="line">DES没有直接作用于明文分组，DES仅用来产生密钥了。</span><br><span class="line">DES-CFB中明文加密：</span><br><span class="line">直接与密钥做异或！</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/469f6b710be64046be14897a07db8282.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>加密算法输出的最左（最高有效位）j比特与明文的第一组P<sub>1</sub>进行异或，产生出1组j比特密文C<sub>1</sub>  ,    然后将移位寄存器的内容左移j位，并将C<sub>1</sub> 送入移位寄存器最右边（最低有效位）j 位。</p><p>CFB模式实际上是 一种自同步序列密码，分组密码算法用来提供复杂的非线性逻辑的密钥流生成器作用，若待加密消息必须按字符（如电传电报）或按比特处理，可采用CFB模式。CFB实际上是将加密算法DES作为一个密钥流产生器，当j=1时就退化为流密码。</p><p>密文分组C<sub>i</sub> 依赖于P<sub>i</sub> 和前面的所有明文分组。</p><h5 id="OFB（输出反馈）模式"><a href="#OFB（输出反馈）模式" class="headerlink" title="OFB（输出反馈）模式"></a>OFB（输出反馈）模式</h5><p>OFB模式的结构类似于CFB，将分组密码算法作为一个密钥流产生器。</p><p>与CFB模式相比不同之处如下：CFB模式是将密文单元反馈到移位寄存器，而OFB模式是将加密算法的输出反馈到移位寄存器</p><p><img src="https://pic2.zhimg.com/v2-942f1bd34096a8278766cabc74fd4765_r.jpg" alt="preview"></p><p>OFB模式传输过程中的比特错误不会被传播</p><h5 id="CTR（计数器）模式"><a href="#CTR（计数器）模式" class="headerlink" title="CTR（计数器）模式"></a>CTR（计数器）模式</h5><p>与CFB、OFB模式类似，CTR模式也是将分组密码作为序列密码密钥流生成器，CTR模式加密和解密采用相同方案，都使用加密函数而非解密函数。CTR模式实际就是一种通过逐次累加的计数器进行的加密来产生密钥流的序列密码。</p><p><img src="https://img-blog.csdnimg.cn/d183ac3ef8d7460a9310d69514422fa8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>CTR模式的特性：</p><p>（1）CTR模式能够对多个分组的加密、解密进行并行处理。</p><p>（2）密文分组的处理与其他密文无关，易于实现。</p><h3 id="分组密码算法的安全性分析"><a href="#分组密码算法的安全性分析" class="headerlink" title="分组密码算法的安全性分析"></a>分组密码算法的安全性分析</h3><h4 id="分组密码算法的分析方法"><a href="#分组密码算法的分析方法" class="headerlink" title="分组密码算法的分析方法"></a>分组密码算法的分析方法</h4><p>分组密码算法分析主要有基于数学方法的分析方法、结合物理实现方法的侧信道密码分析方法和强力攻击。</p><h5 id="基于数学方法的分析方法"><a href="#基于数学方法的分析方法" class="headerlink" title="基于数学方法的分析方法"></a>基于数学方法的分析方法</h5><p>自20世纪90年代提出差分分析和线性分析对DES算法成功破解以来，差分分析和线性分析成为了分组密码最有效的基于数学的分析方法。</p><p>（”对DES成功破解“ 有点夸大，最多也就是 找到密钥（或者子密钥）的部分信息。 对于一个新的分组密码算法来说，能抵挡差分分析和线性分析，这是最基本的要求。）</p><h5 id="结合物理实现方法的侧信道密码分析方法"><a href="#结合物理实现方法的侧信道密码分析方法" class="headerlink" title="结合物理实现方法的侧信道密码分析方法"></a>结合物理实现方法的侧信道密码分析方法</h5><p>结合密码算法具体实现所处的物理环境，通过探测密码算法在运行过程中泄露的某些侧信息，例如温度、时间、能量、电磁、声音等信息的差异，来推断密钥信息。这种结合物理实现方法的攻击方式一般称为侧信道攻击（边信道攻击）。</p><h5 id="强力攻击"><a href="#强力攻击" class="headerlink" title="强力攻击"></a>强力攻击</h5><p>1）穷举密钥搜索攻击</p><p>随着计算机计算力的快速提高，之前理论上安全的一些密码算法也变得不安全，如密钥长度为256bit的DES算法穷举攻击可行。</p><h4 id="差分分析"><a href="#差分分析" class="headerlink" title="差分分析"></a>差分分析</h4><p>差分分析是迄今已知最有效的攻击迭代密码的算法之一，差分分析适用于有固定S盒的密码算法</p><p>确定最后一轮的子密钥或其中一部分是可行的</p><p><img src="https://img-blog.csdnimg.cn/721976253c944c31ba122d696f8afeee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇（分组密码体制）&quot;&gt;&lt;a href=&quot;#密码学之理论篇（分组密码体制）&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇（分组密码体制）&quot;&gt;&lt;/a&gt;密码学之理论篇（分组密码体制）&lt;/h1&gt;&lt;h1 id=&quot;四、分组密码体制&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学之理论篇（概述及古典密码学）</title>
    <link href="http://example.com/2021/12/01/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/12/01/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2021-12-05T02:51:50.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学之理论篇（概述及古典密码学）"><a href="#密码学之理论篇（概述及古典密码学）" class="headerlink" title="密码学之理论篇（概述及古典密码学）"></a>密码学之理论篇（概述及古典密码学）</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-1-密码学在信息安全中的作用"><a href="#1-1-1-密码学在信息安全中的作用" class="headerlink" title="1.1.1 密码学在信息安全中的作用"></a>1.1.1 密码学在信息安全中的作用</h3><p>密码学是信息安全的基石，是信息安全的核心技术。</p><p>密码学绝不是保证信息安全的唯一技术，确保信息安全，除了技术之外，管理也是非常重要的一个方面。（安全管理的重要性）</p><h3 id="1-1-2密码学的发展历程"><a href="#1-1-2密码学的发展历程" class="headerlink" title="1.1.2密码学的发展历程"></a>1.1.2密码学的发展历程</h3><p>古典密码学阶段，密码学基本上可以说是一门技巧性很强的艺术（玩不来艺术，呜呜呜），而不是一门科学。</p><p>1949年，香农在《贝尔系统技术》杂志上发表了<strong>“保密系统的通信理论”</strong> ，为密码学奠定了坚实的理论基础，是密码学真正成了一门科学。</p><p>1976年，W.E.Diffie 和 M.E.Hellman发表了《密码学新方向》一文，提出了一种全新的密码设计思想，导致了密码学史上的一场革命，，，公钥密码学或非对称密钥密码学</p><p>1977年美国国家标准局，正式公布了数据加密标准DES</p><p>1978年 R.L.Rivest    A.Shamir  L.Adleman确立了RSA公钥密码学，成为了公钥密码学的杰出代表。</p><p>1984年 Charles H.Bennett和Brassard Gille首次提出了量子密码学，他可以发现窃听等攻击。</p><p>1985年，N.Koblitz 和 V.Miller 把椭圆曲线理论运用到公钥密码学中</p><p>于此同时——-序列密码，主要用于政府、军事等国家要害部门，1989年 R.Mathews    D.Wheeler      L.M.Pecora 和 Carroll等人首次把混沌理论使用到序列密码及保密通信理论中</p><p>1994年,Adleman利用DNA计算解决了一个有向汉米尔顿路径问题，出现了一个新的密码学领域——–DNA密码</p><p>1996年，Ajtai在格问题困难性的基础上，（基于格的公钥密码）</p><p>2000年10月，由比利时密码学家Joan Daemen、Vincent Rijmen</p><p>密码算法成为新一代数据加密标准——-AES算法</p><p>都是大佬膜拜。。</p><h3 id="1-2-密码学的基本知识"><a href="#1-2-密码学的基本知识" class="headerlink" title="1.2 密码学的基本知识"></a>1.2 密码学的基本知识</h3><p>经典密码学包括<strong>密码编码学</strong>和**密码分析学 **  </p><p>密码编码学是研究把信息（明文）变换成没有密钥就不能解读或很难解读的密文的方法。</p><p>密码分析学是研究分析破译密码的方法</p><p>现代密码学除了密码编码学和密码分析学两个学科之外，还包括近几年才形成的新分支——-<strong>密钥密码学</strong>，它是以密钥（现代密码学的核心）及密钥管理作为研究对象的学科</p><p>现代密码学最重要的原则是“一切秘密寓于密钥之中”。即算法是公开的，但密钥必须是保密的。</p><h3 id="1-3-1-保密通信模型"><a href="#1-3-1-保密通信模型" class="headerlink" title="1.3.1 保密通信模型"></a>1.3.1 保密通信模型</h3><p>1949年，香农（C.E.Shannon）发表了一篇题为《保密系统的信息理论》的论文，该论文用信息论的观点对信息保密问题进行了全面的阐述</p><p>香农从概率统计的观点出发研究信息的传输和保密问题，保密系统设计的目的是使窃听者（或攻击者）即使在完全准确地收到了接受信号的情况下，也无法恢复出原始信息。</p><p><img src="https://img-blog.csdnimg.cn/9a6169fc98a1470ab902c170be3c188c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>如果假定信道是无干扰的，则合法的密文接收者能够利用解密变换和密钥从密文中恢复明文，即m=D<sub>k</sub>(c)=D<sub>k</sub>(E<sub>k</sub>(m)).</p><p>此处D为decode解密，E为encode，k为密钥</p><p>假定密码分析者能够从信道上截获密文，还假定密码分析者知道所用的密码体制，还知道明文空间和密钥空间机器统计特性（这就是所谓的Kerckhoffs假设）那么密码体制的安全性完全取决于所选用的密钥的安全性。（密钥的破解难度，以及分发的安全性）</p><p>料敌从宽，锁是公开的，锁芯和钥匙不公开。</p><h3 id="1-3-2密码学基本知识"><a href="#1-3-2密码学基本知识" class="headerlink" title="1.3.2密码学基本知识"></a>1.3.2密码学基本知识</h3><p>一个密码体制或密码算法通常由一下五个部分构成</p><p>（1）明文空间M（全体明文的集合）</p><p>（2）密文空间C（全体密文的集合）</p><p>（3）密钥空间K（全体密钥集合）</p><p>（4）加密器或加密变换（算法）E ，E<sub>k</sub>(m)=c ,m∈M， c∈C, k∈K</p><p>（5）解密器或解密变换（算法）D<sub>k</sub>(c)=m   ,m∈M， c∈C, k∈K</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">明文 message------&gt;M</span><br><span class="line"></span><br><span class="line">密文ciphertext-----&gt;C</span><br><span class="line"></span><br><span class="line">密钥 key----------&gt;K</span><br><span class="line"></span><br><span class="line">加密 enctypt------&gt;E</span><br><span class="line"></span><br><span class="line">解密 dectypt-----&gt;D</span><br></pre></td></tr></table></figure><p>传统密码体制所采用的加密密钥和解密密钥相同，成为<strong>对称密钥密码体制</strong></p><p>最典型的就是美国数据加密标准DES。1976年，在由Diffe和Hellman提出的密码新体制中，加密密钥和解密密钥不同，也不能相互推导，成为公钥或<strong>非对称密钥密码体制</strong>。</p><p>现代密码学普遍依赖于数学</p><p>小结：</p><p>对称密码，可以理解为：锁门时需要用钥匙，开门还需要同样的钥匙。公钥密码，可以理解为：锁门时不需要密钥，锁就在门上挂则呢，按一下就锁上了；开门时需要钥匙。</p><h3 id="1-4密码体制的安全性"><a href="#1-4密码体制的安全性" class="headerlink" title="1.4密码体制的安全性"></a>1.4密码体制的安全性</h3><h3 id="1-4-1密码分析"><a href="#1-4-1密码分析" class="headerlink" title="1.4.1密码分析"></a>1.4.1密码分析</h3><p>密码分析是密码分析者在不知道密钥的情况下，从密文恢复出明文</p><h5 id="1-分析密码算法的方法"><a href="#1-分析密码算法的方法" class="headerlink" title="1.分析密码算法的方法"></a>1.分析密码算法的方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）穷举法：试图试遍所有的明文或密钥来进行破译</span><br><span class="line"></span><br><span class="line">（2）统计分析学：通过分析密文、明文和密钥的统计规律来破译密码技术</span><br><span class="line"></span><br><span class="line">（3）密码体制分析法</span><br></pre></td></tr></table></figure><h5 id="2-对密码体制进行攻击"><a href="#2-对密码体制进行攻击" class="headerlink" title="2.对密码体制进行攻击"></a>2.对密码体制进行攻击</h5><p>（1）唯密文攻击：密码分析者仅知道两样东西：带破译的一些密文和加密算法，并试图恢复尽可能多的明文，并进一步推导出加密信息的密钥。</p><p><strong>只知道 一堆密文 C<sub>1</sub>,C<sub>2</sub>,C<sub>3</sub>…….C<sub>t</sub>以及加密算法E</strong></p><p>（2）已知明文攻击不仅知道一些带破译的密文，还知道与该密文对应的明文，根据明文—密文对试图推导出加密密钥</p><p><strong>知道一堆明密文对(m<sub>1</sub>,c<sub>1</sub>),(m<sub>2</sub>,c<sub>2</sub>),以及加密算法E</strong></p><p>（3）选择明文攻击可以任意选择一些明文，密码分析者用加密算法，并得到相应的密文，然后试图推导出加密密钥</p><p><strong>1.知道加密算法E</strong></p><p><strong>2.挑选一些特殊的更有价值的明文，如m<sub>i1</sub>,m<sub>i2</sub>,…….,m<sub>it</sub></strong></p><p><strong>3.利用加密算法E对选择的明文进行加密，产生密文C<sub>i1</sub>,C<sub>i2</sub>,……..,C<sub>it</sub>这样就得到一些明密文对：</strong></p><p>（m<sub>i1</sub>,c<sub>i1</sub>),(m<sub>i2</sub>,c<sub>i2</sub>),………,(m<sub>it</sub>,c<sub>it</sub>)</p><p>（4）选择密文攻击可以选择不同的密文，以及相应的被破解的明文，并试图推导出加密密钥</p><p>可类比 选择明文攻击 </p><p>（5）选择文本攻击：是选择明文攻击和选择密文攻击的结合</p><p>唯密文攻击是最困难的，因为分析者可利用的信息最少，一个密码体制是安全的，通常是指前三种攻击下是安全的</p><h3 id="1-4-2-密码体制的安全性及安全条件"><a href="#1-4-2-密码体制的安全性及安全条件" class="headerlink" title="1.4.2 密码体制的安全性及安全条件"></a>1.4.2 密码体制的安全性及安全条件</h3><h4 id="1-密码算法的安全性"><a href="#1-密码算法的安全性" class="headerlink" title="1.密码算法的安全性"></a>1.密码算法的安全性</h4><p>现代密码学最重要的原则是“一切秘密寓于密钥之中”，即这些算法的安全性都是基于密钥的安全性，算法是可以公开的，也可以被分析，即使攻击者知道算法也不对算法的安全性构成危害。</p><p>算法公开具有这样一些优点，可以防止算法设计者在算法中隐藏后门；是评估算法安全性的唯一最佳的方式</p><h4 id="2-评价密码体制安全性的方法和条件"><a href="#2-评价密码体制安全性的方法和条件" class="headerlink" title="2.评价密码体制安全性的方法和条件"></a>2.评价密码体制安全性的方法和条件</h4><p>（1）评价密码体制安全性的方法</p><p>​        1)无条件安全：即使破译者提供了无穷的资源，依然无法破译，除一次一密密码算法外，无条件安全算法是不存在的。</p><p>​        2）可证明安全性：将密码算法的安全性归结为某个经过深入研究的数学难题</p><p>​        3）计算机安全性，利用已有的最好的破译方法破译该密码算法所需要的努力超出了破译者的破译能力。</p><p>（2）破译的原则</p><p>​        1）破译密码算法的成本是否超过了被加密信息本身的价值。</p><p>​        2）破译密码的时间是否超过被加密信息有用的生命周期</p><p>​        如果满足上述两个准则之一，则可以认为该密码算法在实际上是安全的</p><h1 id="二、古典密码体制"><a href="#二、古典密码体制" class="headerlink" title="二、古典密码体制"></a>二、古典密码体制</h1><h3 id="2-1-古典密码概述"><a href="#2-1-古典密码概述" class="headerlink" title="2.1 古典密码概述"></a>2.1 古典密码概述</h3><p>古典密码知识对字母进行变换，而现代密码算法是对比特流进行变换。古典密码技术比较简单，是采用手工或机械操作来对明文进行加密和解密的，古典密码技术根据其基本原理大体上可以分为三类：传统隐写术、替换密码技术和换位密码技术。</p><h3 id="2-2传统隐写术"><a href="#2-2传统隐写术" class="headerlink" title="2.2传统隐写术"></a>2.2传统隐写术</h3><p>隐写术将秘密信息隐写于非秘密或者不太秘密的信息中的方法，是信息隐藏的技术之一，如：显隐墨水，藏头诗。</p><p>隐写术也可以用作数字水印。</p><h3 id="2-3替换密码技术"><a href="#2-3替换密码技术" class="headerlink" title="2.3替换密码技术"></a>2.3替换密码技术</h3><h4 id="2-3-1-单字符单表替换密码技术"><a href="#2-3-1-单字符单表替换密码技术" class="headerlink" title="2.3.1 单字符单表替换密码技术"></a>2.3.1 单字符单表替换密码技术</h4><p>单字符单表替换密码技术是对明文中的所有字符都使用一个固定的映射</p><p>（密钥确定之后，同样的明文字符，每次出现时都被加密成同样的密文字符）</p><p>典型的单字符单表替换密码技术有乘法密码技术、加法密码技术、仿射密码技术</p><h5 id="1-乘法密码技术"><a href="#1-乘法密码技术" class="headerlink" title="1.乘法密码技术"></a>1.乘法密码技术</h5><p>加密变换： E<sub>k</sub>(a<sub>i</sub>)=a<sub>j</sub> , j=i*k(mod n ), gcd(k,n)=1</p><p>解密变换：D<sub>k</sub>(a<sub>j</sub>)=a<sub>i</sub> , i=jk<sup>-1</sup>(mod n)                              </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">k是密钥</span><br><span class="line">j=i*k(mod n)    -----&gt;j等于i和k的乘积除u的余数</span><br><span class="line">(k,n)=1 &lt;====&gt; 存在 a,b∈Z ,ak+bn=1 &lt;===&gt; k^-1(mod n)存在，就是a</span><br></pre></td></tr></table></figure><p>例 英文字母n=26，选取密钥k=9，则明文字母到密文字母的替换表</p><p>此时的字母表</p><p><img src="https://img-blog.csdnimg.cn/ff187e192b944eebbb8c242cc92b5703.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHk0MDQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>解题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 字符串转单字符列表，并返回数字序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoc</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    ch_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">        ch_list.append(i)</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">ord</span>(i)-<span class="number">65</span> <span class="keyword">for</span> i <span class="keyword">in</span> ch_list]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Int to Chr</span></span><br><span class="line"><span class="comment"># 将数字序列还原成大写字母序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">itoc</span>(<span class="params">list_int</span>):</span></span><br><span class="line">    A = [<span class="built_in">chr</span>(i+<span class="number">65</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list_int]</span><br><span class="line">    ch = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">        ch += i</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密文序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encrypt</span>(<span class="params">Message,k,n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;使用乘法密码算法进行加密（k=&#123;&#125;, n=&#123;&#125;）&#x27;</span>.<span class="built_in">format</span>(k,n))</span><br><span class="line">    <span class="keyword">return</span> itoc([i*k%n <span class="keyword">for</span> i <span class="keyword">in</span> stoc(Message)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算明文序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span>(<span class="params">Ciphertext,k,n</span>):</span></span><br><span class="line">    <span class="comment"># 解密方式1：通过构建密码表进行查表解密</span></span><br><span class="line">    <span class="comment"># 解密方式2：通过加密逆运算计算明文</span></span><br><span class="line">    DecryptionType = <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(DecryptionType == <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;构建密码表：&#x27;</span>)</span><br><span class="line">        A = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n)]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;明文字母表：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(itoc(A)))</span><br><span class="line">        B = Encrypt(itoc(A),k,n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;密文字母表：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(B))</span><br><span class="line">        CiphertextTables = <span class="built_in">dict</span>(<span class="built_in">zip</span>(B,A))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;构建密码表进行查表解密&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> itoc([CiphertextTables[i] <span class="keyword">for</span> i <span class="keyword">in</span> Ciphertext])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> k1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">            <span class="keyword">if</span>(k1 * k % n == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt;通过加密逆运算进行解密（k的逆元为:&#123;&#125;）&#x27;</span>.<span class="built_in">format</span>(k1))</span><br><span class="line">        <span class="keyword">return</span> itoc([c*k1%n <span class="keyword">for</span> c <span class="keyword">in</span> stoc(Ciphertext)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 当前仅支持大写字母串</span></span><br><span class="line">    A = (<span class="string">&#x27;AMAN&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入的明文字符串为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(A))</span><br><span class="line">    B = Encrypt(A,<span class="number">9</span>,<span class="number">26</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加密后的密文：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(B))</span><br><span class="line">    C = Decrypt(B,<span class="number">9</span>,<span class="number">26</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;解密后的明文：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(C))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-3-2-单字符多表替换密码技术"><a href="#2-3-2-单字符多表替换密码技术" class="headerlink" title="2.3.2 单字符多表替换密码技术"></a>2.3.2 单字符多表替换密码技术</h4><p>单字符多表替换密码技术在安全性方面比单字符表替换密码技术高</p><p>单字符多表替换密码技术有很多，典型的有Vigenere密码技术、Vernam密码技术、Hill密码技术、Playfair密码技术等。</p><h5 id="1-vernam（弗纳姆）密码技术"><a href="#1-vernam（弗纳姆）密码技术" class="headerlink" title="1.vernam（弗纳姆）密码技术"></a>1.vernam（弗纳姆）密码技术</h5><p>设明文m=m<sub>1</sub> , m<sub>2</sub> , ….,密钥k=k<sub>1</sub> ,k<sub>2</sub>  , ……., 其中m<sub>i</sub> , k<sub>i</sub> ∈ GF(2) , i&gt;=1 ,则密文 c = c<sub>1</sub>c<sub>2</sub> …..,</p><p>其中c<sub>i</sub>=m<sub>i</sub>⊕k<sub>i</sub>   .    这里⊕为模2加法</p><p>​            GF(2)={0,1}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">模2加法</span><br><span class="line">规则是两个序列按位相加模二，即两个序列中对应位，相加，不进位，相同为0，不同为1。</span><br><span class="line">1+1=0+0=0</span><br><span class="line">1+0=0+1=1</span><br><span class="line">与计算机位运算符的 异或算法一致 1^1=0 ,0^0=0,1^0=1,0^1=1</span><br></pre></td></tr></table></figure><p>【例2-5】设明文m=01100001，密钥k=01001110，使用Vernam密码加密求密文解:加密得密文:c=m)k=01100001⊕ 01001110=00101111，即密文为00101111.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data=<span class="number">0b01100001</span></span><br><span class="line">key=<span class="number">0b01001110</span></span><br><span class="line">e=data^key</span><br></pre></td></tr></table></figure><h3 id="2-4-换位密码技术"><a href="#2-4-换位密码技术" class="headerlink" title="2.4 换位密码技术"></a>2.4 换位密码技术</h3><p>换位面吗技术本质上就是一种置换密码技术，是重新排列消息中的字母。</p><h4 id="2-4-1列换位"><a href="#2-4-1列换位" class="headerlink" title="2.4.1列换位"></a>2.4.1列换位</h4><p>列换位的原理：首先将明文按照密钥个数排列，然后再按照密钥在字母表中的顺序变换列的顺序，最后按照列的顺序写出的就是英文</p><h3 id="2-5古典密码的安全性分析"><a href="#2-5古典密码的安全性分析" class="headerlink" title="2.5古典密码的安全性分析"></a>2.5古典密码的安全性分析</h3><p>对于代替密码来说，密文中还保留了明文的统计特征，因此可以使用统计方法进行攻击</p><p>英文字母中出现的频率也是有统计规律的</p><p>单字母E出现频率最高</p><p>双字母TH出现频率最高</p><h4 id="2-5-1移位密码安全性分析-（加法密码技术）"><a href="#2-5-1移位密码安全性分析-（加法密码技术）" class="headerlink" title="2.5.1移位密码安全性分析  （加法密码技术）"></a>2.5.1移位密码安全性分析  （加法密码技术）</h4><p>以为密码是极不安全的（mod 26），因为它可被穷举密钥搜索分析，仅有26种可能的密钥</p><h1 id="三、数学基础"><a href="#三、数学基础" class="headerlink" title="三、数学基础"></a>三、数学基础</h1><p><img src="https://img-blog.csdnimg.cn/20210415155325599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA5Nzc2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学之理论篇（概述及古典密码学）&quot;&gt;&lt;a href=&quot;#密码学之理论篇（概述及古典密码学）&quot; class=&quot;headerlink&quot; title=&quot;密码学之理论篇（概述及古典密码学）&quot;&gt;&lt;/a&gt;密码学之理论篇（概述及古典密码学）&lt;/h1&gt;&lt;h2 id=&quot;一、概述&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/11/25/hello-world/"/>
    <id>http://example.com/2021/11/25/hello-world/</id>
    <published>2021-11-24T17:01:56.458Z</published>
    <updated>2021-11-26T15:50:21.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在博客最开头的小论文"><a href="#写在博客最开头的小论文" class="headerlink" title="写在博客最开头的小论文"></a>写在博客最开头的小论文</h1><p>之前想过要不要搭一个博客，但随着学习的深入，越发觉得自己的可能在某些领域没有摸到门道</p><p>如果成了某个领域的佼佼者，再来写这个博客，但是在安全组的培训算是给了一个很好的写文章的机会，</p><p>遂将其斗胆分享出来，里面的内容或有借鉴（cv）或有自己心得，若有侵权请联系我，会及时删掉。</p><p>​                                                                                                                                                QQ:970856057</p><p>​                                                                                                                                                                 鑫缘</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在博客最开头的小论文&quot;&gt;&lt;a href=&quot;#写在博客最开头的小论文&quot; class=&quot;headerlink&quot; title=&quot;写在博客最开头的小论文&quot;&gt;&lt;/a&gt;写在博客最开头的小论文&lt;/h1&gt;&lt;p&gt;之前想过要不要搭一个博客，但随着学习的深入，越发觉得自己的可能在某些</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="http://example.com/2021/11/25/TcpIP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/11/25/TcpIP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-11-24T16:00:00.000Z</published>
    <updated>2021-11-26T15:53:13.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><h2 id="TCP-IP-协议的具体含义"><a href="#TCP-IP-协议的具体含义" class="headerlink" title="TCP/IP 协议的具体含义"></a>TCP/IP 协议的具体含义</h2><p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的<strong>协议群的统称</strong>。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。<br>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><strong>计算机网络体系结构分层</strong></p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/690219fae5b0587fa26e2dee545e6200~tplv-t2oaga2asx-watermark.awebp" alt="计算机网络体系结构分层" style="zoom:150%;" /><p>TCP/IP协议族按照层次<strong>由上到下，层层包装</strong>。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/32269df6363944b0df8fe99204e92c91~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><blockquote><p>上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/7f693d4add34644a6268e0e11bec2cb7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p><p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p><p> A类IP地址: 0.0.0.0<del>127.0.0.0<br>B类IP地址:128.0.0.1</del>191.255.0.0<br>C类IP地址:192.168.0.0~239.255.255.0</p><h3 id="IP协议头"><a href="#IP协议头" class="headerlink" title="IP协议头"></a>IP协议头</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/8/10/dbb082d9806de01f5653423917a1f71b~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p><h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p><blockquote><p>他们的目标都是在程序之间传输数据。<br>数据可以是文本，文件，可以是视频，也可以是图片。对于TCP协议和UDP协议来说，都是一对二进制数，并没有多大的区别。</p></blockquote><p><strong>TCP 是面向连接的、可靠的流协议。</strong>流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p><p><strong>UDP 是不具有可靠性的数据报协议。</strong>细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p><p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。<strong>TCP 和 UDP 应该根据应用的目的按需使用。</strong></p><h2 id="TCPUDP之间的区别是什么？"><a href="#TCPUDP之间的区别是什么？" class="headerlink" title="TCPUDP之间的区别是什么？"></a>TCPUDP之间的区别是什么？</h2><p>最大的区别是一个基于连接，一个基于非连接。<br>我们来举一个简单的例子，如果把人与人的通信比喻为进程与进程的通信，我们基本有两种方式。第一种方式是写信，第二种方式是打电话。</p><p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto3974789fb5ee497a87f35500480b4571" alt="image-20211105125454004"></p><p><strong>TCP是如何保证以上过程的？</strong></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP报文数据包"><a href="#TCP报文数据包" class="headerlink" title="TCP报文数据包"></a>TCP报文数据包</h3><p><img src="https://pic1.zhimg.com/80/v2-63955c8436410907d6fe4697d5bf0b0c_720w.jpg" alt="img"></p><p><img src="https://s1.ax1x.com/2018/03/02/9rzlJf.png" alt="img"></p><h3 id="TCP-首部各字段的意义和作用"><a href="#TCP-首部各字段的意义和作用" class="headerlink" title="TCP 首部各字段的意义和作用"></a>TCP 首部各字段的意义和作用</h3><blockquote><p>TCP首部最小为20字节，这20字节分为5行，每行4个字节也就是32个位。</p><h5 id="源端口和目的端口-Port"><a href="#源端口和目的端口-Port" class="headerlink" title="源端口和目的端口 Port"></a>源端口和目的端口 Port</h5><ul><li>源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。</li><li>目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 分别占用16位，也就是端口号最大是2^16，所以端口号的范围是0~65536</li></ul><p>端口号的分配：</p><ul><li>知名端口号一般位于：1 — 255 之间</li><li>256 — 1023的端口号，通常是由Unix系统占用（系统占用）</li><li>1024 —5000 是大多数TCP、IP实现的临时分配</li><li>大于5000的一般是给其他服务预留的（Internet上并不常用的服务）</li></ul><h5 id="序号-Sequence-Number"><a href="#序号-Sequence-Number" class="headerlink" title="序号 Sequence Number"></a>序号 Sequence Number</h5><p>TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。</p><h5 id="确认号-Acknowledgemt-Number"><a href="#确认号-Acknowledgemt-Number" class="headerlink" title="确认号 Acknowledgemt Number"></a>确认号 Acknowledgemt Number</h5><p>占 4 个字节，表示期望收到对方下一个报文段的序号值。 TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。</p><p>就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。 例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个确认报文，其中的确认号 = 25600.</p><h5 id="数据偏移-Offset"><a href="#数据偏移-Offset" class="headerlink" title="数据偏移 Offset"></a>数据偏移 Offset</h5><p>占 0.5 个字节 (4 位)。 这个字段实际上是指出了 TCP 报文段的首部长度 ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）</p><p>一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。</p><h5 id="保留-Reserved"><a href="#保留-Reserved" class="headerlink" title="保留 Reserved"></a>保留 Reserved</h5><p>占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。</p><h5 id="标志位-TCP-Flags"><a href="#标志位-TCP-Flags" class="headerlink" title="标志位 TCP Flags"></a>标志位 TCP Flags</h5><p>标志位，一共有 6 个，分别占 1 位，共 6 位 。 每一位的值只有 0 和 1，分别表达不同意思。</p><ul><li>ACK：确认序号有效</li><li>RST：重置连接</li><li>SYN：发起了一个新连接</li><li>FIN：释放一个连接</li></ul><h5 id="确认-ACK-Acknowlegemt"><a href="#确认-ACK-Acknowlegemt" class="headerlink" title="确认 ACK (Acknowlegemt)"></a>确认 ACK (Acknowlegemt)</h5><p>当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。</p><p>TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。</p><h5 id="推送-PSH-Push"><a href="#推送-PSH-Push" class="headerlink" title="推送 PSH (Push)"></a>推送 PSH (Push)</h5><p>当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。</p><h5 id="复位-RST-Reset"><a href="#复位-RST-Reset" class="headerlink" title="复位 RST (Reset)"></a>复位 RST (Reset)</h5><p>当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。</p><h5 id="同步-SYN-SYNchronization"><a href="#同步-SYN-SYNchronization" class="headerlink" title="同步 SYN (SYNchronization)"></a>同步 SYN (SYNchronization)</h5><p>当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。</p><p>对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。</p><h5 id="终止-FIN-Finis"><a href="#终止-FIN-Finis" class="headerlink" title="终止 FIN (Finis)"></a>终止 FIN (Finis)</h5><p>当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。</p><p>一般称携带 FIN 的报文段为「结束报文段」。</p><p>在 TCP 四次挥手释放连接的时候，就会用到该标志。</p><h5 id="窗口大小-Window-Size"><a href="#窗口大小-Window-Size" class="headerlink" title="窗口大小 Window Size"></a>窗口大小 Window Size</h5><p>占 2 字节。</p><p>该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。</p><p>例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。</p><h5 id="校验和-TCP-Checksum"><a href="#校验和-TCP-Checksum" class="headerlink" title="校验和 TCP Checksum"></a>校验和 TCP Checksum</h5><p>占 2 个字节。 由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。</p><p>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</p><h5 id="紧急指针-Urgent-Pointer"><a href="#紧急指针-Urgent-Pointer" class="headerlink" title="紧急指针 Urgent Pointer"></a>紧急指针 Urgent Pointer</h5><p>占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。</p><p>因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p></blockquote><p><strong>有三个关键的步骤，分别为三次握手、传输确认、四次挥手。</strong></p><h3 id="TCP的三次握手，四次挥手"><a href="#TCP的三次握手，四次挥手" class="headerlink" title="TCP的三次握手，四次挥手"></a>TCP的三次握手，四次挥手</h3><h4 id="需要了解的信息"><a href="#需要了解的信息" class="headerlink" title="需要了解的信息"></a>需要了解的信息</h4><ul><li>ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li><li>SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</li><li>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li></ul><p>TCP（Transmission Control Protocol，传输控制协议）是 面向连接的协议，也就是说在<strong>收发数据之前，必须先和对方建立连接</strong></p><blockquote><p>一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的 描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数 据。</p></blockquote><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。<strong>三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</strong></p><img src="https://pic2.zhimg.com/80/v2-1587e91f14923eae0fa7d846cb10df99_720w.jpg" alt="img" style="zoom:200%;" /><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入<strong>SYN_SEND</strong>状态，等待服务器的确认；    </p><p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入<strong>SYN_RECV</strong>状态；  </p><p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入<strong>ESTABLISHED</strong>状态，完成TCP三次握手。</p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto098b95dd1e884eefb56a114cbb1a529f"  /><p><strong>为什么要三次握手而不是两次握手？服务端回复完SYN+ACK之后就建立连接</strong></p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>假设采用两次握手建立连接客户端，向服务端发送了一个SYN来请求建立连接。<br>因为某些未知的原因并没有到达服务器在中间某个网络节点产生了滞留。<br>为了建立连接客户端，会重发SYN，这次的数据包正常送达，服务端回复SYN+ACK之后建立起来连接。<br>但是第一包数据阻塞的网络节点突然恢复，第一包省包又送达到服务端。这时服务端会误认为是客户端又发起了一个新的连接，从而在两次握手之后进入等待数据状态。<br><strong>服务端认为是两个连接，而客户端认为是一个连接，造成了状态不一致。</strong><br>如果在三次握手的情况下，服务端收不到最后的ACK自然不会认为连接建立成功。<br>所以三次握手本质上来说就是为了解决网络信道不可靠的问题。为了能够在不可靠的信道上建立起可靠的连接。<br>经过三次握手之后，客户端和服务端都进入了数据传输状态。</p><blockquote><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nnA &#x27;port 9999&#x27;</span><br><span class="line">nc -4vl 9999</span><br><span class="line">telnet swordk.cn 9999</span><br></pre></td></tr></table></figure><h4 id="传输确认"><a href="#传输确认" class="headerlink" title="传输确认"></a>传输确认</h4><p>TCP协议需要在不可靠的信道上保证可靠的连接。现在这有几个问题需要面对。</p><p>一包数据有可能会被拆成多包发送如何处理<strong>丢包</strong>问题？<br>这些数据包到达的先后顺序不同，如何处理<strong>乱序</strong>问题？</p><p><img src="https://590233ee4fbb3.cdn.sohucs.com/auto/1-auto683ac4ddaa994e71a7e04583ee9b9aa5" alt="image-20211105132602749"></p><p>针对这些要求，TCP协议为每一个连接建立了一个发送缓冲区。从建立连接后的第一个字节的序列号为零，后面每个字节的序列号就会增加一。<br>发送数据时，从发送缓冲区取一部分数据组成发送报文，在其TCP协议头中会附带序列号和长度。接收端在收到数据后需要回复确认报文。<br>确认报文中的ACK等于接收序列号加长度，也就是下一包数据需要发送的基础序列号。<br>这样一问一答的发送方式，能够使发送端确认发送的数据已经被对方收到。<br>发送端也可以一次发送连续的多包数据，接收端只需要回复一次ACK就可以了。<br>这样发送端可以把待发送的数据分割成一系列的碎片，发送到对端。对端根据序列号和长度在接收后重构出来完整的数据。<br>假设其中丢失了某些数据方在接收端可以要求发送端重传。比如丢失了100-199，这一百个字节接收端下发送端发送ACK=100的报文。<br>发送端收到后，重传这一包数据，接收端进行补齐。<br>以上过程不区分客户端和服务端，<strong>TCP连接是全双功能，对于两端来说均采用上述机制。</strong></p><hr><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><img src="https://pic2.zhimg.com/80/v2-6e5f05603526c1d259b300f20b8857a5_720w.jpg" alt="img" style="zoom:200%;" /><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p><p><strong>第一次挥手：</strong> 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p><strong>第二次挥手：</strong> 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p><strong>第三次挥手：</strong> 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p><strong>第四次挥手：</strong> 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p><strong>为什么要四次挥手</strong>？</p><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p><strong>为什么客户端需要等待超时时间？</strong></p><p>这是为了保证对方已收到ACK。因为假设客户端发送完最后一包ACK后就释放了连接。一旦ACK在网络中丢失。服务端将一直停留在最后确认状态。</p><p>如果客户端发送最后一个ACK后等待一段时间，这时服务端因为没有收到ACK，会重发FIN。<br>客户端会响应这个分包重发ACK，用刷新超时时间这个机制跟三次握手一样，也是为了<strong>保证在不可靠的网络链路中进行可靠的连接，断开确认。</strong></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP协议是基于非连接的发送数据，就是简单的把数据包封装一下，然后从网卡发出去就可以了。数据包之间并没有状态上的联系。正因为UDP这种简单的处理方式，导致它的性能损耗非常少。对于CPU内存资源的占用也远小于TCP。但是对于网络传输过程中产生的丢包，UDP协议并不能保证。</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-4bcddf13416e9f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="什么时候应该使用TCP？"><a href="#什么时候应该使用TCP？" class="headerlink" title="什么时候应该使用TCP？"></a>什么时候应该使用TCP？</h3><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 </p><h3 id="什么时候应该使用UDP？"><a href="#什么时候应该使用UDP？" class="headerlink" title="什么时候应该使用UDP？"></a>什么时候应该使用UDP？</h3><p>UDP的优点是速度快，但是可能产生丢包。所以适用于对实时性要求较高，但是对少量丢包并没有太大要求的场景，比如域名查询与云通话、视频直播等。</p><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><table><thead><tr><th align="left">端口</th><th align="left">服务</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">21</td><td align="left">FTP</td><td align="left">FTP 服务器所开放的端口，用于上传、下载</td></tr><tr><td align="left">22</td><td align="left">SSH</td><td align="left">22 端口就是 ssh 端口，用于通过命令行模式远程连接 Linux 系统服务器</td></tr><tr><td align="left">25</td><td align="left">SMTP</td><td align="left">SMTP 服务器所开放的端口，用于发送邮件</td></tr><tr><td align="left">80</td><td align="left">HTTP</td><td align="left">用于网站服务例如 IIS、Apache、Nginx 等提供对外访问</td></tr><tr><td align="left">110</td><td align="left">POP3</td><td align="left">110 端口是为 POP3（邮件协议 3）服务开放的</td></tr><tr><td align="left">137/138/139</td><td align="left">NETBIOS</td><td align="left">其中 137、138 是 UDP 端口，当通过网上邻居传输文件时用这个端口。而 139 端口：通过这个端口进入的连接试图获得 NetBIOS/SMB 服务。这个协议被用于 windows 文件和打印机共享和 SAMBA</td></tr><tr><td align="left">143</td><td align="left">IMAP</td><td align="left">143 端口主要是用于“Internet Message AccessProtocol”v2（Internet 消息访问协议，简称 IMAP），和 POP3 一样，是用于电子邮件的接收的协议</td></tr><tr><td align="left">443</td><td align="left">HTTPS</td><td align="left">网页浏览端口，能提供加密和通过安全端口传输的另一种 HTTP</td></tr><tr><td align="left">1433</td><td align="left">SQL Server</td><td align="left">1433 端口，是 SQL Server 默认的端口，SQL Server 服务使用两个端口：TCP-1433、UDP-1434。其中 1433 用于供 SQL Server 对外提供服务，1434 用于向请求者返回 SQL Server 使用了哪个 TCP/IP 端口</td></tr><tr><td align="left">3306</td><td align="left">MySQL</td><td align="left">3306 端口，是 MySQL 数据库的默认端口，用于 MySQL 对外提供服务</td></tr><tr><td align="left">3389</td><td align="left">Windows Server Remote Desktop Services</td><td align="left">3389 端口是 Windows 远程桌面的服务端口，可以通过这个端口，用 “远程桌面” 等连接工具来连接到远程的服务器</td></tr><tr><td align="left">8080</td><td align="left">代理端口</td><td align="left">8080 端口同 80 端口，是被用于 WWW 代理服务的，可以实现网页浏览，经常在访问某个网站或使用代理服务器的时候，会加上 “:8080” 端口号。另外 Apache Tomcat web server 安装后，默认的服务端口就是 8080</td></tr></tbody></table><p>in the end</p><p>转自：brey.cn</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-IP协议&quot;&gt;&lt;a href=&quot;#TCP-IP协议&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议&quot;&gt;&lt;/a&gt;TCP/IP协议&lt;/h1&gt;&lt;h2 id=&quot;TCP-IP-协议的具体含义&quot;&gt;&lt;a href=&quot;#TCP-IP-协议的具体含义&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
